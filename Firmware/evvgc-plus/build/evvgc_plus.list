
build/evvgc_plus.elf:     file format elf32-littlearm


Disassembly of section .text:

08000160 <Reset_Handler>:
 8000160:	b672      	cpsid	i
 8000162:	4822      	ldr	r0, [pc, #136]	; (80001ec <endfiniloop+0x4>)
 8000164:	f380 8809 	msr	PSP, r0
 8000168:	2002      	movs	r0, #2
 800016a:	f380 8814 	msr	CONTROL, r0
 800016e:	f3bf 8f6f 	isb	sy
 8000172:	f001 f835 	bl	80011e0 <__core_init>
 8000176:	f003 f96b 	bl	8003450 <__early_init>
 800017a:	481d      	ldr	r0, [pc, #116]	; (80001f0 <endfiniloop+0x8>)
 800017c:	491d      	ldr	r1, [pc, #116]	; (80001f4 <endfiniloop+0xc>)
 800017e:	4a1e      	ldr	r2, [pc, #120]	; (80001f8 <endfiniloop+0x10>)

08000180 <msloop>:
 8000180:	4291      	cmp	r1, r2
 8000182:	bf3c      	itt	cc
 8000184:	f841 0b04 	strcc.w	r0, [r1], #4
 8000188:	e7fa      	bcc.n	8000180 <msloop>
 800018a:	491c      	ldr	r1, [pc, #112]	; (80001fc <endfiniloop+0x14>)
 800018c:	4a17      	ldr	r2, [pc, #92]	; (80001ec <endfiniloop+0x4>)

0800018e <psloop>:
 800018e:	4291      	cmp	r1, r2
 8000190:	bf3c      	itt	cc
 8000192:	f841 0b04 	strcc.w	r0, [r1], #4
 8000196:	e7fa      	bcc.n	800018e <psloop>
 8000198:	4919      	ldr	r1, [pc, #100]	; (8000200 <endfiniloop+0x18>)
 800019a:	4a1a      	ldr	r2, [pc, #104]	; (8000204 <endfiniloop+0x1c>)
 800019c:	4b1a      	ldr	r3, [pc, #104]	; (8000208 <endfiniloop+0x20>)

0800019e <dloop>:
 800019e:	429a      	cmp	r2, r3
 80001a0:	bf3e      	ittt	cc
 80001a2:	f851 0b04 	ldrcc.w	r0, [r1], #4
 80001a6:	f842 0b04 	strcc.w	r0, [r2], #4
 80001aa:	e7f8      	bcc.n	800019e <dloop>
 80001ac:	2000      	movs	r0, #0
 80001ae:	4917      	ldr	r1, [pc, #92]	; (800020c <endfiniloop+0x24>)
 80001b0:	4a17      	ldr	r2, [pc, #92]	; (8000210 <endfiniloop+0x28>)

080001b2 <bloop>:
 80001b2:	4291      	cmp	r1, r2
 80001b4:	bf3c      	itt	cc
 80001b6:	f841 0b04 	strcc.w	r0, [r1], #4
 80001ba:	e7fa      	bcc.n	80001b2 <bloop>
 80001bc:	f001 f828 	bl	8001210 <__init_ram_areas>
 80001c0:	f001 f816 	bl	80011f0 <__late_init>
 80001c4:	4c13      	ldr	r4, [pc, #76]	; (8000214 <endfiniloop+0x2c>)
 80001c6:	4d14      	ldr	r5, [pc, #80]	; (8000218 <endfiniloop+0x30>)

080001c8 <initloop>:
 80001c8:	42ac      	cmp	r4, r5
 80001ca:	da03      	bge.n	80001d4 <endinitloop>
 80001cc:	f854 1b04 	ldr.w	r1, [r4], #4
 80001d0:	4788      	blx	r1
 80001d2:	e7f9      	b.n	80001c8 <initloop>

080001d4 <endinitloop>:
 80001d4:	f003 fd4c 	bl	8003c70 <main>
 80001d8:	4c10      	ldr	r4, [pc, #64]	; (800021c <endfiniloop+0x34>)
 80001da:	4d11      	ldr	r5, [pc, #68]	; (8000220 <endfiniloop+0x38>)

080001dc <finiloop>:
 80001dc:	42ac      	cmp	r4, r5
 80001de:	da03      	bge.n	80001e8 <endfiniloop>
 80001e0:	f854 1b04 	ldr.w	r1, [r4], #4
 80001e4:	4788      	blx	r1
 80001e6:	e7f9      	b.n	80001dc <finiloop>

080001e8 <endfiniloop>:
 80001e8:	f001 b80a 	b.w	8001200 <__default_exit>
 80001ec:	20000800 	.word	0x20000800
 80001f0:	55555555 	.word	0x55555555
 80001f4:	20000000 	.word	0x20000000
 80001f8:	20000400 	.word	0x20000400
 80001fc:	20000400 	.word	0x20000400
 8000200:	080048f0 	.word	0x080048f0
 8000204:	20000800 	.word	0x20000800
 8000208:	200008ec 	.word	0x200008ec
 800020c:	200008f0 	.word	0x200008f0
 8000210:	20001144 	.word	0x20001144
 8000214:	08000160 	.word	0x08000160
 8000218:	08000160 	.word	0x08000160
 800021c:	08000160 	.word	0x08000160
 8000220:	08000160 	.word	0x08000160
	...

08000230 <_port_switch>:
 8000230:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8000234:	f8c1 d00c 	str.w	sp, [r1, #12]
 8000238:	68c3      	ldr	r3, [r0, #12]
 800023a:	469d      	mov	sp, r3
 800023c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

08000240 <_port_thread_start>:
 8000240:	2300      	movs	r3, #0
 8000242:	f383 8811 	msr	BASEPRI, r3
 8000246:	4628      	mov	r0, r5
 8000248:	47a0      	blx	r4
 800024a:	2000      	movs	r0, #0
 800024c:	f001 fa48 	bl	80016e0 <chThdExit>

08000250 <_port_switch_from_isr>:
 8000250:	f001 f9c6 	bl	80015e0 <chSchDoReschedule>

08000254 <_port_exit_from_isr>:
 8000254:	df00      	svc	0
 8000256:	e7fe      	b.n	8000256 <_port_exit_from_isr+0x2>
	...

08000260 <__aeabi_drsub>:
 8000260:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000
 8000264:	e002      	b.n	800026c <__adddf3>
 8000266:	bf00      	nop

08000268 <__aeabi_dsub>:
 8000268:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000

0800026c <__adddf3>:
 800026c:	b530      	push	{r4, r5, lr}
 800026e:	ea4f 0441 	mov.w	r4, r1, lsl #1
 8000272:	ea4f 0543 	mov.w	r5, r3, lsl #1
 8000276:	ea94 0f05 	teq	r4, r5
 800027a:	bf08      	it	eq
 800027c:	ea90 0f02 	teqeq	r0, r2
 8000280:	bf1f      	itttt	ne
 8000282:	ea54 0c00 	orrsne.w	ip, r4, r0
 8000286:	ea55 0c02 	orrsne.w	ip, r5, r2
 800028a:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
 800028e:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 8000292:	f000 80e2 	beq.w	800045a <__adddf3+0x1ee>
 8000296:	ea4f 5454 	mov.w	r4, r4, lsr #21
 800029a:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
 800029e:	bfb8      	it	lt
 80002a0:	426d      	neglt	r5, r5
 80002a2:	dd0c      	ble.n	80002be <__adddf3+0x52>
 80002a4:	442c      	add	r4, r5
 80002a6:	ea80 0202 	eor.w	r2, r0, r2
 80002aa:	ea81 0303 	eor.w	r3, r1, r3
 80002ae:	ea82 0000 	eor.w	r0, r2, r0
 80002b2:	ea83 0101 	eor.w	r1, r3, r1
 80002b6:	ea80 0202 	eor.w	r2, r0, r2
 80002ba:	ea81 0303 	eor.w	r3, r1, r3
 80002be:	2d36      	cmp	r5, #54	; 0x36
 80002c0:	bf88      	it	hi
 80002c2:	bd30      	pophi	{r4, r5, pc}
 80002c4:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 80002c8:	ea4f 3101 	mov.w	r1, r1, lsl #12
 80002cc:	f44f 1c80 	mov.w	ip, #1048576	; 0x100000
 80002d0:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
 80002d4:	d002      	beq.n	80002dc <__adddf3+0x70>
 80002d6:	4240      	negs	r0, r0
 80002d8:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 80002dc:	f013 4f00 	tst.w	r3, #2147483648	; 0x80000000
 80002e0:	ea4f 3303 	mov.w	r3, r3, lsl #12
 80002e4:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
 80002e8:	d002      	beq.n	80002f0 <__adddf3+0x84>
 80002ea:	4252      	negs	r2, r2
 80002ec:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 80002f0:	ea94 0f05 	teq	r4, r5
 80002f4:	f000 80a7 	beq.w	8000446 <__adddf3+0x1da>
 80002f8:	f1a4 0401 	sub.w	r4, r4, #1
 80002fc:	f1d5 0e20 	rsbs	lr, r5, #32
 8000300:	db0d      	blt.n	800031e <__adddf3+0xb2>
 8000302:	fa02 fc0e 	lsl.w	ip, r2, lr
 8000306:	fa22 f205 	lsr.w	r2, r2, r5
 800030a:	1880      	adds	r0, r0, r2
 800030c:	f141 0100 	adc.w	r1, r1, #0
 8000310:	fa03 f20e 	lsl.w	r2, r3, lr
 8000314:	1880      	adds	r0, r0, r2
 8000316:	fa43 f305 	asr.w	r3, r3, r5
 800031a:	4159      	adcs	r1, r3
 800031c:	e00e      	b.n	800033c <__adddf3+0xd0>
 800031e:	f1a5 0520 	sub.w	r5, r5, #32
 8000322:	f10e 0e20 	add.w	lr, lr, #32
 8000326:	2a01      	cmp	r2, #1
 8000328:	fa03 fc0e 	lsl.w	ip, r3, lr
 800032c:	bf28      	it	cs
 800032e:	f04c 0c02 	orrcs.w	ip, ip, #2
 8000332:	fa43 f305 	asr.w	r3, r3, r5
 8000336:	18c0      	adds	r0, r0, r3
 8000338:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
 800033c:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 8000340:	d507      	bpl.n	8000352 <__adddf3+0xe6>
 8000342:	f04f 0e00 	mov.w	lr, #0
 8000346:	f1dc 0c00 	rsbs	ip, ip, #0
 800034a:	eb7e 0000 	sbcs.w	r0, lr, r0
 800034e:	eb6e 0101 	sbc.w	r1, lr, r1
 8000352:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
 8000356:	d31b      	bcc.n	8000390 <__adddf3+0x124>
 8000358:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
 800035c:	d30c      	bcc.n	8000378 <__adddf3+0x10c>
 800035e:	0849      	lsrs	r1, r1, #1
 8000360:	ea5f 0030 	movs.w	r0, r0, rrx
 8000364:	ea4f 0c3c 	mov.w	ip, ip, rrx
 8000368:	f104 0401 	add.w	r4, r4, #1
 800036c:	ea4f 5244 	mov.w	r2, r4, lsl #21
 8000370:	f512 0f80 	cmn.w	r2, #4194304	; 0x400000
 8000374:	f080 809a 	bcs.w	80004ac <__adddf3+0x240>
 8000378:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
 800037c:	bf08      	it	eq
 800037e:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 8000382:	f150 0000 	adcs.w	r0, r0, #0
 8000386:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 800038a:	ea41 0105 	orr.w	r1, r1, r5
 800038e:	bd30      	pop	{r4, r5, pc}
 8000390:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
 8000394:	4140      	adcs	r0, r0
 8000396:	eb41 0101 	adc.w	r1, r1, r1
 800039a:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 800039e:	f1a4 0401 	sub.w	r4, r4, #1
 80003a2:	d1e9      	bne.n	8000378 <__adddf3+0x10c>
 80003a4:	f091 0f00 	teq	r1, #0
 80003a8:	bf04      	itt	eq
 80003aa:	4601      	moveq	r1, r0
 80003ac:	2000      	moveq	r0, #0
 80003ae:	fab1 f381 	clz	r3, r1
 80003b2:	bf08      	it	eq
 80003b4:	3320      	addeq	r3, #32
 80003b6:	f1a3 030b 	sub.w	r3, r3, #11
 80003ba:	f1b3 0220 	subs.w	r2, r3, #32
 80003be:	da0c      	bge.n	80003da <__adddf3+0x16e>
 80003c0:	320c      	adds	r2, #12
 80003c2:	dd08      	ble.n	80003d6 <__adddf3+0x16a>
 80003c4:	f102 0c14 	add.w	ip, r2, #20
 80003c8:	f1c2 020c 	rsb	r2, r2, #12
 80003cc:	fa01 f00c 	lsl.w	r0, r1, ip
 80003d0:	fa21 f102 	lsr.w	r1, r1, r2
 80003d4:	e00c      	b.n	80003f0 <__adddf3+0x184>
 80003d6:	f102 0214 	add.w	r2, r2, #20
 80003da:	bfd8      	it	le
 80003dc:	f1c2 0c20 	rsble	ip, r2, #32
 80003e0:	fa01 f102 	lsl.w	r1, r1, r2
 80003e4:	fa20 fc0c 	lsr.w	ip, r0, ip
 80003e8:	bfdc      	itt	le
 80003ea:	ea41 010c 	orrle.w	r1, r1, ip
 80003ee:	4090      	lslle	r0, r2
 80003f0:	1ae4      	subs	r4, r4, r3
 80003f2:	bfa2      	ittt	ge
 80003f4:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
 80003f8:	4329      	orrge	r1, r5
 80003fa:	bd30      	popge	{r4, r5, pc}
 80003fc:	ea6f 0404 	mvn.w	r4, r4
 8000400:	3c1f      	subs	r4, #31
 8000402:	da1c      	bge.n	800043e <__adddf3+0x1d2>
 8000404:	340c      	adds	r4, #12
 8000406:	dc0e      	bgt.n	8000426 <__adddf3+0x1ba>
 8000408:	f104 0414 	add.w	r4, r4, #20
 800040c:	f1c4 0220 	rsb	r2, r4, #32
 8000410:	fa20 f004 	lsr.w	r0, r0, r4
 8000414:	fa01 f302 	lsl.w	r3, r1, r2
 8000418:	ea40 0003 	orr.w	r0, r0, r3
 800041c:	fa21 f304 	lsr.w	r3, r1, r4
 8000420:	ea45 0103 	orr.w	r1, r5, r3
 8000424:	bd30      	pop	{r4, r5, pc}
 8000426:	f1c4 040c 	rsb	r4, r4, #12
 800042a:	f1c4 0220 	rsb	r2, r4, #32
 800042e:	fa20 f002 	lsr.w	r0, r0, r2
 8000432:	fa01 f304 	lsl.w	r3, r1, r4
 8000436:	ea40 0003 	orr.w	r0, r0, r3
 800043a:	4629      	mov	r1, r5
 800043c:	bd30      	pop	{r4, r5, pc}
 800043e:	fa21 f004 	lsr.w	r0, r1, r4
 8000442:	4629      	mov	r1, r5
 8000444:	bd30      	pop	{r4, r5, pc}
 8000446:	f094 0f00 	teq	r4, #0
 800044a:	f483 1380 	eor.w	r3, r3, #1048576	; 0x100000
 800044e:	bf06      	itte	eq
 8000450:	f481 1180 	eoreq.w	r1, r1, #1048576	; 0x100000
 8000454:	3401      	addeq	r4, #1
 8000456:	3d01      	subne	r5, #1
 8000458:	e74e      	b.n	80002f8 <__adddf3+0x8c>
 800045a:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 800045e:	bf18      	it	ne
 8000460:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 8000464:	d029      	beq.n	80004ba <__adddf3+0x24e>
 8000466:	ea94 0f05 	teq	r4, r5
 800046a:	bf08      	it	eq
 800046c:	ea90 0f02 	teqeq	r0, r2
 8000470:	d005      	beq.n	800047e <__adddf3+0x212>
 8000472:	ea54 0c00 	orrs.w	ip, r4, r0
 8000476:	bf04      	itt	eq
 8000478:	4619      	moveq	r1, r3
 800047a:	4610      	moveq	r0, r2
 800047c:	bd30      	pop	{r4, r5, pc}
 800047e:	ea91 0f03 	teq	r1, r3
 8000482:	bf1e      	ittt	ne
 8000484:	2100      	movne	r1, #0
 8000486:	2000      	movne	r0, #0
 8000488:	bd30      	popne	{r4, r5, pc}
 800048a:	ea5f 5c54 	movs.w	ip, r4, lsr #21
 800048e:	d105      	bne.n	800049c <__adddf3+0x230>
 8000490:	0040      	lsls	r0, r0, #1
 8000492:	4149      	adcs	r1, r1
 8000494:	bf28      	it	cs
 8000496:	f041 4100 	orrcs.w	r1, r1, #2147483648	; 0x80000000
 800049a:	bd30      	pop	{r4, r5, pc}
 800049c:	f514 0480 	adds.w	r4, r4, #4194304	; 0x400000
 80004a0:	bf3c      	itt	cc
 80004a2:	f501 1180 	addcc.w	r1, r1, #1048576	; 0x100000
 80004a6:	bd30      	popcc	{r4, r5, pc}
 80004a8:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 80004ac:	f045 41fe 	orr.w	r1, r5, #2130706432	; 0x7f000000
 80004b0:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 80004b4:	f04f 0000 	mov.w	r0, #0
 80004b8:	bd30      	pop	{r4, r5, pc}
 80004ba:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 80004be:	bf1a      	itte	ne
 80004c0:	4619      	movne	r1, r3
 80004c2:	4610      	movne	r0, r2
 80004c4:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
 80004c8:	bf1c      	itt	ne
 80004ca:	460b      	movne	r3, r1
 80004cc:	4602      	movne	r2, r0
 80004ce:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 80004d2:	bf06      	itte	eq
 80004d4:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
 80004d8:	ea91 0f03 	teqeq	r1, r3
 80004dc:	f441 2100 	orrne.w	r1, r1, #524288	; 0x80000
 80004e0:	bd30      	pop	{r4, r5, pc}
 80004e2:	bf00      	nop

080004e4 <__aeabi_ui2d>:
 80004e4:	f090 0f00 	teq	r0, #0
 80004e8:	bf04      	itt	eq
 80004ea:	2100      	moveq	r1, #0
 80004ec:	4770      	bxeq	lr
 80004ee:	b530      	push	{r4, r5, lr}
 80004f0:	f44f 6480 	mov.w	r4, #1024	; 0x400
 80004f4:	f104 0432 	add.w	r4, r4, #50	; 0x32
 80004f8:	f04f 0500 	mov.w	r5, #0
 80004fc:	f04f 0100 	mov.w	r1, #0
 8000500:	e750      	b.n	80003a4 <__adddf3+0x138>
 8000502:	bf00      	nop

08000504 <__aeabi_i2d>:
 8000504:	f090 0f00 	teq	r0, #0
 8000508:	bf04      	itt	eq
 800050a:	2100      	moveq	r1, #0
 800050c:	4770      	bxeq	lr
 800050e:	b530      	push	{r4, r5, lr}
 8000510:	f44f 6480 	mov.w	r4, #1024	; 0x400
 8000514:	f104 0432 	add.w	r4, r4, #50	; 0x32
 8000518:	f010 4500 	ands.w	r5, r0, #2147483648	; 0x80000000
 800051c:	bf48      	it	mi
 800051e:	4240      	negmi	r0, r0
 8000520:	f04f 0100 	mov.w	r1, #0
 8000524:	e73e      	b.n	80003a4 <__adddf3+0x138>
 8000526:	bf00      	nop

08000528 <__aeabi_f2d>:
 8000528:	0042      	lsls	r2, r0, #1
 800052a:	ea4f 01e2 	mov.w	r1, r2, asr #3
 800052e:	ea4f 0131 	mov.w	r1, r1, rrx
 8000532:	ea4f 7002 	mov.w	r0, r2, lsl #28
 8000536:	bf1f      	itttt	ne
 8000538:	f012 437f 	andsne.w	r3, r2, #4278190080	; 0xff000000
 800053c:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
 8000540:	f081 5160 	eorne.w	r1, r1, #939524096	; 0x38000000
 8000544:	4770      	bxne	lr
 8000546:	f092 0f00 	teq	r2, #0
 800054a:	bf14      	ite	ne
 800054c:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
 8000550:	4770      	bxeq	lr
 8000552:	b530      	push	{r4, r5, lr}
 8000554:	f44f 7460 	mov.w	r4, #896	; 0x380
 8000558:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 800055c:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 8000560:	e720      	b.n	80003a4 <__adddf3+0x138>
 8000562:	bf00      	nop

08000564 <__aeabi_ul2d>:
 8000564:	ea50 0201 	orrs.w	r2, r0, r1
 8000568:	bf08      	it	eq
 800056a:	4770      	bxeq	lr
 800056c:	b530      	push	{r4, r5, lr}
 800056e:	f04f 0500 	mov.w	r5, #0
 8000572:	e00a      	b.n	800058a <__aeabi_l2d+0x16>

08000574 <__aeabi_l2d>:
 8000574:	ea50 0201 	orrs.w	r2, r0, r1
 8000578:	bf08      	it	eq
 800057a:	4770      	bxeq	lr
 800057c:	b530      	push	{r4, r5, lr}
 800057e:	f011 4500 	ands.w	r5, r1, #2147483648	; 0x80000000
 8000582:	d502      	bpl.n	800058a <__aeabi_l2d+0x16>
 8000584:	4240      	negs	r0, r0
 8000586:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 800058a:	f44f 6480 	mov.w	r4, #1024	; 0x400
 800058e:	f104 0432 	add.w	r4, r4, #50	; 0x32
 8000592:	ea5f 5c91 	movs.w	ip, r1, lsr #22
 8000596:	f43f aedc 	beq.w	8000352 <__adddf3+0xe6>
 800059a:	f04f 0203 	mov.w	r2, #3
 800059e:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 80005a2:	bf18      	it	ne
 80005a4:	3203      	addne	r2, #3
 80005a6:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 80005aa:	bf18      	it	ne
 80005ac:	3203      	addne	r2, #3
 80005ae:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
 80005b2:	f1c2 0320 	rsb	r3, r2, #32
 80005b6:	fa00 fc03 	lsl.w	ip, r0, r3
 80005ba:	fa20 f002 	lsr.w	r0, r0, r2
 80005be:	fa01 fe03 	lsl.w	lr, r1, r3
 80005c2:	ea40 000e 	orr.w	r0, r0, lr
 80005c6:	fa21 f102 	lsr.w	r1, r1, r2
 80005ca:	4414      	add	r4, r2
 80005cc:	e6c1      	b.n	8000352 <__adddf3+0xe6>
 80005ce:	bf00      	nop

080005d0 <__aeabi_dmul>:
 80005d0:	b570      	push	{r4, r5, r6, lr}
 80005d2:	f04f 0cff 	mov.w	ip, #255	; 0xff
 80005d6:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
 80005da:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 80005de:	bf1d      	ittte	ne
 80005e0:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 80005e4:	ea94 0f0c 	teqne	r4, ip
 80005e8:	ea95 0f0c 	teqne	r5, ip
 80005ec:	f000 f8de 	bleq	80007ac <__aeabi_dmul+0x1dc>
 80005f0:	442c      	add	r4, r5
 80005f2:	ea81 0603 	eor.w	r6, r1, r3
 80005f6:	ea21 514c 	bic.w	r1, r1, ip, lsl #21
 80005fa:	ea23 534c 	bic.w	r3, r3, ip, lsl #21
 80005fe:	ea50 3501 	orrs.w	r5, r0, r1, lsl #12
 8000602:	bf18      	it	ne
 8000604:	ea52 3503 	orrsne.w	r5, r2, r3, lsl #12
 8000608:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 800060c:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 8000610:	d038      	beq.n	8000684 <__aeabi_dmul+0xb4>
 8000612:	fba0 ce02 	umull	ip, lr, r0, r2
 8000616:	f04f 0500 	mov.w	r5, #0
 800061a:	fbe1 e502 	umlal	lr, r5, r1, r2
 800061e:	f006 4200 	and.w	r2, r6, #2147483648	; 0x80000000
 8000622:	fbe0 e503 	umlal	lr, r5, r0, r3
 8000626:	f04f 0600 	mov.w	r6, #0
 800062a:	fbe1 5603 	umlal	r5, r6, r1, r3
 800062e:	f09c 0f00 	teq	ip, #0
 8000632:	bf18      	it	ne
 8000634:	f04e 0e01 	orrne.w	lr, lr, #1
 8000638:	f1a4 04ff 	sub.w	r4, r4, #255	; 0xff
 800063c:	f5b6 7f00 	cmp.w	r6, #512	; 0x200
 8000640:	f564 7440 	sbc.w	r4, r4, #768	; 0x300
 8000644:	d204      	bcs.n	8000650 <__aeabi_dmul+0x80>
 8000646:	ea5f 0e4e 	movs.w	lr, lr, lsl #1
 800064a:	416d      	adcs	r5, r5
 800064c:	eb46 0606 	adc.w	r6, r6, r6
 8000650:	ea42 21c6 	orr.w	r1, r2, r6, lsl #11
 8000654:	ea41 5155 	orr.w	r1, r1, r5, lsr #21
 8000658:	ea4f 20c5 	mov.w	r0, r5, lsl #11
 800065c:	ea40 505e 	orr.w	r0, r0, lr, lsr #21
 8000660:	ea4f 2ece 	mov.w	lr, lr, lsl #11
 8000664:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
 8000668:	bf88      	it	hi
 800066a:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
 800066e:	d81e      	bhi.n	80006ae <__aeabi_dmul+0xde>
 8000670:	f1be 4f00 	cmp.w	lr, #2147483648	; 0x80000000
 8000674:	bf08      	it	eq
 8000676:	ea5f 0e50 	movseq.w	lr, r0, lsr #1
 800067a:	f150 0000 	adcs.w	r0, r0, #0
 800067e:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 8000682:	bd70      	pop	{r4, r5, r6, pc}
 8000684:	f006 4600 	and.w	r6, r6, #2147483648	; 0x80000000
 8000688:	ea46 0101 	orr.w	r1, r6, r1
 800068c:	ea40 0002 	orr.w	r0, r0, r2
 8000690:	ea81 0103 	eor.w	r1, r1, r3
 8000694:	ebb4 045c 	subs.w	r4, r4, ip, lsr #1
 8000698:	bfc2      	ittt	gt
 800069a:	ebd4 050c 	rsbsgt	r5, r4, ip
 800069e:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 80006a2:	bd70      	popgt	{r4, r5, r6, pc}
 80006a4:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 80006a8:	f04f 0e00 	mov.w	lr, #0
 80006ac:	3c01      	subs	r4, #1
 80006ae:	f300 80ab 	bgt.w	8000808 <__aeabi_dmul+0x238>
 80006b2:	f114 0f36 	cmn.w	r4, #54	; 0x36
 80006b6:	bfde      	ittt	le
 80006b8:	2000      	movle	r0, #0
 80006ba:	f001 4100 	andle.w	r1, r1, #2147483648	; 0x80000000
 80006be:	bd70      	pople	{r4, r5, r6, pc}
 80006c0:	f1c4 0400 	rsb	r4, r4, #0
 80006c4:	3c20      	subs	r4, #32
 80006c6:	da35      	bge.n	8000734 <__aeabi_dmul+0x164>
 80006c8:	340c      	adds	r4, #12
 80006ca:	dc1b      	bgt.n	8000704 <__aeabi_dmul+0x134>
 80006cc:	f104 0414 	add.w	r4, r4, #20
 80006d0:	f1c4 0520 	rsb	r5, r4, #32
 80006d4:	fa00 f305 	lsl.w	r3, r0, r5
 80006d8:	fa20 f004 	lsr.w	r0, r0, r4
 80006dc:	fa01 f205 	lsl.w	r2, r1, r5
 80006e0:	ea40 0002 	orr.w	r0, r0, r2
 80006e4:	f001 4200 	and.w	r2, r1, #2147483648	; 0x80000000
 80006e8:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 80006ec:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 80006f0:	fa21 f604 	lsr.w	r6, r1, r4
 80006f4:	eb42 0106 	adc.w	r1, r2, r6
 80006f8:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 80006fc:	bf08      	it	eq
 80006fe:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 8000702:	bd70      	pop	{r4, r5, r6, pc}
 8000704:	f1c4 040c 	rsb	r4, r4, #12
 8000708:	f1c4 0520 	rsb	r5, r4, #32
 800070c:	fa00 f304 	lsl.w	r3, r0, r4
 8000710:	fa20 f005 	lsr.w	r0, r0, r5
 8000714:	fa01 f204 	lsl.w	r2, r1, r4
 8000718:	ea40 0002 	orr.w	r0, r0, r2
 800071c:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 8000720:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 8000724:	f141 0100 	adc.w	r1, r1, #0
 8000728:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 800072c:	bf08      	it	eq
 800072e:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 8000732:	bd70      	pop	{r4, r5, r6, pc}
 8000734:	f1c4 0520 	rsb	r5, r4, #32
 8000738:	fa00 f205 	lsl.w	r2, r0, r5
 800073c:	ea4e 0e02 	orr.w	lr, lr, r2
 8000740:	fa20 f304 	lsr.w	r3, r0, r4
 8000744:	fa01 f205 	lsl.w	r2, r1, r5
 8000748:	ea43 0302 	orr.w	r3, r3, r2
 800074c:	fa21 f004 	lsr.w	r0, r1, r4
 8000750:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 8000754:	fa21 f204 	lsr.w	r2, r1, r4
 8000758:	ea20 0002 	bic.w	r0, r0, r2
 800075c:	eb00 70d3 	add.w	r0, r0, r3, lsr #31
 8000760:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 8000764:	bf08      	it	eq
 8000766:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 800076a:	bd70      	pop	{r4, r5, r6, pc}
 800076c:	f094 0f00 	teq	r4, #0
 8000770:	d10f      	bne.n	8000792 <__aeabi_dmul+0x1c2>
 8000772:	f001 4600 	and.w	r6, r1, #2147483648	; 0x80000000
 8000776:	0040      	lsls	r0, r0, #1
 8000778:	eb41 0101 	adc.w	r1, r1, r1
 800077c:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 8000780:	bf08      	it	eq
 8000782:	3c01      	subeq	r4, #1
 8000784:	d0f7      	beq.n	8000776 <__aeabi_dmul+0x1a6>
 8000786:	ea41 0106 	orr.w	r1, r1, r6
 800078a:	f095 0f00 	teq	r5, #0
 800078e:	bf18      	it	ne
 8000790:	4770      	bxne	lr
 8000792:	f003 4600 	and.w	r6, r3, #2147483648	; 0x80000000
 8000796:	0052      	lsls	r2, r2, #1
 8000798:	eb43 0303 	adc.w	r3, r3, r3
 800079c:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
 80007a0:	bf08      	it	eq
 80007a2:	3d01      	subeq	r5, #1
 80007a4:	d0f7      	beq.n	8000796 <__aeabi_dmul+0x1c6>
 80007a6:	ea43 0306 	orr.w	r3, r3, r6
 80007aa:	4770      	bx	lr
 80007ac:	ea94 0f0c 	teq	r4, ip
 80007b0:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 80007b4:	bf18      	it	ne
 80007b6:	ea95 0f0c 	teqne	r5, ip
 80007ba:	d00c      	beq.n	80007d6 <__aeabi_dmul+0x206>
 80007bc:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 80007c0:	bf18      	it	ne
 80007c2:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 80007c6:	d1d1      	bne.n	800076c <__aeabi_dmul+0x19c>
 80007c8:	ea81 0103 	eor.w	r1, r1, r3
 80007cc:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 80007d0:	f04f 0000 	mov.w	r0, #0
 80007d4:	bd70      	pop	{r4, r5, r6, pc}
 80007d6:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 80007da:	bf06      	itte	eq
 80007dc:	4610      	moveq	r0, r2
 80007de:	4619      	moveq	r1, r3
 80007e0:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 80007e4:	d019      	beq.n	800081a <__aeabi_dmul+0x24a>
 80007e6:	ea94 0f0c 	teq	r4, ip
 80007ea:	d102      	bne.n	80007f2 <__aeabi_dmul+0x222>
 80007ec:	ea50 3601 	orrs.w	r6, r0, r1, lsl #12
 80007f0:	d113      	bne.n	800081a <__aeabi_dmul+0x24a>
 80007f2:	ea95 0f0c 	teq	r5, ip
 80007f6:	d105      	bne.n	8000804 <__aeabi_dmul+0x234>
 80007f8:	ea52 3603 	orrs.w	r6, r2, r3, lsl #12
 80007fc:	bf1c      	itt	ne
 80007fe:	4610      	movne	r0, r2
 8000800:	4619      	movne	r1, r3
 8000802:	d10a      	bne.n	800081a <__aeabi_dmul+0x24a>
 8000804:	ea81 0103 	eor.w	r1, r1, r3
 8000808:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 800080c:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
 8000810:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 8000814:	f04f 0000 	mov.w	r0, #0
 8000818:	bd70      	pop	{r4, r5, r6, pc}
 800081a:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
 800081e:	f441 0178 	orr.w	r1, r1, #16252928	; 0xf80000
 8000822:	bd70      	pop	{r4, r5, r6, pc}

08000824 <__aeabi_ddiv>:
 8000824:	b570      	push	{r4, r5, r6, lr}
 8000826:	f04f 0cff 	mov.w	ip, #255	; 0xff
 800082a:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
 800082e:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 8000832:	bf1d      	ittte	ne
 8000834:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 8000838:	ea94 0f0c 	teqne	r4, ip
 800083c:	ea95 0f0c 	teqne	r5, ip
 8000840:	f000 f8a7 	bleq	8000992 <__aeabi_ddiv+0x16e>
 8000844:	eba4 0405 	sub.w	r4, r4, r5
 8000848:	ea81 0e03 	eor.w	lr, r1, r3
 800084c:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 8000850:	ea4f 3101 	mov.w	r1, r1, lsl #12
 8000854:	f000 8088 	beq.w	8000968 <__aeabi_ddiv+0x144>
 8000858:	ea4f 3303 	mov.w	r3, r3, lsl #12
 800085c:	f04f 5580 	mov.w	r5, #268435456	; 0x10000000
 8000860:	ea45 1313 	orr.w	r3, r5, r3, lsr #4
 8000864:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
 8000868:	ea4f 2202 	mov.w	r2, r2, lsl #8
 800086c:	ea45 1511 	orr.w	r5, r5, r1, lsr #4
 8000870:	ea45 6510 	orr.w	r5, r5, r0, lsr #24
 8000874:	ea4f 2600 	mov.w	r6, r0, lsl #8
 8000878:	f00e 4100 	and.w	r1, lr, #2147483648	; 0x80000000
 800087c:	429d      	cmp	r5, r3
 800087e:	bf08      	it	eq
 8000880:	4296      	cmpeq	r6, r2
 8000882:	f144 04fd 	adc.w	r4, r4, #253	; 0xfd
 8000886:	f504 7440 	add.w	r4, r4, #768	; 0x300
 800088a:	d202      	bcs.n	8000892 <__aeabi_ddiv+0x6e>
 800088c:	085b      	lsrs	r3, r3, #1
 800088e:	ea4f 0232 	mov.w	r2, r2, rrx
 8000892:	1ab6      	subs	r6, r6, r2
 8000894:	eb65 0503 	sbc.w	r5, r5, r3
 8000898:	085b      	lsrs	r3, r3, #1
 800089a:	ea4f 0232 	mov.w	r2, r2, rrx
 800089e:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
 80008a2:	f44f 2c00 	mov.w	ip, #524288	; 0x80000
 80008a6:	ebb6 0e02 	subs.w	lr, r6, r2
 80008aa:	eb75 0e03 	sbcs.w	lr, r5, r3
 80008ae:	bf22      	ittt	cs
 80008b0:	1ab6      	subcs	r6, r6, r2
 80008b2:	4675      	movcs	r5, lr
 80008b4:	ea40 000c 	orrcs.w	r0, r0, ip
 80008b8:	085b      	lsrs	r3, r3, #1
 80008ba:	ea4f 0232 	mov.w	r2, r2, rrx
 80008be:	ebb6 0e02 	subs.w	lr, r6, r2
 80008c2:	eb75 0e03 	sbcs.w	lr, r5, r3
 80008c6:	bf22      	ittt	cs
 80008c8:	1ab6      	subcs	r6, r6, r2
 80008ca:	4675      	movcs	r5, lr
 80008cc:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
 80008d0:	085b      	lsrs	r3, r3, #1
 80008d2:	ea4f 0232 	mov.w	r2, r2, rrx
 80008d6:	ebb6 0e02 	subs.w	lr, r6, r2
 80008da:	eb75 0e03 	sbcs.w	lr, r5, r3
 80008de:	bf22      	ittt	cs
 80008e0:	1ab6      	subcs	r6, r6, r2
 80008e2:	4675      	movcs	r5, lr
 80008e4:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
 80008e8:	085b      	lsrs	r3, r3, #1
 80008ea:	ea4f 0232 	mov.w	r2, r2, rrx
 80008ee:	ebb6 0e02 	subs.w	lr, r6, r2
 80008f2:	eb75 0e03 	sbcs.w	lr, r5, r3
 80008f6:	bf22      	ittt	cs
 80008f8:	1ab6      	subcs	r6, r6, r2
 80008fa:	4675      	movcs	r5, lr
 80008fc:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
 8000900:	ea55 0e06 	orrs.w	lr, r5, r6
 8000904:	d018      	beq.n	8000938 <__aeabi_ddiv+0x114>
 8000906:	ea4f 1505 	mov.w	r5, r5, lsl #4
 800090a:	ea45 7516 	orr.w	r5, r5, r6, lsr #28
 800090e:	ea4f 1606 	mov.w	r6, r6, lsl #4
 8000912:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8000916:	ea43 7352 	orr.w	r3, r3, r2, lsr #29
 800091a:	ea4f 02c2 	mov.w	r2, r2, lsl #3
 800091e:	ea5f 1c1c 	movs.w	ip, ip, lsr #4
 8000922:	d1c0      	bne.n	80008a6 <__aeabi_ddiv+0x82>
 8000924:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 8000928:	d10b      	bne.n	8000942 <__aeabi_ddiv+0x11e>
 800092a:	ea41 0100 	orr.w	r1, r1, r0
 800092e:	f04f 0000 	mov.w	r0, #0
 8000932:	f04f 4c00 	mov.w	ip, #2147483648	; 0x80000000
 8000936:	e7b6      	b.n	80008a6 <__aeabi_ddiv+0x82>
 8000938:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 800093c:	bf04      	itt	eq
 800093e:	4301      	orreq	r1, r0
 8000940:	2000      	moveq	r0, #0
 8000942:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
 8000946:	bf88      	it	hi
 8000948:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
 800094c:	f63f aeaf 	bhi.w	80006ae <__aeabi_dmul+0xde>
 8000950:	ebb5 0c03 	subs.w	ip, r5, r3
 8000954:	bf04      	itt	eq
 8000956:	ebb6 0c02 	subseq.w	ip, r6, r2
 800095a:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 800095e:	f150 0000 	adcs.w	r0, r0, #0
 8000962:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 8000966:	bd70      	pop	{r4, r5, r6, pc}
 8000968:	f00e 4e00 	and.w	lr, lr, #2147483648	; 0x80000000
 800096c:	ea4e 3111 	orr.w	r1, lr, r1, lsr #12
 8000970:	eb14 045c 	adds.w	r4, r4, ip, lsr #1
 8000974:	bfc2      	ittt	gt
 8000976:	ebd4 050c 	rsbsgt	r5, r4, ip
 800097a:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 800097e:	bd70      	popgt	{r4, r5, r6, pc}
 8000980:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 8000984:	f04f 0e00 	mov.w	lr, #0
 8000988:	3c01      	subs	r4, #1
 800098a:	e690      	b.n	80006ae <__aeabi_dmul+0xde>
 800098c:	ea45 0e06 	orr.w	lr, r5, r6
 8000990:	e68d      	b.n	80006ae <__aeabi_dmul+0xde>
 8000992:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 8000996:	ea94 0f0c 	teq	r4, ip
 800099a:	bf08      	it	eq
 800099c:	ea95 0f0c 	teqeq	r5, ip
 80009a0:	f43f af3b 	beq.w	800081a <__aeabi_dmul+0x24a>
 80009a4:	ea94 0f0c 	teq	r4, ip
 80009a8:	d10a      	bne.n	80009c0 <__aeabi_ddiv+0x19c>
 80009aa:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 80009ae:	f47f af34 	bne.w	800081a <__aeabi_dmul+0x24a>
 80009b2:	ea95 0f0c 	teq	r5, ip
 80009b6:	f47f af25 	bne.w	8000804 <__aeabi_dmul+0x234>
 80009ba:	4610      	mov	r0, r2
 80009bc:	4619      	mov	r1, r3
 80009be:	e72c      	b.n	800081a <__aeabi_dmul+0x24a>
 80009c0:	ea95 0f0c 	teq	r5, ip
 80009c4:	d106      	bne.n	80009d4 <__aeabi_ddiv+0x1b0>
 80009c6:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 80009ca:	f43f aefd 	beq.w	80007c8 <__aeabi_dmul+0x1f8>
 80009ce:	4610      	mov	r0, r2
 80009d0:	4619      	mov	r1, r3
 80009d2:	e722      	b.n	800081a <__aeabi_dmul+0x24a>
 80009d4:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 80009d8:	bf18      	it	ne
 80009da:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 80009de:	f47f aec5 	bne.w	800076c <__aeabi_dmul+0x19c>
 80009e2:	ea50 0441 	orrs.w	r4, r0, r1, lsl #1
 80009e6:	f47f af0d 	bne.w	8000804 <__aeabi_dmul+0x234>
 80009ea:	ea52 0543 	orrs.w	r5, r2, r3, lsl #1
 80009ee:	f47f aeeb 	bne.w	80007c8 <__aeabi_dmul+0x1f8>
 80009f2:	e712      	b.n	800081a <__aeabi_dmul+0x24a>
	...

08000a00 <__aeabi_d2iz>:
 8000a00:	ea4f 0241 	mov.w	r2, r1, lsl #1
 8000a04:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
 8000a08:	d215      	bcs.n	8000a36 <__aeabi_d2iz+0x36>
 8000a0a:	d511      	bpl.n	8000a30 <__aeabi_d2iz+0x30>
 8000a0c:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
 8000a10:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
 8000a14:	d912      	bls.n	8000a3c <__aeabi_d2iz+0x3c>
 8000a16:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 8000a1a:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 8000a1e:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
 8000a22:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 8000a26:	fa23 f002 	lsr.w	r0, r3, r2
 8000a2a:	bf18      	it	ne
 8000a2c:	4240      	negne	r0, r0
 8000a2e:	4770      	bx	lr
 8000a30:	f04f 0000 	mov.w	r0, #0
 8000a34:	4770      	bx	lr
 8000a36:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
 8000a3a:	d105      	bne.n	8000a48 <__aeabi_d2iz+0x48>
 8000a3c:	f011 4000 	ands.w	r0, r1, #2147483648	; 0x80000000
 8000a40:	bf08      	it	eq
 8000a42:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
 8000a46:	4770      	bx	lr
 8000a48:	f04f 0000 	mov.w	r0, #0
 8000a4c:	4770      	bx	lr
 8000a4e:	bf00      	nop

08000a50 <__aeabi_d2f>:
 8000a50:	ea4f 0241 	mov.w	r2, r1, lsl #1
 8000a54:	f1b2 43e0 	subs.w	r3, r2, #1879048192	; 0x70000000
 8000a58:	bf24      	itt	cs
 8000a5a:	f5b3 1c00 	subscs.w	ip, r3, #2097152	; 0x200000
 8000a5e:	f1dc 5cfe 	rsbscs	ip, ip, #532676608	; 0x1fc00000
 8000a62:	d90d      	bls.n	8000a80 <__aeabi_d2f+0x30>
 8000a64:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
 8000a68:	ea4f 02c0 	mov.w	r2, r0, lsl #3
 8000a6c:	ea4c 7050 	orr.w	r0, ip, r0, lsr #29
 8000a70:	f1b2 4f00 	cmp.w	r2, #2147483648	; 0x80000000
 8000a74:	eb40 0083 	adc.w	r0, r0, r3, lsl #2
 8000a78:	bf08      	it	eq
 8000a7a:	f020 0001 	biceq.w	r0, r0, #1
 8000a7e:	4770      	bx	lr
 8000a80:	f011 4f80 	tst.w	r1, #1073741824	; 0x40000000
 8000a84:	d121      	bne.n	8000aca <__aeabi_d2f+0x7a>
 8000a86:	f113 7238 	adds.w	r2, r3, #48234496	; 0x2e00000
 8000a8a:	bfbc      	itt	lt
 8000a8c:	f001 4000 	andlt.w	r0, r1, #2147483648	; 0x80000000
 8000a90:	4770      	bxlt	lr
 8000a92:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 8000a96:	ea4f 5252 	mov.w	r2, r2, lsr #21
 8000a9a:	f1c2 0218 	rsb	r2, r2, #24
 8000a9e:	f1c2 0c20 	rsb	ip, r2, #32
 8000aa2:	fa10 f30c 	lsls.w	r3, r0, ip
 8000aa6:	fa20 f002 	lsr.w	r0, r0, r2
 8000aaa:	bf18      	it	ne
 8000aac:	f040 0001 	orrne.w	r0, r0, #1
 8000ab0:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 8000ab4:	ea4f 23d3 	mov.w	r3, r3, lsr #11
 8000ab8:	fa03 fc0c 	lsl.w	ip, r3, ip
 8000abc:	ea40 000c 	orr.w	r0, r0, ip
 8000ac0:	fa23 f302 	lsr.w	r3, r3, r2
 8000ac4:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8000ac8:	e7cc      	b.n	8000a64 <__aeabi_d2f+0x14>
 8000aca:	ea7f 5362 	mvns.w	r3, r2, asr #21
 8000ace:	d107      	bne.n	8000ae0 <__aeabi_d2f+0x90>
 8000ad0:	ea50 3301 	orrs.w	r3, r0, r1, lsl #12
 8000ad4:	bf1e      	ittt	ne
 8000ad6:	f04f 40fe 	movne.w	r0, #2130706432	; 0x7f000000
 8000ada:	f440 0040 	orrne.w	r0, r0, #12582912	; 0xc00000
 8000ade:	4770      	bxne	lr
 8000ae0:	f001 4000 	and.w	r0, r1, #2147483648	; 0x80000000
 8000ae4:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
 8000ae8:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 8000aec:	4770      	bx	lr
 8000aee:	bf00      	nop

08000af0 <__aeabi_frsub>:
 8000af0:	f080 4000 	eor.w	r0, r0, #2147483648	; 0x80000000
 8000af4:	e002      	b.n	8000afc <__addsf3>
 8000af6:	bf00      	nop

08000af8 <__aeabi_fsub>:
 8000af8:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000

08000afc <__addsf3>:
 8000afc:	0042      	lsls	r2, r0, #1
 8000afe:	bf1f      	itttt	ne
 8000b00:	ea5f 0341 	movsne.w	r3, r1, lsl #1
 8000b04:	ea92 0f03 	teqne	r2, r3
 8000b08:	ea7f 6c22 	mvnsne.w	ip, r2, asr #24
 8000b0c:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
 8000b10:	d06a      	beq.n	8000be8 <__addsf3+0xec>
 8000b12:	ea4f 6212 	mov.w	r2, r2, lsr #24
 8000b16:	ebd2 6313 	rsbs	r3, r2, r3, lsr #24
 8000b1a:	bfc1      	itttt	gt
 8000b1c:	18d2      	addgt	r2, r2, r3
 8000b1e:	4041      	eorgt	r1, r0
 8000b20:	4048      	eorgt	r0, r1
 8000b22:	4041      	eorgt	r1, r0
 8000b24:	bfb8      	it	lt
 8000b26:	425b      	neglt	r3, r3
 8000b28:	2b19      	cmp	r3, #25
 8000b2a:	bf88      	it	hi
 8000b2c:	4770      	bxhi	lr
 8000b2e:	f010 4f00 	tst.w	r0, #2147483648	; 0x80000000
 8000b32:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 8000b36:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
 8000b3a:	bf18      	it	ne
 8000b3c:	4240      	negne	r0, r0
 8000b3e:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 8000b42:	f441 0100 	orr.w	r1, r1, #8388608	; 0x800000
 8000b46:	f021 417f 	bic.w	r1, r1, #4278190080	; 0xff000000
 8000b4a:	bf18      	it	ne
 8000b4c:	4249      	negne	r1, r1
 8000b4e:	ea92 0f03 	teq	r2, r3
 8000b52:	d03f      	beq.n	8000bd4 <__addsf3+0xd8>
 8000b54:	f1a2 0201 	sub.w	r2, r2, #1
 8000b58:	fa41 fc03 	asr.w	ip, r1, r3
 8000b5c:	eb10 000c 	adds.w	r0, r0, ip
 8000b60:	f1c3 0320 	rsb	r3, r3, #32
 8000b64:	fa01 f103 	lsl.w	r1, r1, r3
 8000b68:	f000 4300 	and.w	r3, r0, #2147483648	; 0x80000000
 8000b6c:	d502      	bpl.n	8000b74 <__addsf3+0x78>
 8000b6e:	4249      	negs	r1, r1
 8000b70:	eb60 0040 	sbc.w	r0, r0, r0, lsl #1
 8000b74:	f5b0 0f00 	cmp.w	r0, #8388608	; 0x800000
 8000b78:	d313      	bcc.n	8000ba2 <__addsf3+0xa6>
 8000b7a:	f1b0 7f80 	cmp.w	r0, #16777216	; 0x1000000
 8000b7e:	d306      	bcc.n	8000b8e <__addsf3+0x92>
 8000b80:	0840      	lsrs	r0, r0, #1
 8000b82:	ea4f 0131 	mov.w	r1, r1, rrx
 8000b86:	f102 0201 	add.w	r2, r2, #1
 8000b8a:	2afe      	cmp	r2, #254	; 0xfe
 8000b8c:	d251      	bcs.n	8000c32 <__addsf3+0x136>
 8000b8e:	f1b1 4f00 	cmp.w	r1, #2147483648	; 0x80000000
 8000b92:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
 8000b96:	bf08      	it	eq
 8000b98:	f020 0001 	biceq.w	r0, r0, #1
 8000b9c:	ea40 0003 	orr.w	r0, r0, r3
 8000ba0:	4770      	bx	lr
 8000ba2:	0049      	lsls	r1, r1, #1
 8000ba4:	eb40 0000 	adc.w	r0, r0, r0
 8000ba8:	f410 0f00 	tst.w	r0, #8388608	; 0x800000
 8000bac:	f1a2 0201 	sub.w	r2, r2, #1
 8000bb0:	d1ed      	bne.n	8000b8e <__addsf3+0x92>
 8000bb2:	fab0 fc80 	clz	ip, r0
 8000bb6:	f1ac 0c08 	sub.w	ip, ip, #8
 8000bba:	ebb2 020c 	subs.w	r2, r2, ip
 8000bbe:	fa00 f00c 	lsl.w	r0, r0, ip
 8000bc2:	bfaa      	itet	ge
 8000bc4:	eb00 50c2 	addge.w	r0, r0, r2, lsl #23
 8000bc8:	4252      	neglt	r2, r2
 8000bca:	4318      	orrge	r0, r3
 8000bcc:	bfbc      	itt	lt
 8000bce:	40d0      	lsrlt	r0, r2
 8000bd0:	4318      	orrlt	r0, r3
 8000bd2:	4770      	bx	lr
 8000bd4:	f092 0f00 	teq	r2, #0
 8000bd8:	f481 0100 	eor.w	r1, r1, #8388608	; 0x800000
 8000bdc:	bf06      	itte	eq
 8000bde:	f480 0000 	eoreq.w	r0, r0, #8388608	; 0x800000
 8000be2:	3201      	addeq	r2, #1
 8000be4:	3b01      	subne	r3, #1
 8000be6:	e7b5      	b.n	8000b54 <__addsf3+0x58>
 8000be8:	ea4f 0341 	mov.w	r3, r1, lsl #1
 8000bec:	ea7f 6c22 	mvns.w	ip, r2, asr #24
 8000bf0:	bf18      	it	ne
 8000bf2:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
 8000bf6:	d021      	beq.n	8000c3c <__addsf3+0x140>
 8000bf8:	ea92 0f03 	teq	r2, r3
 8000bfc:	d004      	beq.n	8000c08 <__addsf3+0x10c>
 8000bfe:	f092 0f00 	teq	r2, #0
 8000c02:	bf08      	it	eq
 8000c04:	4608      	moveq	r0, r1
 8000c06:	4770      	bx	lr
 8000c08:	ea90 0f01 	teq	r0, r1
 8000c0c:	bf1c      	itt	ne
 8000c0e:	2000      	movne	r0, #0
 8000c10:	4770      	bxne	lr
 8000c12:	f012 4f7f 	tst.w	r2, #4278190080	; 0xff000000
 8000c16:	d104      	bne.n	8000c22 <__addsf3+0x126>
 8000c18:	0040      	lsls	r0, r0, #1
 8000c1a:	bf28      	it	cs
 8000c1c:	f040 4000 	orrcs.w	r0, r0, #2147483648	; 0x80000000
 8000c20:	4770      	bx	lr
 8000c22:	f112 7200 	adds.w	r2, r2, #33554432	; 0x2000000
 8000c26:	bf3c      	itt	cc
 8000c28:	f500 0000 	addcc.w	r0, r0, #8388608	; 0x800000
 8000c2c:	4770      	bxcc	lr
 8000c2e:	f000 4300 	and.w	r3, r0, #2147483648	; 0x80000000
 8000c32:	f043 40fe 	orr.w	r0, r3, #2130706432	; 0x7f000000
 8000c36:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 8000c3a:	4770      	bx	lr
 8000c3c:	ea7f 6222 	mvns.w	r2, r2, asr #24
 8000c40:	bf16      	itet	ne
 8000c42:	4608      	movne	r0, r1
 8000c44:	ea7f 6323 	mvnseq.w	r3, r3, asr #24
 8000c48:	4601      	movne	r1, r0
 8000c4a:	0242      	lsls	r2, r0, #9
 8000c4c:	bf06      	itte	eq
 8000c4e:	ea5f 2341 	movseq.w	r3, r1, lsl #9
 8000c52:	ea90 0f01 	teqeq	r0, r1
 8000c56:	f440 0080 	orrne.w	r0, r0, #4194304	; 0x400000
 8000c5a:	4770      	bx	lr

08000c5c <__aeabi_ui2f>:
 8000c5c:	f04f 0300 	mov.w	r3, #0
 8000c60:	e004      	b.n	8000c6c <__aeabi_i2f+0x8>
 8000c62:	bf00      	nop

08000c64 <__aeabi_i2f>:
 8000c64:	f010 4300 	ands.w	r3, r0, #2147483648	; 0x80000000
 8000c68:	bf48      	it	mi
 8000c6a:	4240      	negmi	r0, r0
 8000c6c:	ea5f 0c00 	movs.w	ip, r0
 8000c70:	bf08      	it	eq
 8000c72:	4770      	bxeq	lr
 8000c74:	f043 4396 	orr.w	r3, r3, #1258291200	; 0x4b000000
 8000c78:	4601      	mov	r1, r0
 8000c7a:	f04f 0000 	mov.w	r0, #0
 8000c7e:	e01c      	b.n	8000cba <__aeabi_l2f+0x2a>

08000c80 <__aeabi_ul2f>:
 8000c80:	ea50 0201 	orrs.w	r2, r0, r1
 8000c84:	bf08      	it	eq
 8000c86:	4770      	bxeq	lr
 8000c88:	f04f 0300 	mov.w	r3, #0
 8000c8c:	e00a      	b.n	8000ca4 <__aeabi_l2f+0x14>
 8000c8e:	bf00      	nop

08000c90 <__aeabi_l2f>:
 8000c90:	ea50 0201 	orrs.w	r2, r0, r1
 8000c94:	bf08      	it	eq
 8000c96:	4770      	bxeq	lr
 8000c98:	f011 4300 	ands.w	r3, r1, #2147483648	; 0x80000000
 8000c9c:	d502      	bpl.n	8000ca4 <__aeabi_l2f+0x14>
 8000c9e:	4240      	negs	r0, r0
 8000ca0:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 8000ca4:	ea5f 0c01 	movs.w	ip, r1
 8000ca8:	bf02      	ittt	eq
 8000caa:	4684      	moveq	ip, r0
 8000cac:	4601      	moveq	r1, r0
 8000cae:	2000      	moveq	r0, #0
 8000cb0:	f043 43b6 	orr.w	r3, r3, #1526726656	; 0x5b000000
 8000cb4:	bf08      	it	eq
 8000cb6:	f1a3 5380 	subeq.w	r3, r3, #268435456	; 0x10000000
 8000cba:	f5a3 0300 	sub.w	r3, r3, #8388608	; 0x800000
 8000cbe:	fabc f28c 	clz	r2, ip
 8000cc2:	3a08      	subs	r2, #8
 8000cc4:	eba3 53c2 	sub.w	r3, r3, r2, lsl #23
 8000cc8:	db10      	blt.n	8000cec <__aeabi_l2f+0x5c>
 8000cca:	fa01 fc02 	lsl.w	ip, r1, r2
 8000cce:	4463      	add	r3, ip
 8000cd0:	fa00 fc02 	lsl.w	ip, r0, r2
 8000cd4:	f1c2 0220 	rsb	r2, r2, #32
 8000cd8:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
 8000cdc:	fa20 f202 	lsr.w	r2, r0, r2
 8000ce0:	eb43 0002 	adc.w	r0, r3, r2
 8000ce4:	bf08      	it	eq
 8000ce6:	f020 0001 	biceq.w	r0, r0, #1
 8000cea:	4770      	bx	lr
 8000cec:	f102 0220 	add.w	r2, r2, #32
 8000cf0:	fa01 fc02 	lsl.w	ip, r1, r2
 8000cf4:	f1c2 0220 	rsb	r2, r2, #32
 8000cf8:	ea50 004c 	orrs.w	r0, r0, ip, lsl #1
 8000cfc:	fa21 f202 	lsr.w	r2, r1, r2
 8000d00:	eb43 0002 	adc.w	r0, r3, r2
 8000d04:	bf08      	it	eq
 8000d06:	ea20 70dc 	biceq.w	r0, r0, ip, lsr #31
 8000d0a:	4770      	bx	lr
 8000d0c:	0000      	movs	r0, r0
	...

08000d10 <__aeabi_fmul>:
 8000d10:	f04f 0cff 	mov.w	ip, #255	; 0xff
 8000d14:	ea1c 52d0 	ands.w	r2, ip, r0, lsr #23
 8000d18:	bf1e      	ittt	ne
 8000d1a:	ea1c 53d1 	andsne.w	r3, ip, r1, lsr #23
 8000d1e:	ea92 0f0c 	teqne	r2, ip
 8000d22:	ea93 0f0c 	teqne	r3, ip
 8000d26:	d06f      	beq.n	8000e08 <__aeabi_fmul+0xf8>
 8000d28:	441a      	add	r2, r3
 8000d2a:	ea80 0c01 	eor.w	ip, r0, r1
 8000d2e:	0240      	lsls	r0, r0, #9
 8000d30:	bf18      	it	ne
 8000d32:	ea5f 2141 	movsne.w	r1, r1, lsl #9
 8000d36:	d01e      	beq.n	8000d76 <__aeabi_fmul+0x66>
 8000d38:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
 8000d3c:	ea43 1050 	orr.w	r0, r3, r0, lsr #5
 8000d40:	ea43 1151 	orr.w	r1, r3, r1, lsr #5
 8000d44:	fba0 3101 	umull	r3, r1, r0, r1
 8000d48:	f00c 4000 	and.w	r0, ip, #2147483648	; 0x80000000
 8000d4c:	f5b1 0f00 	cmp.w	r1, #8388608	; 0x800000
 8000d50:	bf3e      	ittt	cc
 8000d52:	0049      	lslcc	r1, r1, #1
 8000d54:	ea41 71d3 	orrcc.w	r1, r1, r3, lsr #31
 8000d58:	005b      	lslcc	r3, r3, #1
 8000d5a:	ea40 0001 	orr.w	r0, r0, r1
 8000d5e:	f162 027f 	sbc.w	r2, r2, #127	; 0x7f
 8000d62:	2afd      	cmp	r2, #253	; 0xfd
 8000d64:	d81d      	bhi.n	8000da2 <__aeabi_fmul+0x92>
 8000d66:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
 8000d6a:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
 8000d6e:	bf08      	it	eq
 8000d70:	f020 0001 	biceq.w	r0, r0, #1
 8000d74:	4770      	bx	lr
 8000d76:	f090 0f00 	teq	r0, #0
 8000d7a:	f00c 4c00 	and.w	ip, ip, #2147483648	; 0x80000000
 8000d7e:	bf08      	it	eq
 8000d80:	0249      	lsleq	r1, r1, #9
 8000d82:	ea4c 2050 	orr.w	r0, ip, r0, lsr #9
 8000d86:	ea40 2051 	orr.w	r0, r0, r1, lsr #9
 8000d8a:	3a7f      	subs	r2, #127	; 0x7f
 8000d8c:	bfc2      	ittt	gt
 8000d8e:	f1d2 03ff 	rsbsgt	r3, r2, #255	; 0xff
 8000d92:	ea40 50c2 	orrgt.w	r0, r0, r2, lsl #23
 8000d96:	4770      	bxgt	lr
 8000d98:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 8000d9c:	f04f 0300 	mov.w	r3, #0
 8000da0:	3a01      	subs	r2, #1
 8000da2:	dc5d      	bgt.n	8000e60 <__aeabi_fmul+0x150>
 8000da4:	f112 0f19 	cmn.w	r2, #25
 8000da8:	bfdc      	itt	le
 8000daa:	f000 4000 	andle.w	r0, r0, #2147483648	; 0x80000000
 8000dae:	4770      	bxle	lr
 8000db0:	f1c2 0200 	rsb	r2, r2, #0
 8000db4:	0041      	lsls	r1, r0, #1
 8000db6:	fa21 f102 	lsr.w	r1, r1, r2
 8000dba:	f1c2 0220 	rsb	r2, r2, #32
 8000dbe:	fa00 fc02 	lsl.w	ip, r0, r2
 8000dc2:	ea5f 0031 	movs.w	r0, r1, rrx
 8000dc6:	f140 0000 	adc.w	r0, r0, #0
 8000dca:	ea53 034c 	orrs.w	r3, r3, ip, lsl #1
 8000dce:	bf08      	it	eq
 8000dd0:	ea20 70dc 	biceq.w	r0, r0, ip, lsr #31
 8000dd4:	4770      	bx	lr
 8000dd6:	f092 0f00 	teq	r2, #0
 8000dda:	f000 4c00 	and.w	ip, r0, #2147483648	; 0x80000000
 8000dde:	bf02      	ittt	eq
 8000de0:	0040      	lsleq	r0, r0, #1
 8000de2:	f410 0f00 	tsteq.w	r0, #8388608	; 0x800000
 8000de6:	3a01      	subeq	r2, #1
 8000de8:	d0f9      	beq.n	8000dde <__aeabi_fmul+0xce>
 8000dea:	ea40 000c 	orr.w	r0, r0, ip
 8000dee:	f093 0f00 	teq	r3, #0
 8000df2:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
 8000df6:	bf02      	ittt	eq
 8000df8:	0049      	lsleq	r1, r1, #1
 8000dfa:	f411 0f00 	tsteq.w	r1, #8388608	; 0x800000
 8000dfe:	3b01      	subeq	r3, #1
 8000e00:	d0f9      	beq.n	8000df6 <__aeabi_fmul+0xe6>
 8000e02:	ea41 010c 	orr.w	r1, r1, ip
 8000e06:	e78f      	b.n	8000d28 <__aeabi_fmul+0x18>
 8000e08:	ea0c 53d1 	and.w	r3, ip, r1, lsr #23
 8000e0c:	ea92 0f0c 	teq	r2, ip
 8000e10:	bf18      	it	ne
 8000e12:	ea93 0f0c 	teqne	r3, ip
 8000e16:	d00a      	beq.n	8000e2e <__aeabi_fmul+0x11e>
 8000e18:	f030 4c00 	bics.w	ip, r0, #2147483648	; 0x80000000
 8000e1c:	bf18      	it	ne
 8000e1e:	f031 4c00 	bicsne.w	ip, r1, #2147483648	; 0x80000000
 8000e22:	d1d8      	bne.n	8000dd6 <__aeabi_fmul+0xc6>
 8000e24:	ea80 0001 	eor.w	r0, r0, r1
 8000e28:	f000 4000 	and.w	r0, r0, #2147483648	; 0x80000000
 8000e2c:	4770      	bx	lr
 8000e2e:	f090 0f00 	teq	r0, #0
 8000e32:	bf17      	itett	ne
 8000e34:	f090 4f00 	teqne	r0, #2147483648	; 0x80000000
 8000e38:	4608      	moveq	r0, r1
 8000e3a:	f091 0f00 	teqne	r1, #0
 8000e3e:	f091 4f00 	teqne	r1, #2147483648	; 0x80000000
 8000e42:	d014      	beq.n	8000e6e <__aeabi_fmul+0x15e>
 8000e44:	ea92 0f0c 	teq	r2, ip
 8000e48:	d101      	bne.n	8000e4e <__aeabi_fmul+0x13e>
 8000e4a:	0242      	lsls	r2, r0, #9
 8000e4c:	d10f      	bne.n	8000e6e <__aeabi_fmul+0x15e>
 8000e4e:	ea93 0f0c 	teq	r3, ip
 8000e52:	d103      	bne.n	8000e5c <__aeabi_fmul+0x14c>
 8000e54:	024b      	lsls	r3, r1, #9
 8000e56:	bf18      	it	ne
 8000e58:	4608      	movne	r0, r1
 8000e5a:	d108      	bne.n	8000e6e <__aeabi_fmul+0x15e>
 8000e5c:	ea80 0001 	eor.w	r0, r0, r1
 8000e60:	f000 4000 	and.w	r0, r0, #2147483648	; 0x80000000
 8000e64:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
 8000e68:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 8000e6c:	4770      	bx	lr
 8000e6e:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
 8000e72:	f440 0040 	orr.w	r0, r0, #12582912	; 0xc00000
 8000e76:	4770      	bx	lr

08000e78 <__aeabi_fdiv>:
 8000e78:	f04f 0cff 	mov.w	ip, #255	; 0xff
 8000e7c:	ea1c 52d0 	ands.w	r2, ip, r0, lsr #23
 8000e80:	bf1e      	ittt	ne
 8000e82:	ea1c 53d1 	andsne.w	r3, ip, r1, lsr #23
 8000e86:	ea92 0f0c 	teqne	r2, ip
 8000e8a:	ea93 0f0c 	teqne	r3, ip
 8000e8e:	d069      	beq.n	8000f64 <__aeabi_fdiv+0xec>
 8000e90:	eba2 0203 	sub.w	r2, r2, r3
 8000e94:	ea80 0c01 	eor.w	ip, r0, r1
 8000e98:	0249      	lsls	r1, r1, #9
 8000e9a:	ea4f 2040 	mov.w	r0, r0, lsl #9
 8000e9e:	d037      	beq.n	8000f10 <__aeabi_fdiv+0x98>
 8000ea0:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
 8000ea4:	ea43 1111 	orr.w	r1, r3, r1, lsr #4
 8000ea8:	ea43 1310 	orr.w	r3, r3, r0, lsr #4
 8000eac:	f00c 4000 	and.w	r0, ip, #2147483648	; 0x80000000
 8000eb0:	428b      	cmp	r3, r1
 8000eb2:	bf38      	it	cc
 8000eb4:	005b      	lslcc	r3, r3, #1
 8000eb6:	f142 027d 	adc.w	r2, r2, #125	; 0x7d
 8000eba:	f44f 0c00 	mov.w	ip, #8388608	; 0x800000
 8000ebe:	428b      	cmp	r3, r1
 8000ec0:	bf24      	itt	cs
 8000ec2:	1a5b      	subcs	r3, r3, r1
 8000ec4:	ea40 000c 	orrcs.w	r0, r0, ip
 8000ec8:	ebb3 0f51 	cmp.w	r3, r1, lsr #1
 8000ecc:	bf24      	itt	cs
 8000ece:	eba3 0351 	subcs.w	r3, r3, r1, lsr #1
 8000ed2:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
 8000ed6:	ebb3 0f91 	cmp.w	r3, r1, lsr #2
 8000eda:	bf24      	itt	cs
 8000edc:	eba3 0391 	subcs.w	r3, r3, r1, lsr #2
 8000ee0:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
 8000ee4:	ebb3 0fd1 	cmp.w	r3, r1, lsr #3
 8000ee8:	bf24      	itt	cs
 8000eea:	eba3 03d1 	subcs.w	r3, r3, r1, lsr #3
 8000eee:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
 8000ef2:	011b      	lsls	r3, r3, #4
 8000ef4:	bf18      	it	ne
 8000ef6:	ea5f 1c1c 	movsne.w	ip, ip, lsr #4
 8000efa:	d1e0      	bne.n	8000ebe <__aeabi_fdiv+0x46>
 8000efc:	2afd      	cmp	r2, #253	; 0xfd
 8000efe:	f63f af50 	bhi.w	8000da2 <__aeabi_fmul+0x92>
 8000f02:	428b      	cmp	r3, r1
 8000f04:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
 8000f08:	bf08      	it	eq
 8000f0a:	f020 0001 	biceq.w	r0, r0, #1
 8000f0e:	4770      	bx	lr
 8000f10:	f00c 4c00 	and.w	ip, ip, #2147483648	; 0x80000000
 8000f14:	ea4c 2050 	orr.w	r0, ip, r0, lsr #9
 8000f18:	327f      	adds	r2, #127	; 0x7f
 8000f1a:	bfc2      	ittt	gt
 8000f1c:	f1d2 03ff 	rsbsgt	r3, r2, #255	; 0xff
 8000f20:	ea40 50c2 	orrgt.w	r0, r0, r2, lsl #23
 8000f24:	4770      	bxgt	lr
 8000f26:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 8000f2a:	f04f 0300 	mov.w	r3, #0
 8000f2e:	3a01      	subs	r2, #1
 8000f30:	e737      	b.n	8000da2 <__aeabi_fmul+0x92>
 8000f32:	f092 0f00 	teq	r2, #0
 8000f36:	f000 4c00 	and.w	ip, r0, #2147483648	; 0x80000000
 8000f3a:	bf02      	ittt	eq
 8000f3c:	0040      	lsleq	r0, r0, #1
 8000f3e:	f410 0f00 	tsteq.w	r0, #8388608	; 0x800000
 8000f42:	3a01      	subeq	r2, #1
 8000f44:	d0f9      	beq.n	8000f3a <__aeabi_fdiv+0xc2>
 8000f46:	ea40 000c 	orr.w	r0, r0, ip
 8000f4a:	f093 0f00 	teq	r3, #0
 8000f4e:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
 8000f52:	bf02      	ittt	eq
 8000f54:	0049      	lsleq	r1, r1, #1
 8000f56:	f411 0f00 	tsteq.w	r1, #8388608	; 0x800000
 8000f5a:	3b01      	subeq	r3, #1
 8000f5c:	d0f9      	beq.n	8000f52 <__aeabi_fdiv+0xda>
 8000f5e:	ea41 010c 	orr.w	r1, r1, ip
 8000f62:	e795      	b.n	8000e90 <__aeabi_fdiv+0x18>
 8000f64:	ea0c 53d1 	and.w	r3, ip, r1, lsr #23
 8000f68:	ea92 0f0c 	teq	r2, ip
 8000f6c:	d108      	bne.n	8000f80 <__aeabi_fdiv+0x108>
 8000f6e:	0242      	lsls	r2, r0, #9
 8000f70:	f47f af7d 	bne.w	8000e6e <__aeabi_fmul+0x15e>
 8000f74:	ea93 0f0c 	teq	r3, ip
 8000f78:	f47f af70 	bne.w	8000e5c <__aeabi_fmul+0x14c>
 8000f7c:	4608      	mov	r0, r1
 8000f7e:	e776      	b.n	8000e6e <__aeabi_fmul+0x15e>
 8000f80:	ea93 0f0c 	teq	r3, ip
 8000f84:	d104      	bne.n	8000f90 <__aeabi_fdiv+0x118>
 8000f86:	024b      	lsls	r3, r1, #9
 8000f88:	f43f af4c 	beq.w	8000e24 <__aeabi_fmul+0x114>
 8000f8c:	4608      	mov	r0, r1
 8000f8e:	e76e      	b.n	8000e6e <__aeabi_fmul+0x15e>
 8000f90:	f030 4c00 	bics.w	ip, r0, #2147483648	; 0x80000000
 8000f94:	bf18      	it	ne
 8000f96:	f031 4c00 	bicsne.w	ip, r1, #2147483648	; 0x80000000
 8000f9a:	d1ca      	bne.n	8000f32 <__aeabi_fdiv+0xba>
 8000f9c:	f030 4200 	bics.w	r2, r0, #2147483648	; 0x80000000
 8000fa0:	f47f af5c 	bne.w	8000e5c <__aeabi_fmul+0x14c>
 8000fa4:	f031 4300 	bics.w	r3, r1, #2147483648	; 0x80000000
 8000fa8:	f47f af3c 	bne.w	8000e24 <__aeabi_fmul+0x114>
 8000fac:	e75f      	b.n	8000e6e <__aeabi_fmul+0x15e>
 8000fae:	bf00      	nop

08000fb0 <__gesf2>:
 8000fb0:	f04f 3cff 	mov.w	ip, #4294967295
 8000fb4:	e006      	b.n	8000fc4 <__cmpsf2+0x4>
 8000fb6:	bf00      	nop

08000fb8 <__lesf2>:
 8000fb8:	f04f 0c01 	mov.w	ip, #1
 8000fbc:	e002      	b.n	8000fc4 <__cmpsf2+0x4>
 8000fbe:	bf00      	nop

08000fc0 <__cmpsf2>:
 8000fc0:	f04f 0c01 	mov.w	ip, #1
 8000fc4:	f84d cd04 	str.w	ip, [sp, #-4]!
 8000fc8:	ea4f 0240 	mov.w	r2, r0, lsl #1
 8000fcc:	ea4f 0341 	mov.w	r3, r1, lsl #1
 8000fd0:	ea7f 6c22 	mvns.w	ip, r2, asr #24
 8000fd4:	bf18      	it	ne
 8000fd6:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
 8000fda:	d011      	beq.n	8001000 <__cmpsf2+0x40>
 8000fdc:	b001      	add	sp, #4
 8000fde:	ea52 0c53 	orrs.w	ip, r2, r3, lsr #1
 8000fe2:	bf18      	it	ne
 8000fe4:	ea90 0f01 	teqne	r0, r1
 8000fe8:	bf58      	it	pl
 8000fea:	ebb2 0003 	subspl.w	r0, r2, r3
 8000fee:	bf88      	it	hi
 8000ff0:	17c8      	asrhi	r0, r1, #31
 8000ff2:	bf38      	it	cc
 8000ff4:	ea6f 70e1 	mvncc.w	r0, r1, asr #31
 8000ff8:	bf18      	it	ne
 8000ffa:	f040 0001 	orrne.w	r0, r0, #1
 8000ffe:	4770      	bx	lr
 8001000:	ea7f 6c22 	mvns.w	ip, r2, asr #24
 8001004:	d102      	bne.n	800100c <__cmpsf2+0x4c>
 8001006:	ea5f 2c40 	movs.w	ip, r0, lsl #9
 800100a:	d105      	bne.n	8001018 <__cmpsf2+0x58>
 800100c:	ea7f 6c23 	mvns.w	ip, r3, asr #24
 8001010:	d1e4      	bne.n	8000fdc <__cmpsf2+0x1c>
 8001012:	ea5f 2c41 	movs.w	ip, r1, lsl #9
 8001016:	d0e1      	beq.n	8000fdc <__cmpsf2+0x1c>
 8001018:	f85d 0b04 	ldr.w	r0, [sp], #4
 800101c:	4770      	bx	lr
 800101e:	bf00      	nop

08001020 <__aeabi_cfrcmple>:
 8001020:	4684      	mov	ip, r0
 8001022:	4608      	mov	r0, r1
 8001024:	4661      	mov	r1, ip
 8001026:	e7ff      	b.n	8001028 <__aeabi_cfcmpeq>

08001028 <__aeabi_cfcmpeq>:
 8001028:	b50f      	push	{r0, r1, r2, r3, lr}
 800102a:	f7ff ffc9 	bl	8000fc0 <__cmpsf2>
 800102e:	2800      	cmp	r0, #0
 8001030:	bf48      	it	mi
 8001032:	f110 0f00 	cmnmi.w	r0, #0
 8001036:	bd0f      	pop	{r0, r1, r2, r3, pc}

08001038 <__aeabi_fcmpeq>:
 8001038:	f84d ed08 	str.w	lr, [sp, #-8]!
 800103c:	f7ff fff4 	bl	8001028 <__aeabi_cfcmpeq>
 8001040:	bf0c      	ite	eq
 8001042:	2001      	moveq	r0, #1
 8001044:	2000      	movne	r0, #0
 8001046:	f85d fb08 	ldr.w	pc, [sp], #8
 800104a:	bf00      	nop

0800104c <__aeabi_fcmplt>:
 800104c:	f84d ed08 	str.w	lr, [sp, #-8]!
 8001050:	f7ff ffea 	bl	8001028 <__aeabi_cfcmpeq>
 8001054:	bf34      	ite	cc
 8001056:	2001      	movcc	r0, #1
 8001058:	2000      	movcs	r0, #0
 800105a:	f85d fb08 	ldr.w	pc, [sp], #8
 800105e:	bf00      	nop

08001060 <__aeabi_fcmple>:
 8001060:	f84d ed08 	str.w	lr, [sp, #-8]!
 8001064:	f7ff ffe0 	bl	8001028 <__aeabi_cfcmpeq>
 8001068:	bf94      	ite	ls
 800106a:	2001      	movls	r0, #1
 800106c:	2000      	movhi	r0, #0
 800106e:	f85d fb08 	ldr.w	pc, [sp], #8
 8001072:	bf00      	nop

08001074 <__aeabi_fcmpge>:
 8001074:	f84d ed08 	str.w	lr, [sp, #-8]!
 8001078:	f7ff ffd2 	bl	8001020 <__aeabi_cfrcmple>
 800107c:	bf94      	ite	ls
 800107e:	2001      	movls	r0, #1
 8001080:	2000      	movhi	r0, #0
 8001082:	f85d fb08 	ldr.w	pc, [sp], #8
 8001086:	bf00      	nop

08001088 <__aeabi_fcmpgt>:
 8001088:	f84d ed08 	str.w	lr, [sp, #-8]!
 800108c:	f7ff ffc8 	bl	8001020 <__aeabi_cfrcmple>
 8001090:	bf34      	ite	cc
 8001092:	2001      	movcc	r0, #1
 8001094:	2000      	movcs	r0, #0
 8001096:	f85d fb08 	ldr.w	pc, [sp], #8
 800109a:	bf00      	nop
 800109c:	0000      	movs	r0, r0
	...

080010a0 <__aeabi_f2iz>:
 80010a0:	ea4f 0240 	mov.w	r2, r0, lsl #1
 80010a4:	f1b2 4ffe 	cmp.w	r2, #2130706432	; 0x7f000000
 80010a8:	d30f      	bcc.n	80010ca <__aeabi_f2iz+0x2a>
 80010aa:	f04f 039e 	mov.w	r3, #158	; 0x9e
 80010ae:	ebb3 6212 	subs.w	r2, r3, r2, lsr #24
 80010b2:	d90d      	bls.n	80010d0 <__aeabi_f2iz+0x30>
 80010b4:	ea4f 2300 	mov.w	r3, r0, lsl #8
 80010b8:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 80010bc:	f010 4f00 	tst.w	r0, #2147483648	; 0x80000000
 80010c0:	fa23 f002 	lsr.w	r0, r3, r2
 80010c4:	bf18      	it	ne
 80010c6:	4240      	negne	r0, r0
 80010c8:	4770      	bx	lr
 80010ca:	f04f 0000 	mov.w	r0, #0
 80010ce:	4770      	bx	lr
 80010d0:	f112 0f61 	cmn.w	r2, #97	; 0x61
 80010d4:	d101      	bne.n	80010da <__aeabi_f2iz+0x3a>
 80010d6:	0242      	lsls	r2, r0, #9
 80010d8:	d105      	bne.n	80010e6 <__aeabi_f2iz+0x46>
 80010da:	f010 4000 	ands.w	r0, r0, #2147483648	; 0x80000000
 80010de:	bf08      	it	eq
 80010e0:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
 80010e4:	4770      	bx	lr
 80010e6:	f04f 0000 	mov.w	r0, #0
 80010ea:	4770      	bx	lr
 80010ec:	0000      	movs	r0, r0
	...

080010f0 <memcpy>:
 80010f0:	4684      	mov	ip, r0
 80010f2:	ea41 0300 	orr.w	r3, r1, r0
 80010f6:	f013 0303 	ands.w	r3, r3, #3
 80010fa:	d149      	bne.n	8001190 <memcpy+0xa0>
 80010fc:	3a40      	subs	r2, #64	; 0x40
 80010fe:	d323      	bcc.n	8001148 <memcpy+0x58>
 8001100:	680b      	ldr	r3, [r1, #0]
 8001102:	6003      	str	r3, [r0, #0]
 8001104:	684b      	ldr	r3, [r1, #4]
 8001106:	6043      	str	r3, [r0, #4]
 8001108:	688b      	ldr	r3, [r1, #8]
 800110a:	6083      	str	r3, [r0, #8]
 800110c:	68cb      	ldr	r3, [r1, #12]
 800110e:	60c3      	str	r3, [r0, #12]
 8001110:	690b      	ldr	r3, [r1, #16]
 8001112:	6103      	str	r3, [r0, #16]
 8001114:	694b      	ldr	r3, [r1, #20]
 8001116:	6143      	str	r3, [r0, #20]
 8001118:	698b      	ldr	r3, [r1, #24]
 800111a:	6183      	str	r3, [r0, #24]
 800111c:	69cb      	ldr	r3, [r1, #28]
 800111e:	61c3      	str	r3, [r0, #28]
 8001120:	6a0b      	ldr	r3, [r1, #32]
 8001122:	6203      	str	r3, [r0, #32]
 8001124:	6a4b      	ldr	r3, [r1, #36]	; 0x24
 8001126:	6243      	str	r3, [r0, #36]	; 0x24
 8001128:	6a8b      	ldr	r3, [r1, #40]	; 0x28
 800112a:	6283      	str	r3, [r0, #40]	; 0x28
 800112c:	6acb      	ldr	r3, [r1, #44]	; 0x2c
 800112e:	62c3      	str	r3, [r0, #44]	; 0x2c
 8001130:	6b0b      	ldr	r3, [r1, #48]	; 0x30
 8001132:	6303      	str	r3, [r0, #48]	; 0x30
 8001134:	6b4b      	ldr	r3, [r1, #52]	; 0x34
 8001136:	6343      	str	r3, [r0, #52]	; 0x34
 8001138:	6b8b      	ldr	r3, [r1, #56]	; 0x38
 800113a:	6383      	str	r3, [r0, #56]	; 0x38
 800113c:	6bcb      	ldr	r3, [r1, #60]	; 0x3c
 800113e:	63c3      	str	r3, [r0, #60]	; 0x3c
 8001140:	3040      	adds	r0, #64	; 0x40
 8001142:	3140      	adds	r1, #64	; 0x40
 8001144:	3a40      	subs	r2, #64	; 0x40
 8001146:	d2db      	bcs.n	8001100 <memcpy+0x10>
 8001148:	3230      	adds	r2, #48	; 0x30
 800114a:	d30b      	bcc.n	8001164 <memcpy+0x74>
 800114c:	680b      	ldr	r3, [r1, #0]
 800114e:	6003      	str	r3, [r0, #0]
 8001150:	684b      	ldr	r3, [r1, #4]
 8001152:	6043      	str	r3, [r0, #4]
 8001154:	688b      	ldr	r3, [r1, #8]
 8001156:	6083      	str	r3, [r0, #8]
 8001158:	68cb      	ldr	r3, [r1, #12]
 800115a:	60c3      	str	r3, [r0, #12]
 800115c:	3010      	adds	r0, #16
 800115e:	3110      	adds	r1, #16
 8001160:	3a10      	subs	r2, #16
 8001162:	d2f3      	bcs.n	800114c <memcpy+0x5c>
 8001164:	320c      	adds	r2, #12
 8001166:	d305      	bcc.n	8001174 <memcpy+0x84>
 8001168:	f851 3b04 	ldr.w	r3, [r1], #4
 800116c:	f840 3b04 	str.w	r3, [r0], #4
 8001170:	3a04      	subs	r2, #4
 8001172:	d2f9      	bcs.n	8001168 <memcpy+0x78>
 8001174:	3204      	adds	r2, #4
 8001176:	d008      	beq.n	800118a <memcpy+0x9a>
 8001178:	07d2      	lsls	r2, r2, #31
 800117a:	bf1c      	itt	ne
 800117c:	f811 3b01 	ldrbne.w	r3, [r1], #1
 8001180:	f800 3b01 	strbne.w	r3, [r0], #1
 8001184:	d301      	bcc.n	800118a <memcpy+0x9a>
 8001186:	880b      	ldrh	r3, [r1, #0]
 8001188:	8003      	strh	r3, [r0, #0]
 800118a:	4660      	mov	r0, ip
 800118c:	4770      	bx	lr
 800118e:	bf00      	nop
 8001190:	2a08      	cmp	r2, #8
 8001192:	d313      	bcc.n	80011bc <memcpy+0xcc>
 8001194:	078b      	lsls	r3, r1, #30
 8001196:	d0b1      	beq.n	80010fc <memcpy+0xc>
 8001198:	f010 0303 	ands.w	r3, r0, #3
 800119c:	d0ae      	beq.n	80010fc <memcpy+0xc>
 800119e:	f1c3 0304 	rsb	r3, r3, #4
 80011a2:	1ad2      	subs	r2, r2, r3
 80011a4:	07db      	lsls	r3, r3, #31
 80011a6:	bf1c      	itt	ne
 80011a8:	f811 3b01 	ldrbne.w	r3, [r1], #1
 80011ac:	f800 3b01 	strbne.w	r3, [r0], #1
 80011b0:	d3a4      	bcc.n	80010fc <memcpy+0xc>
 80011b2:	f831 3b02 	ldrh.w	r3, [r1], #2
 80011b6:	f820 3b02 	strh.w	r3, [r0], #2
 80011ba:	e79f      	b.n	80010fc <memcpy+0xc>
 80011bc:	3a04      	subs	r2, #4
 80011be:	d3d9      	bcc.n	8001174 <memcpy+0x84>
 80011c0:	3a01      	subs	r2, #1
 80011c2:	f811 3b01 	ldrb.w	r3, [r1], #1
 80011c6:	f800 3b01 	strb.w	r3, [r0], #1
 80011ca:	d2f9      	bcs.n	80011c0 <memcpy+0xd0>
 80011cc:	780b      	ldrb	r3, [r1, #0]
 80011ce:	7003      	strb	r3, [r0, #0]
 80011d0:	784b      	ldrb	r3, [r1, #1]
 80011d2:	7043      	strb	r3, [r0, #1]
 80011d4:	788b      	ldrb	r3, [r1, #2]
 80011d6:	7083      	strb	r3, [r0, #2]
 80011d8:	4660      	mov	r0, ip
 80011da:	4770      	bx	lr
 80011dc:	0000      	movs	r0, r0
	...

080011e0 <__core_init>:
 */
#if !defined(__DOXYGEN__)
__attribute__((weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __core_init(void) {
 80011e0:	4770      	bx	lr
 80011e2:	bf00      	nop
	...

080011f0 <__late_init>:
 */
#if !defined(__DOXYGEN__)
__attribute__((weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __late_init(void) {}
 80011f0:	4770      	bx	lr
 80011f2:	bf00      	nop
	...

08001200 <__default_exit>:
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __default_exit(void) {
/*lint -restore*/

  while (true) {
  }
 8001200:	e7fe      	b.n	8001200 <__default_exit>
 8001202:	bf00      	nop
	...

08001210 <__init_ram_areas>:
}

/**
 * @brief   Performs the initialization of the various RAM areas.
 */
void __init_ram_areas(void) {
 8001210:	b4f0      	push	{r4, r5, r6, r7}
#if CRT1_AREAS_NUMBER > 0
  const ram_init_area_t *rap = ram_areas;
 8001212:	4e11      	ldr	r6, [pc, #68]	; (8001258 <__init_ram_areas+0x48>)
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
      *p = 0;
 8001214:	2500      	movs	r5, #0
 8001216:	f106 0780 	add.w	r7, r6, #128	; 0x80
void __init_ram_areas(void) {
#if CRT1_AREAS_NUMBER > 0
  const ram_init_area_t *rap = ram_areas;

  do {
    uint32_t *tp = rap->init_text_area;
 800121a:	e896 001a 	ldmia.w	r6, {r1, r3, r4}
    uint32_t *p = rap->init_area;

    /* Copying initialization data.*/
    while (p < rap->clear_area) {
 800121e:	42a3      	cmp	r3, r4
 8001220:	d20d      	bcs.n	800123e <__init_ram_areas+0x2e>
 8001222:	461a      	mov	r2, r3
 8001224:	3904      	subs	r1, #4
      *p = *tp;
 8001226:	f851 0f04 	ldr.w	r0, [r1, #4]!
 800122a:	f842 0b04 	str.w	r0, [r2], #4
  do {
    uint32_t *tp = rap->init_text_area;
    uint32_t *p = rap->init_area;

    /* Copying initialization data.*/
    while (p < rap->clear_area) {
 800122e:	42a2      	cmp	r2, r4
 8001230:	d3f9      	bcc.n	8001226 <__init_ram_areas+0x16>
 8001232:	43da      	mvns	r2, r3
 8001234:	4414      	add	r4, r2
 8001236:	f024 0403 	bic.w	r4, r4, #3
 800123a:	3404      	adds	r4, #4
 800123c:	4423      	add	r3, r4
      p++;
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
 800123e:	68f2      	ldr	r2, [r6, #12]
 8001240:	4293      	cmp	r3, r2
 8001242:	d203      	bcs.n	800124c <__init_ram_areas+0x3c>
      *p = 0;
 8001244:	f843 5b04 	str.w	r5, [r3], #4
      p++;
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
 8001248:	4293      	cmp	r3, r2
 800124a:	d3fb      	bcc.n	8001244 <__init_ram_areas+0x34>
      *p = 0;
      p++;
    }
    rap++;
 800124c:	3610      	adds	r6, #16
  }
  while (rap < &ram_areas[CRT1_AREAS_NUMBER]);
 800124e:	42be      	cmp	r6, r7
 8001250:	d3e3      	bcc.n	800121a <__init_ram_areas+0xa>
#endif
}
 8001252:	bcf0      	pop	{r4, r5, r6, r7}
 8001254:	4770      	bx	lr
 8001256:	bf00      	nop
 8001258:	08004640 	.word	0x08004640
 800125c:	00000000 	.word	0x00000000

08001260 <_unhandled_exception>:
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void _unhandled_exception(void) {
/*lint -restore*/

  while (true) {
  }
 8001260:	e7fe      	b.n	8001260 <_unhandled_exception>
 8001262:	bf00      	nop
	...

08001270 <_idle_thread>:
 *          that this thread is executed only if there are no other ready
 *          threads in the system.
 *
 * @param[in] p         the thread parameter, unused in this scenario
 */
static void _idle_thread(void *p) {
 8001270:	e7fe      	b.n	8001270 <_idle_thread>
 8001272:	bf00      	nop
	...

08001280 <chSysInit>:
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk));             /* clear bits to change               */
 8001280:	f64f 01ff 	movw	r1, #63743	; 0xf8ff
 * @brief   Port-related initialization code.
 */
static inline void port_init(void) {

  /* Initialization of the vector table and priority related settings.*/
  SCB->VTOR = CORTEX_VTOR_INIT;
 8001284:	4b1b      	ldr	r3, [pc, #108]	; (80012f4 <chSysInit+0x74>)
 * @post    The main thread is created with priority @p NORMALPRIO and
 *          interrupts are enabled.
 *
 * @special
 */
void chSysInit(void) {
 8001286:	b570      	push	{r4, r5, r6, lr}
 8001288:	2500      	movs	r5, #0
 800128a:	609d      	str	r5, [r3, #8]
__STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 800128c:	68d8      	ldr	r0, [r3, #12]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk));             /* clear bits to change               */
  reg_value  =  (reg_value                                   |
 800128e:	4a1a      	ldr	r2, [pc, #104]	; (80012f8 <chSysInit+0x78>)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk));             /* clear bits to change               */
 8001290:	4001      	ands	r1, r0
  reg_value  =  (reg_value                                   |
 8001292:	430a      	orrs	r2, r1

  /* Initializing priority grouping.*/
  NVIC_SetPriorityGrouping(CORTEX_PRIGROUP_INIT);

  /* DWT cycle counter enable, note, the M7 requires DWT unlocking.*/
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
 8001294:	4819      	ldr	r0, [pc, #100]	; (80012fc <chSysInit+0x7c>)
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8)                       );              /* Insert write key and priorty group */
  SCB->AIRCR =  reg_value;
 8001296:	60da      	str	r2, [r3, #12]
 8001298:	68c2      	ldr	r2, [r0, #12]
#if CORTEX_MODEL == 7
  DWT->LAR = 0xC5ACCE55U;
#endif
  DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
 800129a:	4919      	ldr	r1, [pc, #100]	; (8001300 <chSysInit+0x80>)

  /* Initializing priority grouping.*/
  NVIC_SetPriorityGrouping(CORTEX_PRIGROUP_INIT);

  /* DWT cycle counter enable, note, the M7 requires DWT unlocking.*/
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
 800129c:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 80012a0:	60c2      	str	r2, [r0, #12]
#if CORTEX_MODEL == 7
  DWT->LAR = 0xC5ACCE55U;
#endif
  DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
 80012a2:	680a      	ldr	r2, [r1, #0]
    \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if((int32_t)IRQn < 0) {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8 - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80012a4:	2020      	movs	r0, #32
 80012a6:	f042 0201 	orr.w	r2, r2, #1
  _dbg_trace_init();
#endif

#if CH_CFG_NO_IDLE_THREAD == FALSE
  /* Now this instructions flow becomes the main thread.*/
  setcurrp(_thread_init(&ch.mainthread, NORMALPRIO));
 80012aa:	4c16      	ldr	r4, [pc, #88]	; (8001304 <chSysInit+0x84>)
 80012ac:	2610      	movs	r6, #16
 80012ae:	600a      	str	r2, [r1, #0]
 * @post    The main thread is created with priority @p NORMALPRIO and
 *          interrupts are enabled.
 *
 * @special
 */
void chSysInit(void) {
 80012b0:	b082      	sub	sp, #8
 80012b2:	77de      	strb	r6, [r3, #31]
 80012b4:	f883 0022 	strb.w	r0, [r3, #34]	; 0x22
#if CH_DBG_ENABLE_STACK_CHECK == TRUE
  extern stkalign_t __main_thread_stack_base__;
#endif

  port_init();
  _scheduler_init();
 80012b8:	f000 f8d2 	bl	8001460 <_scheduler_init>
  _vt_init();
 80012bc:	f000 f850 	bl	8001360 <_vt_init>
#if CH_CFG_USE_TM == TRUE
  _tm_init();
 80012c0:	f000 fa7e 	bl	80017c0 <_tm_init>
#endif
#if CH_CFG_USE_MEMCORE == TRUE
  _core_init();
 80012c4:	f000 fc0c 	bl	8001ae0 <_core_init>
#endif
#if CH_CFG_USE_HEAP == TRUE
  _heap_init();
 80012c8:	f000 fc42 	bl	8001b50 <_heap_init>
  _dbg_trace_init();
#endif

#if CH_CFG_NO_IDLE_THREAD == FALSE
  /* Now this instructions flow becomes the main thread.*/
  setcurrp(_thread_init(&ch.mainthread, NORMALPRIO));
 80012cc:	4620      	mov	r0, r4
 80012ce:	2140      	movs	r1, #64	; 0x40
 80012d0:	f000 f98e 	bl	80015f0 <_thread_init>
#else
  /* Now this instructions flow becomes the idle thread.*/
  setcurrp(_thread_init(&ch.mainthread, IDLEPRIO));
#endif

  currp->p_state = CH_STATE_CURRENT;
 80012d4:	2201      	movs	r2, #1
  _dbg_trace_init();
#endif

#if CH_CFG_NO_IDLE_THREAD == FALSE
  /* Now this instructions flow becomes the main thread.*/
  setcurrp(_thread_init(&ch.mainthread, NORMALPRIO));
 80012d6:	f844 0c14 	str.w	r0, [r4, #-20]
#else
  /* Now this instructions flow becomes the idle thread.*/
  setcurrp(_thread_init(&ch.mainthread, IDLEPRIO));
#endif

  currp->p_state = CH_STATE_CURRENT;
 80012da:	7402      	strb	r2, [r0, #16]

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 80012dc:	f385 8811 	msr	BASEPRI, r5
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80012e0:	b662      	cpsie	i
#if CH_CFG_NO_IDLE_THREAD == FALSE
  {
  /* This thread has the lowest priority in the system, its role is just to
     serve interrupts in its context while keeping the lowest energy saving
     mode compatible with the system status.*/
    thread_t *tp =  chThdCreateStatic(ch.idle_thread_wa,
 80012e2:	21d0      	movs	r1, #208	; 0xd0
 80012e4:	9500      	str	r5, [sp, #0]
 80012e6:	f104 003c 	add.w	r0, r4, #60	; 0x3c
 80012ea:	4b07      	ldr	r3, [pc, #28]	; (8001308 <chSysInit+0x88>)
 80012ec:	f000 f998 	bl	8001620 <chThdCreateStatic>
                                      (tfunc_t)_idle_thread,
                                      NULL);
    chRegSetThreadNameX(tp, "idle");
  }
#endif
}
 80012f0:	b002      	add	sp, #8
 80012f2:	bd70      	pop	{r4, r5, r6, pc}
 80012f4:	e000ed00 	.word	0xe000ed00
 80012f8:	05fa0300 	.word	0x05fa0300
 80012fc:	e000edf0 	.word	0xe000edf0
 8001300:	e0001000 	.word	0xe0001000
 8001304:	20000914 	.word	0x20000914
 8001308:	08001271 	.word	0x08001271
 800130c:	00000000 	.word	0x00000000

08001310 <chSysTimerHandlerI>:
 *          and, together with the @p CH_CFG_TIME_QUANTUM macro, the round robin
 *          interval.
 *
 * @iclass
 */
void chSysTimerHandlerI(void) {
 8001310:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
static inline void chVTDoTickI(void) {

  chDbgCheckClassI();

#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.vt_systime++;
 8001312:	4d10      	ldr	r5, [pc, #64]	; (8001354 <chSysTimerHandlerI+0x44>)
  if (&ch.vtlist != (virtual_timers_list_t *)ch.vtlist.vt_next) {
 8001314:	462e      	mov	r6, r5
static inline void chVTDoTickI(void) {

  chDbgCheckClassI();

#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.vt_systime++;
 8001316:	8bea      	ldrh	r2, [r5, #30]
  if (&ch.vtlist != (virtual_timers_list_t *)ch.vtlist.vt_next) {
 8001318:	f856 3f14 	ldr.w	r3, [r6, #20]!
static inline void chVTDoTickI(void) {

  chDbgCheckClassI();

#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.vt_systime++;
 800131c:	3201      	adds	r2, #1
 800131e:	b292      	uxth	r2, r2
  if (&ch.vtlist != (virtual_timers_list_t *)ch.vtlist.vt_next) {
 8001320:	42b3      	cmp	r3, r6
static inline void chVTDoTickI(void) {

  chDbgCheckClassI();

#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.vt_systime++;
 8001322:	83ea      	strh	r2, [r5, #30]
  if (&ch.vtlist != (virtual_timers_list_t *)ch.vtlist.vt_next) {
 8001324:	d014      	beq.n	8001350 <chSysTimerHandlerI+0x40>
    /* The list is not empty, processing elements on top.*/
    --ch.vtlist.vt_next->vt_delta;
 8001326:	891c      	ldrh	r4, [r3, #8]
 8001328:	3c01      	subs	r4, #1
 800132a:	b2a4      	uxth	r4, r4
 800132c:	811c      	strh	r4, [r3, #8]
    while (ch.vtlist.vt_next->vt_delta == (systime_t)0) {
 800132e:	b97c      	cbnz	r4, 8001350 <chSysTimerHandlerI+0x40>

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8001330:	2720      	movs	r7, #32
      vtfunc_t fn;

      vtp = ch.vtlist.vt_next;
      fn = vtp->vt_func;
      vtp->vt_func = NULL;
      vtp->vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
 8001332:	681a      	ldr	r2, [r3, #0]
    while (ch.vtlist.vt_next->vt_delta == (systime_t)0) {
      virtual_timer_t *vtp;
      vtfunc_t fn;

      vtp = ch.vtlist.vt_next;
      fn = vtp->vt_func;
 8001334:	68d9      	ldr	r1, [r3, #12]
      vtp->vt_func = NULL;
 8001336:	60dc      	str	r4, [r3, #12]
      vtp->vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
 8001338:	6056      	str	r6, [r2, #4]
      ch.vtlist.vt_next = vtp->vt_next;
 800133a:	616a      	str	r2, [r5, #20]
 800133c:	f384 8811 	msr	BASEPRI, r4
      chSysUnlockFromISR();
      fn(vtp->vt_par);
 8001340:	6918      	ldr	r0, [r3, #16]
 8001342:	4788      	blx	r1
 8001344:	f387 8811 	msr	BASEPRI, r7
#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.vt_systime++;
  if (&ch.vtlist != (virtual_timers_list_t *)ch.vtlist.vt_next) {
    /* The list is not empty, processing elements on top.*/
    --ch.vtlist.vt_next->vt_delta;
    while (ch.vtlist.vt_next->vt_delta == (systime_t)0) {
 8001348:	696b      	ldr	r3, [r5, #20]
 800134a:	891a      	ldrh	r2, [r3, #8]
 800134c:	2a00      	cmp	r2, #0
 800134e:	d0f0      	beq.n	8001332 <chSysTimerHandlerI+0x22>
 8001350:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8001352:	bf00      	nop
 8001354:	200008f0 	.word	0x200008f0
	...

08001360 <_vt_init>:
 */
void _vt_init(void) {

  ch.vtlist.vt_next = (virtual_timer_t *)&ch.vtlist;
  ch.vtlist.vt_prev = (virtual_timer_t *)&ch.vtlist;
  ch.vtlist.vt_delta = (systime_t)-1;
 8001360:	f64f 70ff 	movw	r0, #65535	; 0xffff
 *
 * @notapi
 */
void _vt_init(void) {

  ch.vtlist.vt_next = (virtual_timer_t *)&ch.vtlist;
 8001364:	4b04      	ldr	r3, [pc, #16]	; (8001378 <_vt_init+0x18>)
  ch.vtlist.vt_prev = (virtual_timer_t *)&ch.vtlist;
  ch.vtlist.vt_delta = (systime_t)-1;
#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.vt_systime = (systime_t)0;
 8001366:	2100      	movs	r1, #0
 *
 * @notapi
 */
void _vt_init(void) {

  ch.vtlist.vt_next = (virtual_timer_t *)&ch.vtlist;
 8001368:	f103 0214 	add.w	r2, r3, #20
  ch.vtlist.vt_prev = (virtual_timer_t *)&ch.vtlist;
  ch.vtlist.vt_delta = (systime_t)-1;
 800136c:	8398      	strh	r0, [r3, #28]
#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.vt_systime = (systime_t)0;
 800136e:	83d9      	strh	r1, [r3, #30]
 *
 * @notapi
 */
void _vt_init(void) {

  ch.vtlist.vt_next = (virtual_timer_t *)&ch.vtlist;
 8001370:	615a      	str	r2, [r3, #20]
  ch.vtlist.vt_prev = (virtual_timer_t *)&ch.vtlist;
 8001372:	619a      	str	r2, [r3, #24]
 8001374:	4770      	bx	lr
 8001376:	bf00      	nop
 8001378:	200008f0 	.word	0x200008f0
 800137c:	00000000 	.word	0x00000000

08001380 <chVTDoSetI>:
 *                      function
 *
 * @iclass
 */
void chVTDoSetI(virtual_timer_t *vtp, systime_t delay,
                vtfunc_t vtfunc, void *par) {
 8001380:	b430      	push	{r4, r5}
  delta = delay;
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  p = ch.vtlist.vt_next;
 8001382:	4c0d      	ldr	r4, [pc, #52]	; (80013b8 <chVTDoSetI+0x38>)
  systime_t delta;

  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));

  vtp->vt_par = par;
 8001384:	6103      	str	r3, [r0, #16]
  delta = delay;
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  p = ch.vtlist.vt_next;
 8001386:	6963      	ldr	r3, [r4, #20]

  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));

  vtp->vt_par = par;
  vtp->vt_func = vtfunc;
 8001388:	60c2      	str	r2, [r0, #12]
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  p = ch.vtlist.vt_next;
  while (p->vt_delta < delta) {
 800138a:	891a      	ldrh	r2, [r3, #8]
 800138c:	4291      	cmp	r1, r2
 800138e:	d905      	bls.n	800139c <chVTDoSetI+0x1c>
    delta -= p->vt_delta;
    p = p->vt_next;
 8001390:	681b      	ldr	r3, [r3, #0]

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  p = ch.vtlist.vt_next;
  while (p->vt_delta < delta) {
    delta -= p->vt_delta;
 8001392:	1a89      	subs	r1, r1, r2
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  p = ch.vtlist.vt_next;
  while (p->vt_delta < delta) {
 8001394:	891a      	ldrh	r2, [r3, #8]
    delta -= p->vt_delta;
 8001396:	b289      	uxth	r1, r1
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  p = ch.vtlist.vt_next;
  while (p->vt_delta < delta) {
 8001398:	428a      	cmp	r2, r1
 800139a:	d3f9      	bcc.n	8001390 <chVTDoSetI+0x10>
  vtp->vt_delta = delta

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/;
  p->vt_delta -= delta;
  ch.vtlist.vt_delta = (systime_t)-1;
 800139c:	f64f 75ff 	movw	r5, #65535	; 0xffff
    p = p->vt_next;
  }

  /* The timer is inserted in the delta list.*/
  vtp->vt_next = p;
  vtp->vt_prev = vtp->vt_next->vt_prev;
 80013a0:	685a      	ldr	r2, [r3, #4]
    delta -= p->vt_delta;
    p = p->vt_next;
  }

  /* The timer is inserted in the delta list.*/
  vtp->vt_next = p;
 80013a2:	6003      	str	r3, [r0, #0]
  vtp->vt_prev = vtp->vt_next->vt_prev;
 80013a4:	6042      	str	r2, [r0, #4]
  vtp->vt_prev->vt_next = vtp;
 80013a6:	6010      	str	r0, [r2, #0]
  p->vt_prev = vtp;
 80013a8:	6058      	str	r0, [r3, #4]
  vtp->vt_delta = delta
 80013aa:	8101      	strh	r1, [r0, #8]

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/;
  p->vt_delta -= delta;
 80013ac:	891a      	ldrh	r2, [r3, #8]
 80013ae:	1a51      	subs	r1, r2, r1
 80013b0:	8119      	strh	r1, [r3, #8]
  ch.vtlist.vt_delta = (systime_t)-1;
 80013b2:	83a5      	strh	r5, [r4, #28]
}
 80013b4:	bc30      	pop	{r4, r5}
 80013b6:	4770      	bx	lr
 80013b8:	200008f0 	.word	0x200008f0
 80013bc:	00000000 	.word	0x00000000

080013c0 <chVTDoResetI>:
 *
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 *
 * @iclass
 */
void chVTDoResetI(virtual_timer_t *vtp) {
 80013c0:	b430      	push	{r4, r5}
  vtp->vt_next->vt_prev = vtp->vt_prev;
  vtp->vt_func = NULL;

  /* The above code changes the value in the header when the removed element
     is the last of the list, restoring it.*/
  ch.vtlist.vt_delta = (systime_t)-1;
 80013c2:	f64f 74ff 	movw	r4, #65535	; 0xffff
  chDbgAssert(vtp->vt_func != NULL, "timer not set or already triggered");

#if CH_CFG_ST_TIMEDELTA == 0

  /* The delta of the timer is added to the next timer.*/
  vtp->vt_next->vt_delta += vtp->vt_delta;
 80013c6:	6803      	ldr	r3, [r0, #0]
 80013c8:	8905      	ldrh	r5, [r0, #8]
 80013ca:	891a      	ldrh	r2, [r3, #8]

 /* Removing the element from the delta list.*/
  vtp->vt_prev->vt_next = vtp->vt_next;
 80013cc:	6841      	ldr	r1, [r0, #4]
  chDbgAssert(vtp->vt_func != NULL, "timer not set or already triggered");

#if CH_CFG_ST_TIMEDELTA == 0

  /* The delta of the timer is added to the next timer.*/
  vtp->vt_next->vt_delta += vtp->vt_delta;
 80013ce:	442a      	add	r2, r5
 80013d0:	811a      	strh	r2, [r3, #8]

 /* Removing the element from the delta list.*/
  vtp->vt_prev->vt_next = vtp->vt_next;
 80013d2:	600b      	str	r3, [r1, #0]
  vtp->vt_next->vt_prev = vtp->vt_prev;
 80013d4:	6805      	ldr	r5, [r0, #0]
  vtp->vt_func = NULL;

  /* The above code changes the value in the header when the removed element
     is the last of the list, restoring it.*/
  ch.vtlist.vt_delta = (systime_t)-1;
 80013d6:	4b03      	ldr	r3, [pc, #12]	; (80013e4 <chVTDoResetI+0x24>)
  vtp->vt_next->vt_delta += vtp->vt_delta;

 /* Removing the element from the delta list.*/
  vtp->vt_prev->vt_next = vtp->vt_next;
  vtp->vt_next->vt_prev = vtp->vt_prev;
  vtp->vt_func = NULL;
 80013d8:	2200      	movs	r2, #0
  /* The delta of the timer is added to the next timer.*/
  vtp->vt_next->vt_delta += vtp->vt_delta;

 /* Removing the element from the delta list.*/
  vtp->vt_prev->vt_next = vtp->vt_next;
  vtp->vt_next->vt_prev = vtp->vt_prev;
 80013da:	6069      	str	r1, [r5, #4]
  vtp->vt_func = NULL;
 80013dc:	60c2      	str	r2, [r0, #12]

  /* The above code changes the value in the header when the removed element
     is the last of the list, restoring it.*/
  ch.vtlist.vt_delta = (systime_t)-1;
 80013de:	839c      	strh	r4, [r3, #28]
    delta = (systime_t)CH_CFG_ST_TIMEDELTA;
  }

  port_timer_set_alarm(ch.vtlist.vt_lasttime + nowdelta + delta);
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 80013e0:	bc30      	pop	{r4, r5}
 80013e2:	4770      	bx	lr
 80013e4:	200008f0 	.word	0x200008f0
	...

080013f0 <wakeup>:
}

/*
 * Timeout wakeup callback.
 */
static void wakeup(void *p) {
 80013f0:	b410      	push	{r4}
 80013f2:	2320      	movs	r3, #32
 80013f4:	f383 8811 	msr	BASEPRI, r3
  thread_t *tp = (thread_t *)p;

  chSysLockFromISR();
  switch (tp->p_state) {
 80013f8:	7c03      	ldrb	r3, [r0, #16]
 80013fa:	2b07      	cmp	r3, #7
 80013fc:	d80e      	bhi.n	800141c <wakeup+0x2c>
 80013fe:	e8df f003 	tbb	[pc, r3]
 8001402:	0d27      	.short	0x0d27
 8001404:	0408230d 	.word	0x0408230d
 8001408:	080d      	.short	0x080d
  case CH_STATE_SUSPENDED:
    *tp->p_u.wttrp = NULL;
    break;
#if CH_CFG_USE_SEMAPHORES == TRUE
  case CH_STATE_WTSEM:
    chSemFastSignalI(tp->p_u.wtsemp);
 800140a:	6942      	ldr	r2, [r0, #20]
 */
static inline void chSemFastSignalI(semaphore_t *sp) {

  chDbgCheckClassI();

  sp->s_cnt++;
 800140c:	6893      	ldr	r3, [r2, #8]
 800140e:	3301      	adds	r3, #1
 8001410:	6093      	str	r3, [r2, #8]
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->p_prev->p_next = tp->p_next;
 8001412:	e890 000c 	ldmia.w	r0, {r2, r3}
 8001416:	601a      	str	r2, [r3, #0]
  tp->p_next->p_prev = tp->p_prev;
 8001418:	6802      	ldr	r2, [r0, #0]
 800141a:	6053      	str	r3, [r2, #4]
    break;
  default:
    /* Any other state, nothing to do.*/
    break;
  }
  tp->p_u.rdymsg = MSG_TIMEOUT;
 800141c:	f04f 34ff 	mov.w	r4, #4294967295
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
 8001420:	2200      	movs	r2, #0
 8001422:	6881      	ldr	r1, [r0, #8]
  cp = (thread_t *)&ch.rlist.r_queue;
 8001424:	4b0d      	ldr	r3, [pc, #52]	; (800145c <wakeup+0x6c>)
    break;
  default:
    /* Any other state, nothing to do.*/
    break;
  }
  tp->p_u.rdymsg = MSG_TIMEOUT;
 8001426:	6144      	str	r4, [r0, #20]
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
 8001428:	7402      	strb	r2, [r0, #16]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
 800142a:	681b      	ldr	r3, [r3, #0]
  } while (cp->p_prio >= tp->p_prio);
 800142c:	689a      	ldr	r2, [r3, #8]
 800142e:	428a      	cmp	r2, r1
 8001430:	d2fb      	bcs.n	800142a <wakeup+0x3a>
  /* Insertion on p_prev.*/
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 8001432:	685a      	ldr	r2, [r3, #4]
 8001434:	2100      	movs	r1, #0
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio >= tp->p_prio);
  /* Insertion on p_prev.*/
  tp->p_next = cp;
 8001436:	6003      	str	r3, [r0, #0]
  tp->p_prev = cp->p_prev;
 8001438:	6042      	str	r2, [r0, #4]
  tp->p_prev->p_next = tp;
 800143a:	6010      	str	r0, [r2, #0]
  cp->p_prev = tp;
 800143c:	6058      	str	r0, [r3, #4]
 800143e:	f381 8811 	msr	BASEPRI, r1
    break;
  }
  tp->p_u.rdymsg = MSG_TIMEOUT;
  (void) chSchReadyI(tp);
  chSysUnlockFromISR();
}
 8001442:	f85d 4b04 	ldr.w	r4, [sp], #4
 8001446:	4770      	bx	lr
    /* Handling the special case where the thread has been made ready by
       another thread with higher priority.*/
    chSysUnlockFromISR();
    return;
  case CH_STATE_SUSPENDED:
    *tp->p_u.wttrp = NULL;
 8001448:	6943      	ldr	r3, [r0, #20]
 800144a:	2200      	movs	r2, #0
 800144c:	601a      	str	r2, [r3, #0]
    break;
 800144e:	e7e5      	b.n	800141c <wakeup+0x2c>
 8001450:	2300      	movs	r3, #0
 8001452:	f383 8811 	msr	BASEPRI, r3
    break;
  }
  tp->p_u.rdymsg = MSG_TIMEOUT;
  (void) chSchReadyI(tp);
  chSysUnlockFromISR();
}
 8001456:	f85d 4b04 	ldr.w	r4, [sp], #4
 800145a:	4770      	bx	lr
 800145c:	200008f0 	.word	0x200008f0

08001460 <_scheduler_init>:
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8001460:	4b02      	ldr	r3, [pc, #8]	; (800146c <_scheduler_init+0xc>)
 * @notapi
 */
void _scheduler_init(void) {

  queue_init(&ch.rlist.r_queue);
  ch.rlist.r_prio = NOPRIO;
 8001462:	2200      	movs	r2, #0
 8001464:	601b      	str	r3, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
 8001466:	605b      	str	r3, [r3, #4]
 8001468:	609a      	str	r2, [r3, #8]
 800146a:	4770      	bx	lr
 800146c:	200008f0 	.word	0x200008f0

08001470 <chSchReadyI>:
 * @param[in] tp        the thread to be made ready
 * @return              The thread pointer.
 *
 * @iclass
 */
thread_t *chSchReadyI(thread_t *tp) {
 8001470:	b410      	push	{r4}
 8001472:	4604      	mov	r4, r0
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
 8001474:	2200      	movs	r2, #0
 8001476:	6881      	ldr	r1, [r0, #8]
  cp = (thread_t *)&ch.rlist.r_queue;
 8001478:	4b07      	ldr	r3, [pc, #28]	; (8001498 <chSchReadyI+0x28>)
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
 800147a:	7402      	strb	r2, [r0, #16]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
 800147c:	681b      	ldr	r3, [r3, #0]
  } while (cp->p_prio >= tp->p_prio);
 800147e:	689a      	ldr	r2, [r3, #8]
 8001480:	428a      	cmp	r2, r1
 8001482:	d2fb      	bcs.n	800147c <chSchReadyI+0xc>
  /* Insertion on p_prev.*/
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 8001484:	685a      	ldr	r2, [r3, #4]
  tp->p_prev->p_next = tp;
  cp->p_prev = tp;

  return tp;
}
 8001486:	4620      	mov	r0, r4
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio >= tp->p_prio);
  /* Insertion on p_prev.*/
  tp->p_next = cp;
 8001488:	6023      	str	r3, [r4, #0]
  tp->p_prev = cp->p_prev;
 800148a:	6062      	str	r2, [r4, #4]
  tp->p_prev->p_next = tp;
 800148c:	6014      	str	r4, [r2, #0]
  cp->p_prev = tp;
 800148e:	605c      	str	r4, [r3, #4]

  return tp;
}
 8001490:	f85d 4b04 	ldr.w	r4, [sp], #4
 8001494:	4770      	bx	lr
 8001496:	bf00      	nop
 8001498:	200008f0 	.word	0x200008f0
 800149c:	00000000 	.word	0x00000000

080014a0 <chSchGoSleepS>:
void chSchGoSleepS(tstate_t newstate) {
  thread_t *otp;

  chDbgCheckClassS();

  otp = currp;
 80014a0:	4b07      	ldr	r3, [pc, #28]	; (80014c0 <chSchGoSleepS+0x20>)
 *
 * @param[in] newstate  the new thread state
 *
 * @sclass
 */
void chSchGoSleepS(tstate_t newstate) {
 80014a2:	b430      	push	{r4, r5}
  tp->p_prev->p_next = tp;
  tqp->p_prev = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;
 80014a4:	681a      	ldr	r2, [r3, #0]
  thread_t *otp;

  chDbgCheckClassS();

  otp = currp;
 80014a6:	6919      	ldr	r1, [r3, #16]

  tqp->p_next = tp->p_next;
 80014a8:	6814      	ldr	r4, [r2, #0]
#if defined(CH_CFG_IDLE_ENTER_HOOK)
  if (currp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
 80014aa:	2501      	movs	r5, #1
  thread_t *otp;

  chDbgCheckClassS();

  otp = currp;
  otp->p_state = newstate;
 80014ac:	7408      	strb	r0, [r1, #16]
  tqp->p_next->p_prev = (thread_t *)tqp;
 80014ae:	6063      	str	r3, [r4, #4]
#if CH_CFG_TIME_QUANTUM > 0
  /* The thread is renouncing its remaining time slices so it will have a new
     time quantum when it will wakeup.*/
  otp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
  setcurrp(queue_fifo_remove(&ch.rlist.r_queue));
 80014b0:	611a      	str	r2, [r3, #16]
#if defined(CH_CFG_IDLE_ENTER_HOOK)
  if (currp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
 80014b2:	7415      	strb	r5, [r2, #16]
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  tqp->p_next = tp->p_next;
 80014b4:	601c      	str	r4, [r3, #0]
  chSysSwitch(currp, otp);
 80014b6:	4610      	mov	r0, r2
}
 80014b8:	bc30      	pop	{r4, r5}
  if (currp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
  chSysSwitch(currp, otp);
 80014ba:	f7fe beb9 	b.w	8000230 <_port_switch>
 80014be:	bf00      	nop
 80014c0:	200008f0 	.word	0x200008f0
	...

080014d0 <chSchGoSleepTimeoutS>:
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t time) {

  chDbgCheckClassS();

  if (TIME_INFINITE != time) {
 80014d0:	f64f 73ff 	movw	r3, #65535	; 0xffff
 * @return              The wakeup message.
 * @retval MSG_TIMEOUT  if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t time) {
 80014d4:	b530      	push	{r4, r5, lr}

  chDbgCheckClassS();

  if (TIME_INFINITE != time) {
 80014d6:	4299      	cmp	r1, r3
 * @return              The wakeup message.
 * @retval MSG_TIMEOUT  if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t time) {
 80014d8:	b087      	sub	sp, #28

  chDbgCheckClassS();

  if (TIME_INFINITE != time) {
 80014da:	d012      	beq.n	8001502 <chSchGoSleepTimeoutS+0x32>
 80014dc:	4605      	mov	r5, r0
    virtual_timer_t vt;

    chVTDoSetI(&vt, time, wakeup, currp);
 80014de:	4c0c      	ldr	r4, [pc, #48]	; (8001510 <chSchGoSleepTimeoutS+0x40>)
 80014e0:	a801      	add	r0, sp, #4
 80014e2:	6923      	ldr	r3, [r4, #16]
 80014e4:	4a0b      	ldr	r2, [pc, #44]	; (8001514 <chSchGoSleepTimeoutS+0x44>)
 80014e6:	f7ff ff4b 	bl	8001380 <chVTDoSetI>
    chSchGoSleepS(newstate);
 80014ea:	4628      	mov	r0, r5
 80014ec:	f7ff ffd8 	bl	80014a0 <chSchGoSleepS>
    if (chVTIsArmedI(&vt)) {
 80014f0:	9b04      	ldr	r3, [sp, #16]
 80014f2:	b113      	cbz	r3, 80014fa <chSchGoSleepTimeoutS+0x2a>
      chVTDoResetI(&vt);
 80014f4:	a801      	add	r0, sp, #4
 80014f6:	f7ff ff63 	bl	80013c0 <chVTDoResetI>
  }
  else {
    chSchGoSleepS(newstate);
  }

  return currp->p_u.rdymsg;
 80014fa:	6923      	ldr	r3, [r4, #16]
}
 80014fc:	6958      	ldr	r0, [r3, #20]
 80014fe:	b007      	add	sp, #28
 8001500:	bd30      	pop	{r4, r5, pc}
    if (chVTIsArmedI(&vt)) {
      chVTDoResetI(&vt);
    }
  }
  else {
    chSchGoSleepS(newstate);
 8001502:	f7ff ffcd 	bl	80014a0 <chSchGoSleepS>
 8001506:	4c02      	ldr	r4, [pc, #8]	; (8001510 <chSchGoSleepTimeoutS+0x40>)
  }

  return currp->p_u.rdymsg;
 8001508:	6923      	ldr	r3, [r4, #16]
}
 800150a:	6958      	ldr	r0, [r3, #20]
 800150c:	b007      	add	sp, #28
 800150e:	bd30      	pop	{r4, r5, pc}
 8001510:	200008f0 	.word	0x200008f0
 8001514:	080013f1 	.word	0x080013f1
	...

08001520 <chSchWakeupS>:

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio) {
 8001520:	4b14      	ldr	r3, [pc, #80]	; (8001574 <chSchWakeupS+0x54>)
 * @param[in] ntp       the thread to be made ready
 * @param[in] msg       the wakeup message
 *
 * @sclass
 */
void chSchWakeupS(thread_t *ntp, msg_t msg) {
 8001522:	b470      	push	{r4, r5, r6}

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio) {
 8001524:	691e      	ldr	r6, [r3, #16]
 8001526:	6884      	ldr	r4, [r0, #8]
 * @param[in] ntp       the thread to be made ready
 * @param[in] msg       the wakeup message
 *
 * @sclass
 */
void chSchWakeupS(thread_t *ntp, msg_t msg) {
 8001528:	4605      	mov	r5, r0
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  /* Storing the message to be retrieved by the target thread when it will
     restart execution.*/
  ntp->p_u.rdymsg = msg;
 800152a:	6141      	str	r1, [r0, #20]

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio) {
 800152c:	68b0      	ldr	r0, [r6, #8]
 800152e:	4284      	cmp	r4, r0
 8001530:	d80c      	bhi.n	800154c <chSchWakeupS+0x2c>
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
 8001532:	2200      	movs	r2, #0
 8001534:	742a      	strb	r2, [r5, #16]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
 8001536:	681b      	ldr	r3, [r3, #0]
  } while (cp->p_prio >= tp->p_prio);
 8001538:	689a      	ldr	r2, [r3, #8]
 800153a:	4294      	cmp	r4, r2
 800153c:	d9fb      	bls.n	8001536 <chSchWakeupS+0x16>
  /* Insertion on p_prev.*/
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 800153e:	685a      	ldr	r2, [r3, #4]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio >= tp->p_prio);
  /* Insertion on p_prev.*/
  tp->p_next = cp;
 8001540:	602b      	str	r3, [r5, #0]
  tp->p_prev = cp->p_prev;
 8001542:	606a      	str	r2, [r5, #4]
  tp->p_prev->p_next = tp;
 8001544:	6015      	str	r5, [r2, #0]
  cp->p_prev = tp;
 8001546:	605d      	str	r5, [r3, #4]
    }
#endif
    ntp->p_state = CH_STATE_CURRENT;
    chSysSwitch(ntp, otp);
  }
}
 8001548:	bc70      	pop	{r4, r5, r6}
 800154a:	4770      	bx	lr
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
  cp = (thread_t *)&ch.rlist.r_queue;
 800154c:	461a      	mov	r2, r3
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
 800154e:	2100      	movs	r1, #0
 8001550:	7431      	strb	r1, [r6, #16]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
 8001552:	6812      	ldr	r2, [r2, #0]
  } while (cp->p_prio >= tp->p_prio);
 8001554:	6891      	ldr	r1, [r2, #8]
 8001556:	4288      	cmp	r0, r1
 8001558:	d9fb      	bls.n	8001552 <chSchWakeupS+0x32>
  /* Insertion on p_prev.*/
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 800155a:	6850      	ldr	r0, [r2, #4]
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
    if (otp->p_prio == IDLEPRIO) {
      CH_CFG_IDLE_LEAVE_HOOK();
    }
#endif
    ntp->p_state = CH_STATE_CURRENT;
 800155c:	2401      	movs	r4, #1
  do {
    cp = cp->p_next;
  } while (cp->p_prio >= tp->p_prio);
  /* Insertion on p_prev.*/
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 800155e:	6070      	str	r0, [r6, #4]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio >= tp->p_prio);
  /* Insertion on p_prev.*/
  tp->p_next = cp;
 8001560:	6032      	str	r2, [r6, #0]
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = tp;
 8001562:	6006      	str	r6, [r0, #0]
  cp->p_prev = tp;
 8001564:	6056      	str	r6, [r2, #4]
  if (ntp->p_prio <= currp->p_prio) {
    (void) chSchReadyI(ntp);
  }
  else {
    thread_t *otp = chSchReadyI(currp);
    setcurrp(ntp);
 8001566:	611d      	str	r5, [r3, #16]
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
    if (otp->p_prio == IDLEPRIO) {
      CH_CFG_IDLE_LEAVE_HOOK();
    }
#endif
    ntp->p_state = CH_STATE_CURRENT;
 8001568:	742c      	strb	r4, [r5, #16]
    chSysSwitch(ntp, otp);
 800156a:	4631      	mov	r1, r6
 800156c:	4628      	mov	r0, r5
  }
}
 800156e:	bc70      	pop	{r4, r5, r6}
    if (otp->p_prio == IDLEPRIO) {
      CH_CFG_IDLE_LEAVE_HOOK();
    }
#endif
    ntp->p_state = CH_STATE_CURRENT;
    chSysSwitch(ntp, otp);
 8001570:	f7fe be5e 	b.w	8000230 <_port_switch>
 8001574:	200008f0 	.word	0x200008f0
	...

08001580 <chSchIsPreemptionRequired>:
 * @retval false        if preemption is not required.
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {
  tprio_t p1 = firstprio(&ch.rlist.r_queue);
 8001580:	4b04      	ldr	r3, [pc, #16]	; (8001594 <chSchIsPreemptionRequired+0x14>)
 8001582:	681a      	ldr	r2, [r3, #0]
  tprio_t p2 = currp->p_prio;
 8001584:	691b      	ldr	r3, [r3, #16]
     if the first thread on the ready queue has equal or higher priority.*/
  return (currp->p_preempt > (tslices_t)0) ? (p1 > p2) : (p1 >= p2);
#else
  /* If the round robin preemption feature is not enabled then performs a
     simpler comparison.*/
  return p1 > p2;
 8001586:	6890      	ldr	r0, [r2, #8]
 8001588:	689b      	ldr	r3, [r3, #8]
#endif
}
 800158a:	4298      	cmp	r0, r3
 800158c:	bf94      	ite	ls
 800158e:	2000      	movls	r0, #0
 8001590:	2001      	movhi	r0, #1
 8001592:	4770      	bx	lr
 8001594:	200008f0 	.word	0x200008f0
	...

080015a0 <chSchDoRescheduleAhead>:
 * @special
 */
void chSchDoRescheduleAhead(void) {
  thread_t *otp, *cp;

  otp = currp;
 80015a0:	4a0d      	ldr	r2, [pc, #52]	; (80015d8 <chSchDoRescheduleAhead+0x38>)
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoRescheduleAhead(void) {
 80015a2:	b4f0      	push	{r4, r5, r6, r7}
  tp->p_prev->p_next = tp;
  tqp->p_prev = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;
 80015a4:	6810      	ldr	r0, [r2, #0]
  thread_t *otp, *cp;

  otp = currp;
 80015a6:	6914      	ldr	r4, [r2, #16]

  tqp->p_next = tp->p_next;
 80015a8:	6805      	ldr	r5, [r0, #0]
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
  if (otp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
 80015aa:	2701      	movs	r7, #1

  otp->p_state = CH_STATE_READY;
 80015ac:	2600      	movs	r6, #0
 80015ae:	68a1      	ldr	r1, [r4, #8]
 80015b0:	462b      	mov	r3, r5
  tqp->p_next->p_prev = (thread_t *)tqp;
 80015b2:	606a      	str	r2, [r5, #4]
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  tqp->p_next = tp->p_next;
 80015b4:	6015      	str	r5, [r2, #0]
void chSchDoRescheduleAhead(void) {
  thread_t *otp, *cp;

  otp = currp;
  /* Picks the first thread from the ready queue and makes it current.*/
  setcurrp(queue_fifo_remove(&ch.rlist.r_queue));
 80015b6:	6110      	str	r0, [r2, #16]
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
  if (otp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
 80015b8:	7407      	strb	r7, [r0, #16]

  otp->p_state = CH_STATE_READY;
 80015ba:	7426      	strb	r6, [r4, #16]
 80015bc:	e000      	b.n	80015c0 <chSchDoRescheduleAhead+0x20>
 80015be:	681b      	ldr	r3, [r3, #0]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio > otp->p_prio);
 80015c0:	689a      	ldr	r2, [r3, #8]
 80015c2:	428a      	cmp	r2, r1
 80015c4:	d8fb      	bhi.n	80015be <chSchDoRescheduleAhead+0x1e>
  /* Insertion on p_prev.*/
  otp->p_next = cp;
  otp->p_prev = cp->p_prev;
 80015c6:	685a      	ldr	r2, [r3, #4]
  otp->p_prev->p_next = otp;
  cp->p_prev = otp;

  chSysSwitch(currp, otp);
 80015c8:	4621      	mov	r1, r4
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio > otp->p_prio);
  /* Insertion on p_prev.*/
  otp->p_next = cp;
 80015ca:	6023      	str	r3, [r4, #0]
  otp->p_prev = cp->p_prev;
 80015cc:	6062      	str	r2, [r4, #4]
  otp->p_prev->p_next = otp;
 80015ce:	6014      	str	r4, [r2, #0]
  cp->p_prev = otp;
 80015d0:	605c      	str	r4, [r3, #4]

  chSysSwitch(currp, otp);
}
 80015d2:	bcf0      	pop	{r4, r5, r6, r7}
  otp->p_next = cp;
  otp->p_prev = cp->p_prev;
  otp->p_prev->p_next = otp;
  cp->p_prev = otp;

  chSysSwitch(currp, otp);
 80015d4:	f7fe be2c 	b.w	8000230 <_port_switch>
 80015d8:	200008f0 	.word	0x200008f0
 80015dc:	00000000 	.word	0x00000000

080015e0 <chSchDoReschedule>:
    chSchDoRescheduleAhead();
  }
#else /* !(CH_CFG_TIME_QUANTUM > 0) */
  /* If the round-robin mechanism is disabled then the thread goes always
     ahead of its peers.*/
  chSchDoRescheduleAhead();
 80015e0:	f7ff bfde 	b.w	80015a0 <chSchDoRescheduleAhead>
	...

080015f0 <_thread_init>:
 * @param[in] prio      the priority level for the new thread
 * @return              The same thread pointer passed as parameter.
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {
 80015f0:	b4f0      	push	{r4, r5, r6, r7}
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  list_init(&tp->p_waiting);
#endif
#if CH_CFG_USE_MESSAGES == TRUE
  queue_init(&tp->p_msgqueue);
 80015f2:	f100 041c 	add.w	r4, r0, #28
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
  tp->p_flags = CH_FLAG_MODE_STATIC;
 80015f6:	2200      	movs	r2, #0
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
 80015f8:	2702      	movs	r7, #2
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->p_time = (systime_t)0;
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
 80015fa:	2601      	movs	r6, #1
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  list_init(&tp->p_waiting);
 80015fc:	f100 0518 	add.w	r5, r0, #24
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
 8001600:	7407      	strb	r7, [r0, #16]
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->p_time = (systime_t)0;
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
 8001602:	7486      	strb	r6, [r0, #18]
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {

  tlp->p_next = (thread_t *)tlp;
 8001604:	6185      	str	r5, [r0, #24]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8001606:	61c4      	str	r4, [r0, #28]
  tqp->p_prev = (thread_t *)tqp;
 8001608:	6204      	str	r4, [r0, #32]
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
 800160a:	6081      	str	r1, [r0, #8]
  tp->p_flags = CH_FLAG_MODE_STATIC;
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->p_realprio = prio;
 800160c:	6301      	str	r1, [r0, #48]	; 0x30
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
  tp->p_flags = CH_FLAG_MODE_STATIC;
 800160e:	7442      	strb	r2, [r0, #17]
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->p_realprio = prio;
  tp->p_mtxlist = NULL;
 8001610:	62c2      	str	r2, [r0, #44]	; 0x2c
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->p_epending = (eventmask_t)0;
 8001612:	6282      	str	r2, [r0, #40]	; 0x28
#endif
#if defined(CH_CFG_THREAD_INIT_HOOK)
  CH_CFG_THREAD_INIT_HOOK(tp);
#endif
  return tp;
}
 8001614:	bcf0      	pop	{r4, r5, r6, r7}
 8001616:	4770      	bx	lr
	...

08001620 <chThdCreateStatic>:
 *                      the thread into the working space area.
 *
 * @api
 */
thread_t *chThdCreateStatic(void *wsp, size_t size,
                            tprio_t prio, tfunc_t pf, void *arg) {
 8001620:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8001624:	469a      	mov	sl, r3
 8001626:	4604      	mov	r4, r0
 8001628:	2320      	movs	r3, #32
 800162a:	f383 8811 	msr	BASEPRI, r3

  chDbgCheckClassI();
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 800162e:	f8df 9050 	ldr.w	r9, [pc, #80]	; 8001680 <chThdCreateStatic+0x60>
 8001632:	3924      	subs	r1, #36	; 0x24
 8001634:	9f08      	ldr	r7, [sp, #32]
 8001636:	1846      	adds	r6, r0, r1
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
  tp->p_flags = CH_FLAG_MODE_STATIC;
 8001638:	2500      	movs	r5, #0
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  list_init(&tp->p_waiting);
#endif
#if CH_CFG_USE_MESSAGES == TRUE
  queue_init(&tp->p_msgqueue);
 800163a:	f100 031c 	add.w	r3, r0, #28
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->p_time = (systime_t)0;
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
 800163e:	f04f 0c01 	mov.w	ip, #1
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  list_init(&tp->p_waiting);
 8001642:	f100 0e18 	add.w	lr, r0, #24
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
 8001646:	f04f 0802 	mov.w	r8, #2

  chDbgCheckClassI();
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 800164a:	60c6      	str	r6, [r0, #12]
 800164c:	f840 a001 	str.w	sl, [r0, r1]
 8001650:	6077      	str	r7, [r6, #4]
 8001652:	f8c6 9020 	str.w	r9, [r6, #32]
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
  tp = chThdCreateI(wsp, size, prio, pf, arg);
  chSchWakeupS(tp, MSG_OK);
 8001656:	4629      	mov	r1, r5
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
 8001658:	6082      	str	r2, [r0, #8]
  tp->p_flags = CH_FLAG_MODE_STATIC;
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->p_realprio = prio;
 800165a:	6302      	str	r2, [r0, #48]	; 0x30
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
 800165c:	f880 8010 	strb.w	r8, [r0, #16]
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->p_time = (systime_t)0;
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
 8001660:	f880 c012 	strb.w	ip, [r0, #18]
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {

  tlp->p_next = (thread_t *)tlp;
 8001664:	f8c0 e018 	str.w	lr, [r0, #24]
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
  tp->p_flags = CH_FLAG_MODE_STATIC;
 8001668:	7445      	strb	r5, [r0, #17]
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->p_realprio = prio;
  tp->p_mtxlist = NULL;
 800166a:	62c5      	str	r5, [r0, #44]	; 0x2c
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->p_epending = (eventmask_t)0;
 800166c:	6285      	str	r5, [r0, #40]	; 0x28
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 800166e:	61c3      	str	r3, [r0, #28]
  tqp->p_prev = (thread_t *)tqp;
 8001670:	6203      	str	r3, [r0, #32]
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
  tp = chThdCreateI(wsp, size, prio, pf, arg);
  chSchWakeupS(tp, MSG_OK);
 8001672:	f7ff ff55 	bl	8001520 <chSchWakeupS>
 8001676:	f385 8811 	msr	BASEPRI, r5
  chSysUnlock();

  return tp;
}
 800167a:	4620      	mov	r0, r4
 800167c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8001680:	08000241 	.word	0x08000241
	...

08001690 <chThdSleep>:
 *                      - @a TIME_IMMEDIATE this value is not allowed.
 *                      .
 *
 * @api
 */
void chThdSleep(systime_t time) {
 8001690:	b508      	push	{r3, lr}
 8001692:	4601      	mov	r1, r0
 8001694:	2320      	movs	r3, #32
 8001696:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chThdSleepS(systime_t time) {

  chDbgCheck(time != TIME_IMMEDIATE);

  (void) chSchGoSleepTimeoutS(CH_STATE_SLEEPING, time);
 800169a:	2008      	movs	r0, #8
 800169c:	f7ff ff18 	bl	80014d0 <chSchGoSleepTimeoutS>
 80016a0:	2300      	movs	r3, #0
 80016a2:	f383 8811 	msr	BASEPRI, r3
 80016a6:	bd08      	pop	{r3, pc}
	...

080016b0 <chThdExitS>:
 *
 * @param[in] msg       thread exit code
 *
 * @sclass
 */
void chThdExitS(msg_t msg) {
 80016b0:	b538      	push	{r3, r4, r5, lr}
  thread_t *tp = currp;
 80016b2:	4b0a      	ldr	r3, [pc, #40]	; (80016dc <chThdExitS+0x2c>)
 80016b4:	691c      	ldr	r4, [r3, #16]
 *
 * @notapi
 */
static inline bool list_notempty(threads_list_t *tlp) {

  return (bool)(tlp->p_next != (thread_t *)tlp);
 80016b6:	69a3      	ldr	r3, [r4, #24]
  tp->p_u.exitcode = msg;
#if defined(CH_CFG_THREAD_EXIT_HOOK)
  CH_CFG_THREAD_EXIT_HOOK(tp);
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  while (list_notempty(&tp->p_waiting)) {
 80016b8:	f104 0518 	add.w	r5, r4, #24
 80016bc:	429d      	cmp	r5, r3
 * @sclass
 */
void chThdExitS(msg_t msg) {
  thread_t *tp = currp;

  tp->p_u.exitcode = msg;
 80016be:	6160      	str	r0, [r4, #20]
#if defined(CH_CFG_THREAD_EXIT_HOOK)
  CH_CFG_THREAD_EXIT_HOOK(tp);
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  while (list_notempty(&tp->p_waiting)) {
 80016c0:	d007      	beq.n	80016d2 <chThdExitS+0x22>
}

static inline thread_t *list_remove(threads_list_t *tlp) {

  thread_t *tp = tlp->p_next;
  tlp->p_next = tp->p_next;
 80016c2:	681a      	ldr	r2, [r3, #0]
    (void) chSchReadyI(list_remove(&tp->p_waiting));
 80016c4:	4618      	mov	r0, r3
 80016c6:	61a2      	str	r2, [r4, #24]
 80016c8:	f7ff fed2 	bl	8001470 <chSchReadyI>
 *
 * @notapi
 */
static inline bool list_notempty(threads_list_t *tlp) {

  return (bool)(tlp->p_next != (thread_t *)tlp);
 80016cc:	69a3      	ldr	r3, [r4, #24]
  tp->p_u.exitcode = msg;
#if defined(CH_CFG_THREAD_EXIT_HOOK)
  CH_CFG_THREAD_EXIT_HOOK(tp);
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  while (list_notempty(&tp->p_waiting)) {
 80016ce:	42ab      	cmp	r3, r5
 80016d0:	d1f7      	bne.n	80016c2 <chThdExitS+0x12>
     there is no memory to recover.*/
  if ((tp->p_flags & CH_FLAG_MODE_MASK) == CH_FLAG_MODE_STATIC) {
    REG_REMOVE(tp);
  }
#endif
  chSchGoSleepS(CH_STATE_FINAL);
 80016d2:	200f      	movs	r0, #15

  /* The thread never returns here.*/
  chDbgAssert(false, "zombies apocalypse");
}
 80016d4:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
     there is no memory to recover.*/
  if ((tp->p_flags & CH_FLAG_MODE_MASK) == CH_FLAG_MODE_STATIC) {
    REG_REMOVE(tp);
  }
#endif
  chSchGoSleepS(CH_STATE_FINAL);
 80016d8:	f7ff bee2 	b.w	80014a0 <chSchGoSleepS>
 80016dc:	200008f0 	.word	0x200008f0

080016e0 <chThdExit>:
 80016e0:	2320      	movs	r3, #32
 80016e2:	f383 8811 	msr	BASEPRI, r3
 * @api
 */
void chThdExit(msg_t msg) {

  chSysLock();
  chThdExitS(msg);
 80016e6:	f7ff bfe3 	b.w	80016b0 <chThdExitS>
 80016ea:	bf00      	nop
 80016ec:	0000      	movs	r0, r0
	...

080016f0 <chThdResumeI>:
 *
 * @iclass
 */
void chThdResumeI(thread_reference_t *trp, msg_t msg) {

  if (*trp != NULL) {
 80016f0:	6803      	ldr	r3, [r0, #0]
 80016f2:	b12b      	cbz	r3, 8001700 <chThdResumeI+0x10>
    thread_t *tp = *trp;

    chDbgAssert(tp->p_state == CH_STATE_SUSPENDED,
                "not THD_STATE_SUSPENDED");

    *trp = NULL;
 80016f4:	2200      	movs	r2, #0
 80016f6:	6002      	str	r2, [r0, #0]
    tp->p_u.rdymsg = msg;
    (void) chSchReadyI(tp);
 80016f8:	4618      	mov	r0, r3

    chDbgAssert(tp->p_state == CH_STATE_SUSPENDED,
                "not THD_STATE_SUSPENDED");

    *trp = NULL;
    tp->p_u.rdymsg = msg;
 80016fa:	6159      	str	r1, [r3, #20]
    (void) chSchReadyI(tp);
 80016fc:	f7ff beb8 	b.w	8001470 <chSchReadyI>
 8001700:	4770      	bx	lr
 8001702:	bf00      	nop
	...

08001710 <chThdEnqueueTimeoutS>:
 *
 * @sclass
 */
msg_t chThdEnqueueTimeoutS(threads_queue_t *tqp, systime_t timeout) {

  if (TIME_IMMEDIATE == timeout) {
 8001710:	b169      	cbz	r1, 800172e <chThdEnqueueTimeoutS+0x1e>
 8001712:	4602      	mov	r2, r0
    return MSG_TIMEOUT;
  }

  queue_insert(currp, tqp);
 8001714:	4b07      	ldr	r3, [pc, #28]	; (8001734 <chThdEnqueueTimeoutS+0x24>)
 *                      invoked with @p TIME_IMMEDIATE as timeout
 *                      specification.
 *
 * @sclass
 */
msg_t chThdEnqueueTimeoutS(threads_queue_t *tqp, systime_t timeout) {
 8001716:	b410      	push	{r4}

  if (TIME_IMMEDIATE == timeout) {
    return MSG_TIMEOUT;
  }

  queue_insert(currp, tqp);
 8001718:	691b      	ldr	r3, [r3, #16]
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {

  tp->p_next = (thread_t *)tqp;
  tp->p_prev = tqp->p_prev;
 800171a:	6844      	ldr	r4, [r0, #4]

  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
 800171c:	2004      	movs	r0, #4
 800171e:	e883 0014 	stmia.w	r3, {r2, r4}
  tp->p_prev->p_next = tp;
 8001722:	6023      	str	r3, [r4, #0]
  tqp->p_prev = tp;
 8001724:	6053      	str	r3, [r2, #4]
}
 8001726:	f85d 4b04 	ldr.w	r4, [sp], #4
    return MSG_TIMEOUT;
  }

  queue_insert(currp, tqp);

  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
 800172a:	f7ff bed1 	b.w	80014d0 <chSchGoSleepTimeoutS>
}
 800172e:	f04f 30ff 	mov.w	r0, #4294967295
 8001732:	4770      	bx	lr
 8001734:	200008f0 	.word	0x200008f0
	...

08001740 <chThdDequeueNextI>:
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->p_next != (const thread_t *)tqp);
 8001740:	6802      	ldr	r2, [r0, #0]
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdDequeueNextI(threads_queue_t *tqp, msg_t msg) {
 8001742:	4603      	mov	r3, r0

  if (queue_notempty(tqp)) {
 8001744:	4290      	cmp	r0, r2
 8001746:	d009      	beq.n	800175c <chThdDequeueNextI+0x1c>
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdDequeueNextI(threads_queue_t *tqp, msg_t msg) {
 8001748:	b410      	push	{r4}
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  tqp->p_next = tp->p_next;
 800174a:	6814      	ldr	r4, [r2, #0]
  tp = queue_fifo_remove(tqp);

  chDbgAssert(tp->p_state == CH_STATE_QUEUED, "invalid state");

  tp->p_u.rdymsg = msg;
  (void) chSchReadyI(tp);
 800174c:	4610      	mov	r0, r2
 800174e:	601c      	str	r4, [r3, #0]
  tqp->p_next->p_prev = (thread_t *)tqp;
 8001750:	6063      	str	r3, [r4, #4]

  tp = queue_fifo_remove(tqp);

  chDbgAssert(tp->p_state == CH_STATE_QUEUED, "invalid state");

  tp->p_u.rdymsg = msg;
 8001752:	6151      	str	r1, [r2, #20]

  if (queue_notempty(tqp)) {
    chThdDoDequeueNextI(tqp, msg);
  }
}
 8001754:	f85d 4b04 	ldr.w	r4, [sp], #4
  (void) chSchReadyI(tp);
 8001758:	f7ff be8a 	b.w	8001470 <chSchReadyI>
 800175c:	4770      	bx	lr
 800175e:	bf00      	nop

08001760 <chTMStartMeasurementX>:
 *
 * @return              The realtime counter value.
 */
static inline rtcnt_t port_rt_get_counter_value(void) {

  return DWT->CYCCNT;
 8001760:	4b01      	ldr	r3, [pc, #4]	; (8001768 <chTMStartMeasurementX+0x8>)
 8001762:	685b      	ldr	r3, [r3, #4]
 *
 * @xclass
 */
NOINLINE void chTMStartMeasurementX(time_measurement_t *tmp) {

  tmp->last = chSysGetRealtimeCounterX();
 8001764:	6083      	str	r3, [r0, #8]
 8001766:	4770      	bx	lr
 8001768:	e0001000 	.word	0xe0001000
 800176c:	00000000 	.word	0x00000000

08001770 <chTMStopMeasurementX>:
 8001770:	4b0e      	ldr	r3, [pc, #56]	; (80017ac <chTMStopMeasurementX+0x3c>)
 *
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch.tm.offset);
 8001772:	490f      	ldr	r1, [pc, #60]	; (80017b0 <chTMStopMeasurementX+0x40>)
 8001774:	685a      	ldr	r2, [r3, #4]
static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
  tmp->last = (now - tmp->last) - offset;
 8001776:	6883      	ldr	r3, [r0, #8]
 *
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch.tm.offset);
 8001778:	6dc9      	ldr	r1, [r1, #92]	; 0x5c
static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
  tmp->last = (now - tmp->last) - offset;
 800177a:	1ad3      	subs	r3, r2, r3

static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
 800177c:	68c2      	ldr	r2, [r0, #12]
 *
 * @param[in,out] tmp   pointer to a @p time_measurement_t structure
 *
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {
 800177e:	b430      	push	{r4, r5}
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
  tmp->last = (now - tmp->last) - offset;
  tmp->cumulative += (rttime_t)tmp->last;
 8001780:	e9d0 4504 	ldrd	r4, r5, [r0, #16]
static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
  tmp->last = (now - tmp->last) - offset;
 8001784:	1a5b      	subs	r3, r3, r1

static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
 8001786:	3201      	adds	r2, #1
  tmp->last = (now - tmp->last) - offset;
  tmp->cumulative += (rttime_t)tmp->last;
  if (tmp->last > tmp->worst) {
 8001788:	6841      	ldr	r1, [r0, #4]
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
  tmp->last = (now - tmp->last) - offset;
  tmp->cumulative += (rttime_t)tmp->last;
 800178a:	18e4      	adds	r4, r4, r3

static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
 800178c:	60c2      	str	r2, [r0, #12]
  tmp->last = (now - tmp->last) - offset;
  tmp->cumulative += (rttime_t)tmp->last;
  if (tmp->last > tmp->worst) {
    tmp->worst = tmp->last;
  }
  if (tmp->last < tmp->best) {
 800178e:	6802      	ldr	r2, [r0, #0]
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
  tmp->last = (now - tmp->last) - offset;
  tmp->cumulative += (rttime_t)tmp->last;
 8001790:	f145 0500 	adc.w	r5, r5, #0
  if (tmp->last > tmp->worst) {
 8001794:	428b      	cmp	r3, r1
    tmp->worst = tmp->last;
 8001796:	bf88      	it	hi
 8001798:	6043      	strhi	r3, [r0, #4]
  }
  if (tmp->last < tmp->best) {
 800179a:	4293      	cmp	r3, r2
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
  tmp->last = (now - tmp->last) - offset;
  tmp->cumulative += (rttime_t)tmp->last;
 800179c:	e9c0 4504 	strd	r4, r5, [r0, #16]
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch.tm.offset);
}
 80017a0:	bc30      	pop	{r4, r5}
static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
  tmp->last = (now - tmp->last) - offset;
 80017a2:	6083      	str	r3, [r0, #8]
  tmp->cumulative += (rttime_t)tmp->last;
  if (tmp->last > tmp->worst) {
    tmp->worst = tmp->last;
  }
  if (tmp->last < tmp->best) {
    tmp->best = tmp->last;
 80017a4:	bf38      	it	cc
 80017a6:	6003      	strcc	r3, [r0, #0]
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch.tm.offset);
}
 80017a8:	4770      	bx	lr
 80017aa:	bf00      	nop
 80017ac:	e0001000 	.word	0xe0001000
 80017b0:	200008f0 	.word	0x200008f0
	...

080017c0 <_tm_init>:
/**
 * @brief   Initializes the time measurement unit.
 *
 * @init
 */
void _tm_init(void) {
 80017c0:	b5d0      	push	{r4, r6, r7, lr}
  time_measurement_t tm;

  /* Time Measurement subsystem calibration, it does a null measurement
     and calculates the call overhead which is subtracted to real
     measurements.*/
  ch.tm.offset = (rtcnt_t)0;
 80017c2:	4c0c      	ldr	r4, [pc, #48]	; (80017f4 <_tm_init+0x34>)
/**
 * @brief   Initializes the time measurement unit.
 *
 * @init
 */
void _tm_init(void) {
 80017c4:	b086      	sub	sp, #24
  time_measurement_t tm;

  /* Time Measurement subsystem calibration, it does a null measurement
     and calculates the call overhead which is subtracted to real
     measurements.*/
  ch.tm.offset = (rtcnt_t)0;
 80017c6:	2300      	movs	r3, #0
 *
 * @init
 */
void chTMObjectInit(time_measurement_t *tmp) {

  tmp->best       = (rtcnt_t)-1;
 80017c8:	f04f 32ff 	mov.w	r2, #4294967295
  /* Time Measurement subsystem calibration, it does a null measurement
     and calculates the call overhead which is subtracted to real
     measurements.*/
  ch.tm.offset = (rtcnt_t)0;
  chTMObjectInit(&tm);
  chTMStartMeasurementX(&tm);
 80017cc:	4668      	mov	r0, sp

  tmp->best       = (rtcnt_t)-1;
  tmp->worst      = (rtcnt_t)0;
  tmp->last       = (rtcnt_t)0;
  tmp->n          = (ucnt_t)0;
  tmp->cumulative = (rttime_t)0;
 80017ce:	2600      	movs	r6, #0
 80017d0:	2700      	movs	r7, #0
  time_measurement_t tm;

  /* Time Measurement subsystem calibration, it does a null measurement
     and calculates the call overhead which is subtracted to real
     measurements.*/
  ch.tm.offset = (rtcnt_t)0;
 80017d2:	65e3      	str	r3, [r4, #92]	; 0x5c
 * @init
 */
void chTMObjectInit(time_measurement_t *tmp) {

  tmp->best       = (rtcnt_t)-1;
  tmp->worst      = (rtcnt_t)0;
 80017d4:	9301      	str	r3, [sp, #4]
  tmp->last       = (rtcnt_t)0;
 80017d6:	9302      	str	r3, [sp, #8]
  tmp->n          = (ucnt_t)0;
 80017d8:	9303      	str	r3, [sp, #12]
 *
 * @init
 */
void chTMObjectInit(time_measurement_t *tmp) {

  tmp->best       = (rtcnt_t)-1;
 80017da:	9200      	str	r2, [sp, #0]
  tmp->worst      = (rtcnt_t)0;
  tmp->last       = (rtcnt_t)0;
  tmp->n          = (ucnt_t)0;
  tmp->cumulative = (rttime_t)0;
 80017dc:	e9cd 6704 	strd	r6, r7, [sp, #16]
  /* Time Measurement subsystem calibration, it does a null measurement
     and calculates the call overhead which is subtracted to real
     measurements.*/
  ch.tm.offset = (rtcnt_t)0;
  chTMObjectInit(&tm);
  chTMStartMeasurementX(&tm);
 80017e0:	f7ff ffbe 	bl	8001760 <chTMStartMeasurementX>
  chTMStopMeasurementX(&tm);
 80017e4:	4668      	mov	r0, sp
 80017e6:	f7ff ffc3 	bl	8001770 <chTMStopMeasurementX>
  ch.tm.offset = tm.last;
 80017ea:	9b02      	ldr	r3, [sp, #8]
 80017ec:	65e3      	str	r3, [r4, #92]	; 0x5c
}
 80017ee:	b006      	add	sp, #24
 80017f0:	bdd0      	pop	{r4, r6, r7, pc}
 80017f2:	bf00      	nop
 80017f4:	200008f0 	.word	0x200008f0
	...

08001800 <chMtxObjectInit>:
void chMtxObjectInit(mutex_t *mp) {

  chDbgCheck(mp != NULL);

  queue_init(&mp->m_queue);
  mp->m_owner = NULL;
 8001800:	2300      	movs	r3, #0
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8001802:	6000      	str	r0, [r0, #0]
  tqp->p_prev = (thread_t *)tqp;
 8001804:	6040      	str	r0, [r0, #4]
 8001806:	6083      	str	r3, [r0, #8]
 8001808:	4770      	bx	lr
 800180a:	bf00      	nop
 800180c:	0000      	movs	r0, r0
	...

08001810 <chEvtSignalI>:
void chEvtSignalI(thread_t *tp, eventmask_t events) {

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->p_epending |= events;
 8001810:	6a83      	ldr	r3, [r0, #40]	; 0x28
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
 8001812:	7c02      	ldrb	r2, [r0, #16]
void chEvtSignalI(thread_t *tp, eventmask_t events) {

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->p_epending |= events;
 8001814:	4319      	orrs	r1, r3
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
 8001816:	2a0a      	cmp	r2, #10
void chEvtSignalI(thread_t *tp, eventmask_t events) {

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->p_epending |= events;
 8001818:	6281      	str	r1, [r0, #40]	; 0x28
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
 800181a:	d00a      	beq.n	8001832 <chEvtSignalI+0x22>
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
 800181c:	2a0b      	cmp	r2, #11
 800181e:	d000      	beq.n	8001822 <chEvtSignalI+0x12>
 8001820:	4770      	bx	lr
      ((tp->p_state == CH_STATE_WTANDEVT) &&
       ((tp->p_epending & tp->p_u.ewmask) == tp->p_u.ewmask))) {
 8001822:	6943      	ldr	r3, [r0, #20]
 8001824:	4019      	ands	r1, r3

  tp->p_epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
      ((tp->p_state == CH_STATE_WTANDEVT) &&
 8001826:	428b      	cmp	r3, r1
 8001828:	d1fa      	bne.n	8001820 <chEvtSignalI+0x10>
       ((tp->p_epending & tp->p_u.ewmask) == tp->p_u.ewmask))) {
    tp->p_u.rdymsg = MSG_OK;
 800182a:	2300      	movs	r3, #0
 800182c:	6143      	str	r3, [r0, #20]
    (void) chSchReadyI(tp);
 800182e:	f7ff be1f 	b.w	8001470 <chSchReadyI>
  chDbgCheck(tp != NULL);

  tp->p_epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
 8001832:	6943      	ldr	r3, [r0, #20]
  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->p_epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
 8001834:	4219      	tst	r1, r3
 8001836:	d1f8      	bne.n	800182a <chEvtSignalI+0x1a>
 8001838:	4770      	bx	lr
 800183a:	bf00      	nop
 800183c:	0000      	movs	r0, r0
	...

08001840 <chEvtBroadcastFlagsI>:
 * @param[in] esp       pointer to the @p event_source_t structure
 * @param[in] flags     the flags set to be added to the listener flags mask
 *
 * @iclass
 */
void chEvtBroadcastFlagsI(event_source_t *esp, eventflags_t flags) {
 8001840:	b570      	push	{r4, r5, r6, lr}
  event_listener_t *elp;

  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->es_next;
 8001842:	6804      	ldr	r4, [r0, #0]
 * @param[in] esp       pointer to the @p event_source_t structure
 * @param[in] flags     the flags set to be added to the listener flags mask
 *
 * @iclass
 */
void chEvtBroadcastFlagsI(event_source_t *esp, eventflags_t flags) {
 8001844:	4606      	mov	r6, r0
  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->es_next;
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
 8001846:	42a0      	cmp	r0, r4
 * @param[in] esp       pointer to the @p event_source_t structure
 * @param[in] flags     the flags set to be added to the listener flags mask
 *
 * @iclass
 */
void chEvtBroadcastFlagsI(event_source_t *esp, eventflags_t flags) {
 8001848:	460d      	mov	r5, r1
  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->es_next;
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
 800184a:	d00d      	beq.n	8001868 <chEvtBroadcastFlagsI+0x28>
  /*lint -restore*/
    elp->el_flags |= flags;
 800184c:	68e3      	ldr	r3, [r4, #12]
 800184e:	432b      	orrs	r3, r5
 8001850:	60e3      	str	r3, [r4, #12]
    /* When flags == 0 the thread will always be signaled because the
       source does not emit any flag.*/
    if ((flags == (eventflags_t)0) ||
 8001852:	b115      	cbz	r5, 800185a <chEvtBroadcastFlagsI+0x1a>
        ((elp->el_flags & elp->el_wflags) != (eventflags_t)0)) {
 8001854:	6922      	ldr	r2, [r4, #16]
  while (elp != (event_listener_t *)esp) {
  /*lint -restore*/
    elp->el_flags |= flags;
    /* When flags == 0 the thread will always be signaled because the
       source does not emit any flag.*/
    if ((flags == (eventflags_t)0) ||
 8001856:	4213      	tst	r3, r2
 8001858:	d003      	beq.n	8001862 <chEvtBroadcastFlagsI+0x22>
        ((elp->el_flags & elp->el_wflags) != (eventflags_t)0)) {
      chEvtSignalI(elp->el_listener, elp->el_events);
 800185a:	6860      	ldr	r0, [r4, #4]
 800185c:	68a1      	ldr	r1, [r4, #8]
 800185e:	f7ff ffd7 	bl	8001810 <chEvtSignalI>
    }
    elp = elp->el_next;
 8001862:	6824      	ldr	r4, [r4, #0]
  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->es_next;
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
 8001864:	42a6      	cmp	r6, r4
 8001866:	d1f1      	bne.n	800184c <chEvtBroadcastFlagsI+0xc>
 8001868:	bd70      	pop	{r4, r5, r6, pc}
 800186a:	bf00      	nop
 800186c:	0000      	movs	r0, r0
	...

08001870 <chIQObjectInit>:
 * @param[in] link      application defined pointer
 *
 * @init
 */
void chIQObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                    qnotify_t infy, void *link) {
 8001870:	b430      	push	{r4, r5}
 8001872:	9c02      	ldr	r4, [sp, #8]

  chThdQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
 8001874:	2500      	movs	r5, #0
  iqp->q_buffer  = bp;
  iqp->q_rdptr   = bp;
  iqp->q_wrptr   = bp;
  iqp->q_top     = bp + size;
 8001876:	440a      	add	r2, r1
 */
void chIQObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                    qnotify_t infy, void *link) {

  chThdQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
 8001878:	6085      	str	r5, [r0, #8]
  iqp->q_buffer  = bp;
  iqp->q_rdptr   = bp;
  iqp->q_wrptr   = bp;
  iqp->q_top     = bp + size;
  iqp->q_notify  = infy;
  iqp->q_link    = link;
 800187a:	6204      	str	r4, [r0, #32]
  chThdQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
  iqp->q_buffer  = bp;
  iqp->q_rdptr   = bp;
  iqp->q_wrptr   = bp;
  iqp->q_top     = bp + size;
 800187c:	6102      	str	r2, [r0, #16]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 800187e:	6000      	str	r0, [r0, #0]
  tqp->p_prev = (thread_t *)tqp;
 8001880:	6040      	str	r0, [r0, #4]
void chIQObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                    qnotify_t infy, void *link) {

  chThdQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
  iqp->q_buffer  = bp;
 8001882:	60c1      	str	r1, [r0, #12]
  iqp->q_rdptr   = bp;
 8001884:	6181      	str	r1, [r0, #24]
  iqp->q_wrptr   = bp;
 8001886:	6141      	str	r1, [r0, #20]
  iqp->q_top     = bp + size;
  iqp->q_notify  = infy;
 8001888:	61c3      	str	r3, [r0, #28]
  iqp->q_link    = link;
}
 800188a:	bc30      	pop	{r4, r5}
 800188c:	4770      	bx	lr
 800188e:	bf00      	nop

08001890 <chIQPutI>:
static inline bool chIQIsFullI(input_queue_t *iqp) {

  chDbgCheckClassI();

  /*lint -save -e9007 [13.5] No side effects.*/
  return (bool)((iqp->q_wrptr == iqp->q_rdptr) && (iqp->q_counter != 0U));
 8001890:	6943      	ldr	r3, [r0, #20]
 8001892:	6982      	ldr	r2, [r0, #24]
 * @retval Q_FULL       if the queue is full and the operation cannot be
 *                      completed.
 *
 * @iclass
 */
msg_t chIQPutI(input_queue_t *iqp, uint8_t b) {
 8001894:	b510      	push	{r4, lr}
 8001896:	4293      	cmp	r3, r2
 8001898:	d010      	beq.n	80018bc <chIQPutI+0x2c>

  if (chIQIsFullI(iqp)) {
    return Q_FULL;
  }

  iqp->q_counter++;
 800189a:	6882      	ldr	r2, [r0, #8]
  *iqp->q_wrptr++ = b;
 800189c:	1c5c      	adds	r4, r3, #1

  if (chIQIsFullI(iqp)) {
    return Q_FULL;
  }

  iqp->q_counter++;
 800189e:	3201      	adds	r2, #1
 80018a0:	6082      	str	r2, [r0, #8]
  *iqp->q_wrptr++ = b;
 80018a2:	6144      	str	r4, [r0, #20]
 80018a4:	7019      	strb	r1, [r3, #0]
  if (iqp->q_wrptr >= iqp->q_top) {
 80018a6:	6942      	ldr	r2, [r0, #20]
 80018a8:	6903      	ldr	r3, [r0, #16]
 80018aa:	429a      	cmp	r2, r3
 80018ac:	d301      	bcc.n	80018b2 <chIQPutI+0x22>
    iqp->q_wrptr = iqp->q_buffer;
 80018ae:	68c3      	ldr	r3, [r0, #12]
 80018b0:	6143      	str	r3, [r0, #20]
  }

  chThdDequeueNextI(&iqp->q_waiting, Q_OK);
 80018b2:	2100      	movs	r1, #0
 80018b4:	f7ff ff44 	bl	8001740 <chThdDequeueNextI>

  return Q_OK;
 80018b8:	2000      	movs	r0, #0
 80018ba:	bd10      	pop	{r4, pc}
 80018bc:	6882      	ldr	r2, [r0, #8]
 80018be:	2a00      	cmp	r2, #0
 80018c0:	d0eb      	beq.n	800189a <chIQPutI+0xa>
msg_t chIQPutI(input_queue_t *iqp, uint8_t b) {

  chDbgCheckClassI();

  if (chIQIsFullI(iqp)) {
    return Q_FULL;
 80018c2:	f06f 0003 	mvn.w	r0, #3
 80018c6:	bd10      	pop	{r4, pc}
	...

080018d0 <chIQGetTimeout>:
 * @retval Q_TIMEOUT    if the specified time expired.
 * @retval Q_RESET      if the queue has been reset.
 *
 * @api
 */
msg_t chIQGetTimeout(input_queue_t *iqp, systime_t timeout) {
 80018d0:	b570      	push	{r4, r5, r6, lr}
 80018d2:	2320      	movs	r3, #32
 80018d4:	460e      	mov	r6, r1
 80018d6:	4604      	mov	r4, r0
 80018d8:	f383 8811 	msr	BASEPRI, r3
  uint8_t b;

  chSysLock();
  if (iqp->q_notify != NULL) {
 80018dc:	69c3      	ldr	r3, [r0, #28]
 80018de:	b13b      	cbz	r3, 80018f0 <chIQGetTimeout+0x20>
    iqp->q_notify(iqp);
 80018e0:	4798      	blx	r3
 80018e2:	e005      	b.n	80018f0 <chIQGetTimeout+0x20>
  }

  while (chIQIsEmptyI(iqp)) {
    msg_t msg = chThdEnqueueTimeoutS(&iqp->q_waiting, timeout);
 80018e4:	4620      	mov	r0, r4
 80018e6:	4631      	mov	r1, r6
 80018e8:	f7ff ff12 	bl	8001710 <chThdEnqueueTimeoutS>
    if (msg < Q_OK) {
 80018ec:	2800      	cmp	r0, #0
 80018ee:	db13      	blt.n	8001918 <chIQGetTimeout+0x48>
 */
static inline bool chIQIsEmptyI(input_queue_t *iqp) {

  chDbgCheckClassI();

  return (bool)(chQSpaceI(iqp) == 0U);
 80018f0:	68a5      	ldr	r5, [r4, #8]
  chSysLock();
  if (iqp->q_notify != NULL) {
    iqp->q_notify(iqp);
  }

  while (chIQIsEmptyI(iqp)) {
 80018f2:	2d00      	cmp	r5, #0
 80018f4:	d0f6      	beq.n	80018e4 <chIQGetTimeout+0x14>
      return msg;
    }
  }

  iqp->q_counter--;
  b = *iqp->q_rdptr++;
 80018f6:	69a1      	ldr	r1, [r4, #24]
      chSysUnlock();
      return msg;
    }
  }

  iqp->q_counter--;
 80018f8:	68a3      	ldr	r3, [r4, #8]
  b = *iqp->q_rdptr++;
  if (iqp->q_rdptr >= iqp->q_top) {
 80018fa:	6925      	ldr	r5, [r4, #16]
      return msg;
    }
  }

  iqp->q_counter--;
  b = *iqp->q_rdptr++;
 80018fc:	1c4a      	adds	r2, r1, #1
      chSysUnlock();
      return msg;
    }
  }

  iqp->q_counter--;
 80018fe:	3b01      	subs	r3, #1
  b = *iqp->q_rdptr++;
  if (iqp->q_rdptr >= iqp->q_top) {
 8001900:	42aa      	cmp	r2, r5
      chSysUnlock();
      return msg;
    }
  }

  iqp->q_counter--;
 8001902:	60a3      	str	r3, [r4, #8]
  b = *iqp->q_rdptr++;
  if (iqp->q_rdptr >= iqp->q_top) {
    iqp->q_rdptr = iqp->q_buffer;
 8001904:	bf28      	it	cs
 8001906:	68e3      	ldrcs	r3, [r4, #12]
      return msg;
    }
  }

  iqp->q_counter--;
  b = *iqp->q_rdptr++;
 8001908:	61a2      	str	r2, [r4, #24]
 800190a:	7808      	ldrb	r0, [r1, #0]
  if (iqp->q_rdptr >= iqp->q_top) {
    iqp->q_rdptr = iqp->q_buffer;
 800190c:	bf28      	it	cs
 800190e:	61a3      	strcs	r3, [r4, #24]
 8001910:	2300      	movs	r3, #0
 8001912:	f383 8811 	msr	BASEPRI, r3
  }
  chSysUnlock();

  return (msg_t)b;
}
 8001916:	bd70      	pop	{r4, r5, r6, pc}
 8001918:	f385 8811 	msr	BASEPRI, r5

  while (chIQIsEmptyI(iqp)) {
    msg_t msg = chThdEnqueueTimeoutS(&iqp->q_waiting, timeout);
    if (msg < Q_OK) {
      chSysUnlock();
      return msg;
 800191c:	bd70      	pop	{r4, r5, r6, pc}
 800191e:	bf00      	nop

08001920 <chIQReadTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t chIQReadTimeout(input_queue_t *iqp, uint8_t *bp,
                       size_t n, systime_t timeout) {
 8001920:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8001924:	4604      	mov	r4, r0
 8001926:	b083      	sub	sp, #12
 8001928:	4689      	mov	r9, r1
 800192a:	4693      	mov	fp, r2
 800192c:	461d      	mov	r5, r3
  qnotify_t nfy = iqp->q_notify;
 800192e:	f8d0 801c 	ldr.w	r8, [r0, #28]
 8001932:	2720      	movs	r7, #32
 8001934:	f387 8811 	msr	BASEPRI, r7
  size_t r = 0;
 8001938:	2600      	movs	r6, #0
 800193a:	46b2      	mov	sl, r6
 800193c:	9701      	str	r7, [sp, #4]

  chDbgCheck(n > 0U);

  chSysLock();
  while (true) {
    if (nfy != NULL) {
 800193e:	f1b8 0f00 	cmp.w	r8, #0
 8001942:	d007      	beq.n	8001954 <chIQReadTimeout+0x34>
      nfy(iqp);
 8001944:	4620      	mov	r0, r4
 8001946:	47c0      	blx	r8
 8001948:	e004      	b.n	8001954 <chIQReadTimeout+0x34>
    }

    while (chIQIsEmptyI(iqp)) {
      if (chThdEnqueueTimeoutS(&iqp->q_waiting, timeout) != Q_OK) {
 800194a:	4620      	mov	r0, r4
 800194c:	4629      	mov	r1, r5
 800194e:	f7ff fedf 	bl	8001710 <chThdEnqueueTimeoutS>
 8001952:	b9d0      	cbnz	r0, 800198a <chIQReadTimeout+0x6a>
 8001954:	68a7      	ldr	r7, [r4, #8]
  while (true) {
    if (nfy != NULL) {
      nfy(iqp);
    }

    while (chIQIsEmptyI(iqp)) {
 8001956:	2f00      	cmp	r7, #0
 8001958:	d0f7      	beq.n	800194a <chIQReadTimeout+0x2a>
        return r;
      }
    }

    iqp->q_counter--;
    *bp++ = *iqp->q_rdptr++;
 800195a:	69a2      	ldr	r2, [r4, #24]
        chSysUnlock();
        return r;
      }
    }

    iqp->q_counter--;
 800195c:	68a3      	ldr	r3, [r4, #8]
    *bp++ = *iqp->q_rdptr++;
 800195e:	1c51      	adds	r1, r2, #1
        chSysUnlock();
        return r;
      }
    }

    iqp->q_counter--;
 8001960:	3b01      	subs	r3, #1
    *bp++ = *iqp->q_rdptr++;
 8001962:	61a1      	str	r1, [r4, #24]
        chSysUnlock();
        return r;
      }
    }

    iqp->q_counter--;
 8001964:	60a3      	str	r3, [r4, #8]
    *bp++ = *iqp->q_rdptr++;
 8001966:	7813      	ldrb	r3, [r2, #0]
 8001968:	f809 3b01 	strb.w	r3, [r9], #1
    if (iqp->q_rdptr >= iqp->q_top) {
 800196c:	6923      	ldr	r3, [r4, #16]
 800196e:	69a2      	ldr	r2, [r4, #24]
 8001970:	429a      	cmp	r2, r3
      iqp->q_rdptr = iqp->q_buffer;
 8001972:	bf24      	itt	cs
 8001974:	68e3      	ldrcs	r3, [r4, #12]
 8001976:	61a3      	strcs	r3, [r4, #24]
 8001978:	f38a 8811 	msr	BASEPRI, sl
    }
    chSysUnlock(); /* Gives a preemption chance in a controlled point.*/

    r++;
 800197c:	3601      	adds	r6, #1
    if (--n == 0U) {
 800197e:	45b3      	cmp	fp, r6
 8001980:	d005      	beq.n	800198e <chIQReadTimeout+0x6e>
 8001982:	9b01      	ldr	r3, [sp, #4]
 8001984:	f383 8811 	msr	BASEPRI, r3
 8001988:	e7d9      	b.n	800193e <chIQReadTimeout+0x1e>
 800198a:	f387 8811 	msr	BASEPRI, r7
      return r;
    }

    chSysLock();
  }
}
 800198e:	4630      	mov	r0, r6
 8001990:	b003      	add	sp, #12
 8001992:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8001996:	bf00      	nop
	...

080019a0 <chOQObjectInit>:
 * @param[in] link      application defined pointer
 *
 * @init
 */
void chOQObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                    qnotify_t onfy, void *link) {
 80019a0:	b430      	push	{r4, r5}
 80019a2:	9c02      	ldr	r4, [sp, #8]
  chThdQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
  oqp->q_buffer  = bp;
  oqp->q_rdptr   = bp;
  oqp->q_wrptr   = bp;
  oqp->q_top     = bp + size;
 80019a4:	188d      	adds	r5, r1, r2
 80019a6:	6105      	str	r5, [r0, #16]
  oqp->q_notify  = onfy;
  oqp->q_link    = link;
 80019a8:	6204      	str	r4, [r0, #32]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 80019aa:	6000      	str	r0, [r0, #0]
  tqp->p_prev = (thread_t *)tqp;
 80019ac:	6040      	str	r0, [r0, #4]
 */
void chOQObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                    qnotify_t onfy, void *link) {

  chThdQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
 80019ae:	6082      	str	r2, [r0, #8]
  oqp->q_buffer  = bp;
 80019b0:	60c1      	str	r1, [r0, #12]
  oqp->q_rdptr   = bp;
 80019b2:	6181      	str	r1, [r0, #24]
  oqp->q_wrptr   = bp;
 80019b4:	6141      	str	r1, [r0, #20]
  oqp->q_top     = bp + size;
  oqp->q_notify  = onfy;
 80019b6:	61c3      	str	r3, [r0, #28]
  oqp->q_link    = link;
}
 80019b8:	bc30      	pop	{r4, r5}
 80019ba:	4770      	bx	lr
 80019bc:	0000      	movs	r0, r0
	...

080019c0 <chOQPutTimeout>:
 * @retval Q_TIMEOUT    if the specified time expired.
 * @retval Q_RESET      if the queue has been reset.
 *
 * @api
 */
msg_t chOQPutTimeout(output_queue_t *oqp, uint8_t b, systime_t timeout) {
 80019c0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80019c2:	4604      	mov	r4, r0
 80019c4:	460f      	mov	r7, r1
 80019c6:	4616      	mov	r6, r2
 80019c8:	2320      	movs	r3, #32
 80019ca:	f383 8811 	msr	BASEPRI, r3
 80019ce:	e005      	b.n	80019dc <chOQPutTimeout+0x1c>

  chSysLock();
  while (chOQIsFullI(oqp)) {
    msg_t msg = chThdEnqueueTimeoutS(&oqp->q_waiting, timeout);
 80019d0:	4620      	mov	r0, r4
 80019d2:	4631      	mov	r1, r6
 80019d4:	f7ff fe9c 	bl	8001710 <chThdEnqueueTimeoutS>
    if (msg < Q_OK) {
 80019d8:	2800      	cmp	r0, #0
 80019da:	db17      	blt.n	8001a0c <chOQPutTimeout+0x4c>
 */
static inline bool chOQIsFullI(output_queue_t *oqp) {

  chDbgCheckClassI();

  return (bool)(chQSpaceI(oqp) == 0U);
 80019dc:	68a5      	ldr	r5, [r4, #8]
 * @api
 */
msg_t chOQPutTimeout(output_queue_t *oqp, uint8_t b, systime_t timeout) {

  chSysLock();
  while (chOQIsFullI(oqp)) {
 80019de:	2d00      	cmp	r5, #0
 80019e0:	d0f6      	beq.n	80019d0 <chOQPutTimeout+0x10>
      return msg;
    }
  }

  oqp->q_counter--;
  *oqp->q_wrptr++ = b;
 80019e2:	6962      	ldr	r2, [r4, #20]
      chSysUnlock();
      return msg;
    }
  }

  oqp->q_counter--;
 80019e4:	68a3      	ldr	r3, [r4, #8]
  *oqp->q_wrptr++ = b;
 80019e6:	1c51      	adds	r1, r2, #1
      chSysUnlock();
      return msg;
    }
  }

  oqp->q_counter--;
 80019e8:	3b01      	subs	r3, #1
  *oqp->q_wrptr++ = b;
 80019ea:	6161      	str	r1, [r4, #20]
      chSysUnlock();
      return msg;
    }
  }

  oqp->q_counter--;
 80019ec:	60a3      	str	r3, [r4, #8]
  *oqp->q_wrptr++ = b;
 80019ee:	7017      	strb	r7, [r2, #0]
  if (oqp->q_wrptr >= oqp->q_top) {
 80019f0:	6923      	ldr	r3, [r4, #16]
 80019f2:	6962      	ldr	r2, [r4, #20]
 80019f4:	429a      	cmp	r2, r3
    oqp->q_wrptr = oqp->q_buffer;
 80019f6:	bf24      	itt	cs
 80019f8:	68e3      	ldrcs	r3, [r4, #12]
 80019fa:	6163      	strcs	r3, [r4, #20]
  }

  if (oqp->q_notify != NULL) {
 80019fc:	69e3      	ldr	r3, [r4, #28]
 80019fe:	b10b      	cbz	r3, 8001a04 <chOQPutTimeout+0x44>
    oqp->q_notify(oqp);
 8001a00:	4620      	mov	r0, r4
 8001a02:	4798      	blx	r3
 8001a04:	2000      	movs	r0, #0
 8001a06:	f380 8811 	msr	BASEPRI, r0
  }
  chSysUnlock();

  return Q_OK;
}
 8001a0a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8001a0c:	f385 8811 	msr	BASEPRI, r5
  chSysLock();
  while (chOQIsFullI(oqp)) {
    msg_t msg = chThdEnqueueTimeoutS(&oqp->q_waiting, timeout);
    if (msg < Q_OK) {
      chSysUnlock();
      return msg;
 8001a10:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8001a12:	bf00      	nop
	...

08001a20 <chOQGetI>:
 * @return              The byte value from the queue.
 * @retval Q_EMPTY      if the queue is empty.
 *
 * @iclass
 */
msg_t chOQGetI(output_queue_t *oqp) {
 8001a20:	b538      	push	{r3, r4, r5, lr}
static inline bool chOQIsEmptyI(output_queue_t *oqp) {

  chDbgCheckClassI();

  /*lint -save -e9007 [13.5] No side effects.*/
  return (bool)((oqp->q_wrptr == oqp->q_rdptr) && (oqp->q_counter != 0U));
 8001a22:	6942      	ldr	r2, [r0, #20]
 8001a24:	6983      	ldr	r3, [r0, #24]
 8001a26:	429a      	cmp	r2, r3
 8001a28:	d00f      	beq.n	8001a4a <chOQGetI+0x2a>

  if (chOQIsEmptyI(oqp)) {
    return Q_EMPTY;
  }

  oqp->q_counter++;
 8001a2a:	6882      	ldr	r2, [r0, #8]
  b = *oqp->q_rdptr++;
  if (oqp->q_rdptr >= oqp->q_top) {
 8001a2c:	6905      	ldr	r5, [r0, #16]
  if (chOQIsEmptyI(oqp)) {
    return Q_EMPTY;
  }

  oqp->q_counter++;
  b = *oqp->q_rdptr++;
 8001a2e:	1c59      	adds	r1, r3, #1

  if (chOQIsEmptyI(oqp)) {
    return Q_EMPTY;
  }

  oqp->q_counter++;
 8001a30:	3201      	adds	r2, #1
 8001a32:	6082      	str	r2, [r0, #8]
  b = *oqp->q_rdptr++;
 8001a34:	6181      	str	r1, [r0, #24]
  if (oqp->q_rdptr >= oqp->q_top) {
 8001a36:	42a9      	cmp	r1, r5
  if (chOQIsEmptyI(oqp)) {
    return Q_EMPTY;
  }

  oqp->q_counter++;
  b = *oqp->q_rdptr++;
 8001a38:	781c      	ldrb	r4, [r3, #0]
  if (oqp->q_rdptr >= oqp->q_top) {
 8001a3a:	d301      	bcc.n	8001a40 <chOQGetI+0x20>
    oqp->q_rdptr = oqp->q_buffer;
 8001a3c:	68c3      	ldr	r3, [r0, #12]
 8001a3e:	6183      	str	r3, [r0, #24]
  }

  chThdDequeueNextI(&oqp->q_waiting, Q_OK);
 8001a40:	2100      	movs	r1, #0
 8001a42:	f7ff fe7d 	bl	8001740 <chThdDequeueNextI>

  return (msg_t)b;
 8001a46:	4620      	mov	r0, r4
 8001a48:	bd38      	pop	{r3, r4, r5, pc}
 8001a4a:	6882      	ldr	r2, [r0, #8]
 8001a4c:	2a00      	cmp	r2, #0
 8001a4e:	d0ec      	beq.n	8001a2a <chOQGetI+0xa>
  uint8_t b;

  chDbgCheckClassI();

  if (chOQIsEmptyI(oqp)) {
    return Q_EMPTY;
 8001a50:	f06f 0002 	mvn.w	r0, #2
 8001a54:	bd38      	pop	{r3, r4, r5, pc}
 8001a56:	bf00      	nop
	...

08001a60 <chOQWriteTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t chOQWriteTimeout(output_queue_t *oqp, const uint8_t *bp,
                        size_t n, systime_t timeout) {
 8001a60:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8001a64:	b083      	sub	sp, #12
 8001a66:	4604      	mov	r4, r0
 8001a68:	468b      	mov	fp, r1
 8001a6a:	4615      	mov	r5, r2
 8001a6c:	9301      	str	r3, [sp, #4]
  qnotify_t nfy = oqp->q_notify;
 8001a6e:	69c7      	ldr	r7, [r0, #28]
 8001a70:	f04f 0820 	mov.w	r8, #32
 8001a74:	f388 8811 	msr	BASEPRI, r8
  size_t w = 0;
 8001a78:	2600      	movs	r6, #0
 8001a7a:	46b1      	mov	r9, r6
 */
static inline bool chOQIsFullI(output_queue_t *oqp) {

  chDbgCheckClassI();

  return (bool)(chQSpaceI(oqp) == 0U);
 8001a7c:	68a3      	ldr	r3, [r4, #8]
        return w;
      }
    }
    
    oqp->q_counter--;
    *oqp->q_wrptr++ = *bp++;
 8001a7e:	f10b 0a01 	add.w	sl, fp, #1

  chDbgCheck(n > 0U);

  chSysLock();
  while (true) {
    while (chOQIsFullI(oqp)) {
 8001a82:	b1fb      	cbz	r3, 8001ac4 <chOQWriteTimeout+0x64>
        return w;
      }
    }
    
    oqp->q_counter--;
    *oqp->q_wrptr++ = *bp++;
 8001a84:	6962      	ldr	r2, [r4, #20]
        chSysUnlock();
        return w;
      }
    }
    
    oqp->q_counter--;
 8001a86:	68a3      	ldr	r3, [r4, #8]
    *oqp->q_wrptr++ = *bp++;
 8001a88:	1c50      	adds	r0, r2, #1
        chSysUnlock();
        return w;
      }
    }
    
    oqp->q_counter--;
 8001a8a:	3b01      	subs	r3, #1
    *oqp->q_wrptr++ = *bp++;
 8001a8c:	6160      	str	r0, [r4, #20]
        chSysUnlock();
        return w;
      }
    }
    
    oqp->q_counter--;
 8001a8e:	60a3      	str	r3, [r4, #8]
    *oqp->q_wrptr++ = *bp++;
 8001a90:	f89b 3000 	ldrb.w	r3, [fp]
 8001a94:	7013      	strb	r3, [r2, #0]
    if (oqp->q_wrptr >= oqp->q_top) {
 8001a96:	6923      	ldr	r3, [r4, #16]
 8001a98:	6962      	ldr	r2, [r4, #20]
 8001a9a:	429a      	cmp	r2, r3
      oqp->q_wrptr = oqp->q_buffer;
 8001a9c:	bf24      	itt	cs
 8001a9e:	68e3      	ldrcs	r3, [r4, #12]
 8001aa0:	6163      	strcs	r3, [r4, #20]
    }

    if (nfy != NULL) {
 8001aa2:	b10f      	cbz	r7, 8001aa8 <chOQWriteTimeout+0x48>
      nfy(oqp);
 8001aa4:	4620      	mov	r0, r4
 8001aa6:	47b8      	blx	r7
 8001aa8:	f389 8811 	msr	BASEPRI, r9
    }
    chSysUnlock(); /* Gives a preemption chance in a controlled point.*/

    w++;
    if (--n == 0U) {
 8001aac:	3d01      	subs	r5, #1
    if (nfy != NULL) {
      nfy(oqp);
    }
    chSysUnlock(); /* Gives a preemption chance in a controlled point.*/

    w++;
 8001aae:	f106 0601 	add.w	r6, r6, #1
    if (--n == 0U) {
 8001ab2:	d011      	beq.n	8001ad8 <chOQWriteTimeout+0x78>
 8001ab4:	f388 8811 	msr	BASEPRI, r8
        return w;
      }
    }
    
    oqp->q_counter--;
    *oqp->q_wrptr++ = *bp++;
 8001ab8:	46d3      	mov	fp, sl
 8001aba:	68a3      	ldr	r3, [r4, #8]
 8001abc:	f10b 0a01 	add.w	sl, fp, #1

  chDbgCheck(n > 0U);

  chSysLock();
  while (true) {
    while (chOQIsFullI(oqp)) {
 8001ac0:	2b00      	cmp	r3, #0
 8001ac2:	d1df      	bne.n	8001a84 <chOQWriteTimeout+0x24>
      if (chThdEnqueueTimeoutS(&oqp->q_waiting, timeout) != Q_OK) {
 8001ac4:	4620      	mov	r0, r4
 8001ac6:	9901      	ldr	r1, [sp, #4]
 8001ac8:	9300      	str	r3, [sp, #0]
 8001aca:	f7ff fe21 	bl	8001710 <chThdEnqueueTimeoutS>
 8001ace:	9b00      	ldr	r3, [sp, #0]
 8001ad0:	2800      	cmp	r0, #0
 8001ad2:	d0d3      	beq.n	8001a7c <chOQWriteTimeout+0x1c>
 8001ad4:	f383 8811 	msr	BASEPRI, r3
    if (--n == 0U) {
      return w;
    }
    chSysLock();
  }
}
 8001ad8:	4630      	mov	r0, r6
 8001ada:	b003      	add	sp, #12
 8001adc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

08001ae0 <_core_init>:
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  /*lint -save -e9033 [10.8] Required cast operations.*/
  nextmem = (uint8_t *)MEM_ALIGN_NEXT(__heap_base__);
 8001ae0:	4a05      	ldr	r2, [pc, #20]	; (8001af8 <_core_init+0x18>)
  endmem = (uint8_t *)MEM_ALIGN_PREV(__heap_end__);
 8001ae2:	4b06      	ldr	r3, [pc, #24]	; (8001afc <_core_init+0x1c>)
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  /*lint -save -e9033 [10.8] Required cast operations.*/
  nextmem = (uint8_t *)MEM_ALIGN_NEXT(__heap_base__);
 8001ae4:	4806      	ldr	r0, [pc, #24]	; (8001b00 <_core_init+0x20>)
  endmem = (uint8_t *)MEM_ALIGN_PREV(__heap_end__);
 8001ae6:	4907      	ldr	r1, [pc, #28]	; (8001b04 <_core_init+0x24>)
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  /*lint -save -e9033 [10.8] Required cast operations.*/
  nextmem = (uint8_t *)MEM_ALIGN_NEXT(__heap_base__);
 8001ae8:	f022 0207 	bic.w	r2, r2, #7
  endmem = (uint8_t *)MEM_ALIGN_PREV(__heap_end__);
 8001aec:	f023 0307 	bic.w	r3, r3, #7
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  /*lint -save -e9033 [10.8] Required cast operations.*/
  nextmem = (uint8_t *)MEM_ALIGN_NEXT(__heap_base__);
 8001af0:	6002      	str	r2, [r0, #0]
  endmem = (uint8_t *)MEM_ALIGN_PREV(__heap_end__);
 8001af2:	600b      	str	r3, [r1, #0]
 8001af4:	4770      	bx	lr
 8001af6:	bf00      	nop
 8001af8:	2000114f 	.word	0x2000114f
 8001afc:	2000c000 	.word	0x2000c000
 8001b00:	20000a24 	.word	0x20000a24
 8001b04:	20000a20 	.word	0x20000a20
	...

08001b10 <chCoreAlloc>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @api
 */
void *chCoreAlloc(size_t size) {
 8001b10:	b410      	push	{r4}
 8001b12:	2320      	movs	r3, #32
 8001b14:	f383 8811 	msr	BASEPRI, r3

  chDbgCheckClassI();

  size = MEM_ALIGN_NEXT(size);
  /*lint -save -e9033 [10.8] The cast is safe.*/
  if ((size_t)(endmem - nextmem) < size) {
 8001b18:	4c09      	ldr	r4, [pc, #36]	; (8001b40 <chCoreAlloc+0x30>)
 8001b1a:	4b0a      	ldr	r3, [pc, #40]	; (8001b44 <chCoreAlloc+0x34>)
 8001b1c:	6822      	ldr	r2, [r4, #0]
 8001b1e:	6819      	ldr	r1, [r3, #0]
void *chCoreAllocI(size_t size) {
  void *p;

  chDbgCheckClassI();

  size = MEM_ALIGN_NEXT(size);
 8001b20:	1dc3      	adds	r3, r0, #7
 8001b22:	f023 0307 	bic.w	r3, r3, #7
  /*lint -save -e9033 [10.8] The cast is safe.*/
  if ((size_t)(endmem - nextmem) < size) {
 8001b26:	1a89      	subs	r1, r1, r2
 8001b28:	428b      	cmp	r3, r1
  /*lint -restore*/
    return NULL;
  }
  p = nextmem;
  nextmem += size;
 8001b2a:	bf9d      	ittte	ls
 8001b2c:	189b      	addls	r3, r3, r2
 8001b2e:	6023      	strls	r3, [r4, #0]

  return p;
 8001b30:	4610      	movls	r0, r2

  size = MEM_ALIGN_NEXT(size);
  /*lint -save -e9033 [10.8] The cast is safe.*/
  if ((size_t)(endmem - nextmem) < size) {
  /*lint -restore*/
    return NULL;
 8001b32:	2000      	movhi	r0, #0
 8001b34:	2300      	movs	r3, #0
 8001b36:	f383 8811 	msr	BASEPRI, r3
  chSysLock();
  p = chCoreAllocI(size);
  chSysUnlock();

  return p;
}
 8001b3a:	f85d 4b04 	ldr.w	r4, [sp], #4
 8001b3e:	4770      	bx	lr
 8001b40:	20000a24 	.word	0x20000a24
 8001b44:	20000a20 	.word	0x20000a20
	...

08001b50 <_heap_init>:
 *
 * @notapi
 */
void _heap_init(void) {

  default_heap.h_provider = chCoreAlloc;
 8001b50:	4b04      	ldr	r3, [pc, #16]	; (8001b64 <_heap_init+0x14>)
 8001b52:	4905      	ldr	r1, [pc, #20]	; (8001b68 <_heap_init+0x18>)
  default_heap.h_free.h.u.next = NULL;
 8001b54:	2200      	movs	r2, #0
  default_heap.h_free.h.size = 0;
#if (CH_CFG_USE_MUTEXES == TRUE) || defined(__DOXYGEN__)
  chMtxObjectInit(&default_heap.h_mtx);
 8001b56:	f103 0010 	add.w	r0, r3, #16
 *
 * @notapi
 */
void _heap_init(void) {

  default_heap.h_provider = chCoreAlloc;
 8001b5a:	6019      	str	r1, [r3, #0]
  default_heap.h_free.h.u.next = NULL;
 8001b5c:	609a      	str	r2, [r3, #8]
  default_heap.h_free.h.size = 0;
 8001b5e:	60da      	str	r2, [r3, #12]
#if (CH_CFG_USE_MUTEXES == TRUE) || defined(__DOXYGEN__)
  chMtxObjectInit(&default_heap.h_mtx);
 8001b60:	f7ff be4e 	b.w	8001800 <chMtxObjectInit>
 8001b64:	20000a28 	.word	0x20000a28
 8001b68:	08001b11 	.word	0x08001b11
 8001b6c:	00000000 	.word	0x00000000

08001b70 <SVC_Handler>:
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 8001b70:	f3ef 8309 	mrs	r3, PSP
  /* The port_extctx structure is pointed by the PSP register.*/
  ctxp = (struct port_extctx *)__get_PSP();

  /* Discarding the current exception context and positioning the stack to
     point to the real one.*/
  ctxp++;
 8001b74:	3320      	adds	r3, #32

    \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
 8001b76:	f383 8809 	msr	PSP, r3

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8001b7a:	2300      	movs	r3, #0
 8001b7c:	f383 8811 	msr	BASEPRI, r3
 8001b80:	4770      	bx	lr
 8001b82:	bf00      	nop
	...

08001b90 <_port_irq_epilogue>:
 8001b90:	2320      	movs	r3, #32
 8001b92:	f383 8811 	msr	BASEPRI, r3
 * @brief   Exception exit redirection to _port_switch_from_isr().
 */
void _port_irq_epilogue(void) {

  port_lock_from_isr();
  if ((SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) != 0U) {
 8001b96:	4b0f      	ldr	r3, [pc, #60]	; (8001bd4 <_port_irq_epilogue+0x44>)
 8001b98:	685b      	ldr	r3, [r3, #4]
 8001b9a:	f413 6300 	ands.w	r3, r3, #2048	; 0x800
 8001b9e:	d102      	bne.n	8001ba6 <_port_irq_epilogue+0x16>
 8001ba0:	f383 8811 	msr	BASEPRI, r3
 8001ba4:	4770      	bx	lr
/*===========================================================================*/

/**
 * @brief   Exception exit redirection to _port_switch_from_isr().
 */
void _port_irq_epilogue(void) {
 8001ba6:	b510      	push	{r4, lr}
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 8001ba8:	f3ef 8409 	mrs	r4, PSP
    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    ctxp--;

    /* Setting up a fake XPSR register value.*/
    ctxp->xpsr = (regarm_t)0x01000000;
 8001bac:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
 8001bb0:	f844 3c04 	str.w	r3, [r4, #-4]
    /* The port_extctx structure is pointed by the PSP register.*/
    ctxp = (struct port_extctx *)__get_PSP();

    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    ctxp--;
 8001bb4:	f1a4 0320 	sub.w	r3, r4, #32

    \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
 8001bb8:	f383 8809 	msr	PSP, r3
    /* Writing back the modified PSP value.*/
    __set_PSP((uint32_t)ctxp);

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
 8001bbc:	f7ff fce0 	bl	8001580 <chSchIsPreemptionRequired>
 8001bc0:	b118      	cbz	r0, 8001bca <_port_irq_epilogue+0x3a>
      /* Preemption is required we need to enforce a context switch.*/
      ctxp->pc = (regarm_t)_port_switch_from_isr;
 8001bc2:	4b05      	ldr	r3, [pc, #20]	; (8001bd8 <_port_irq_epilogue+0x48>)
 8001bc4:	f844 3c08 	str.w	r3, [r4, #-8]
 8001bc8:	bd10      	pop	{r4, pc}
    }
    else {
      /* Preemption not required, we just need to exit the exception
         atomically.*/
      ctxp->pc = (regarm_t)_port_exit_from_isr;
 8001bca:	4b04      	ldr	r3, [pc, #16]	; (8001bdc <_port_irq_epilogue+0x4c>)
 8001bcc:	f844 3c08 	str.w	r3, [r4, #-8]
 8001bd0:	bd10      	pop	{r4, pc}
 8001bd2:	bf00      	nop
 8001bd4:	e000ed00 	.word	0xe000ed00
 8001bd8:	08000251 	.word	0x08000251
 8001bdc:	08000254 	.word	0x08000254

08001be0 <halInit>:
 *          board-specific initialization is performed by invoking
 *          @p boardInit() (usually defined in @p board.c).
 *
 * @init
 */
void halInit(void) {
 8001be0:	b508      	push	{r3, lr}

  /* Initializes the OS Abstraction Layer.*/
  osalInit();

  /* Platform low level initializations.*/
  hal_lld_init();
 8001be2:	f000 fc3d 	bl	8002460 <hal_lld_init>

#if (HAL_USE_PAL == TRUE) || defined(__DOXYGEN__)
  palInit(&pal_default_config);
 8001be6:	480a      	ldr	r0, [pc, #40]	; (8001c10 <halInit+0x30>)
 8001be8:	f000 fe12 	bl	8002810 <_pal_lld_init>
#endif
#if (HAL_USE_ADC == TRUE) || defined(__DOXYGEN__)
  adcInit();
 8001bec:	f000 f820 	bl	8001c30 <adcInit>
#endif
#if (HAL_USE_GPT == TRUE) || defined(__DOXYGEN__)
  gptInit();
#endif
#if (HAL_USE_I2C == TRUE) || defined(__DOXYGEN__)
  i2cInit();
 8001bf0:	f000 f82e 	bl	8001c50 <i2cInit>
#endif
#if (HAL_USE_MAC == TRUE) || defined(__DOXYGEN__)
  macInit();
#endif
#if (HAL_USE_PWM == TRUE) || defined(__DOXYGEN__)
  pwmInit();
 8001bf4:	f000 f83c 	bl	8001c70 <pwmInit>
#endif
#if (HAL_USE_SERIAL == TRUE) || defined(__DOXYGEN__)
  sdInit();
 8001bf8:	f000 f88a 	bl	8001d10 <sdInit>
#endif
#if (HAL_USE_UART == TRUE) || defined(__DOXYGEN__)
  uartInit();
#endif
#if (HAL_USE_USB == TRUE) || defined(__DOXYGEN__)
  usbInit();
 8001bfc:	f000 f900 	bl	8001e00 <usbInit>
#endif
#if (HAL_USE_MMC_SPI == TRUE) || defined(__DOXYGEN__)
  mmcInit();
#endif
#if (HAL_USE_SERIAL_USB == TRUE) || defined(__DOXYGEN__)
  sduInit();
 8001c00:	f000 f8de 	bl	8001dc0 <sduInit>
  halCommunityInit();
#endif
#endif

  /* Board specific initialization.*/
  boardInit();
 8001c04:	f001 fc2c 	bl	8003460 <boardInit>
 *  configured to require it.
 */
#if OSAL_ST_MODE != OSAL_ST_MODE_NONE
  stInit();
#endif
}
 8001c08:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
/*
 *  The ST driver is a special case, it is only initialized if the OSAL is
 *  configured to require it.
 */
#if OSAL_ST_MODE != OSAL_ST_MODE_NONE
  stInit();
 8001c0c:	f000 b808 	b.w	8001c20 <stInit>
 8001c10:	08004840 	.word	0x08004840
	...

08001c20 <stInit>:
 *
 * @init
 */
void stInit(void) {

  st_lld_init();
 8001c20:	f000 bdae 	b.w	8002780 <st_lld_init>
	...

08001c30 <adcInit>:
 *
 * @init
 */
void adcInit(void) {

  adc_lld_init();
 8001c30:	f000 bdb6 	b.w	80027a0 <adc_lld_init>
	...

08001c40 <adcObjectInit>:
 * @init
 */
void adcObjectInit(ADCDriver *adcp) {

  adcp->state    = ADC_STOP;
  adcp->config   = NULL;
 8001c40:	2300      	movs	r3, #0
 *
 * @init
 */
void adcObjectInit(ADCDriver *adcp) {

  adcp->state    = ADC_STOP;
 8001c42:	2201      	movs	r2, #1
 8001c44:	7002      	strb	r2, [r0, #0]
  adcp->config   = NULL;
 8001c46:	6043      	str	r3, [r0, #4]
  adcp->samples  = NULL;
 8001c48:	6083      	str	r3, [r0, #8]
  adcp->depth    = 0;
 8001c4a:	60c3      	str	r3, [r0, #12]
  adcp->grpp     = NULL;
 8001c4c:	6103      	str	r3, [r0, #16]
 8001c4e:	4770      	bx	lr

08001c50 <i2cInit>:
 *
 * @init
 */
void i2cInit(void) {

  i2c_lld_init();
 8001c50:	f000 bf26 	b.w	8002aa0 <i2c_lld_init>
	...

08001c60 <i2cObjectInit>:
 *
 * @init
 */
void i2cObjectInit(I2CDriver *i2cp) {

  i2cp->state  = I2C_STOP;
 8001c60:	2201      	movs	r2, #1
  i2cp->config = NULL;
 8001c62:	2300      	movs	r3, #0
 *
 * @init
 */
void i2cObjectInit(I2CDriver *i2cp) {

  i2cp->state  = I2C_STOP;
 8001c64:	7002      	strb	r2, [r0, #0]
  i2cp->config = NULL;
 8001c66:	6043      	str	r3, [r0, #4]
 * @init
 */
static inline void osalMutexObjectInit(mutex_t *mp) {

#if CH_CFG_USE_MUTEXES
  chMtxObjectInit(mp);
 8001c68:	300c      	adds	r0, #12
 8001c6a:	f7ff bdc9 	b.w	8001800 <chMtxObjectInit>
 8001c6e:	bf00      	nop

08001c70 <pwmInit>:
 *
 * @init
 */
void pwmInit(void) {

  pwm_lld_init();
 8001c70:	f000 bf2e 	b.w	8002ad0 <pwm_lld_init>
	...

08001c80 <pwmObjectInit>:
 * @init
 */
void pwmObjectInit(PWMDriver *pwmp) {

  pwmp->state    = PWM_STOP;
  pwmp->config   = NULL;
 8001c80:	2300      	movs	r3, #0
 *
 * @init
 */
void pwmObjectInit(PWMDriver *pwmp) {

  pwmp->state    = PWM_STOP;
 8001c82:	2201      	movs	r2, #1
 8001c84:	7002      	strb	r2, [r0, #0]
  pwmp->config   = NULL;
 8001c86:	6043      	str	r3, [r0, #4]
  pwmp->enabled  = 0;
 8001c88:	60c3      	str	r3, [r0, #12]
  pwmp->channels = 0;
 8001c8a:	7403      	strb	r3, [r0, #16]
 8001c8c:	4770      	bx	lr
 8001c8e:	bf00      	nop

08001c90 <readt>:
  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, timeout);
}

static size_t readt(void *ip, uint8_t *bp, size_t n, systime_t timeout) {

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp, n, timeout);
 8001c90:	300c      	adds	r0, #12
 8001c92:	f7ff be45 	b.w	8001920 <chIQReadTimeout>
 8001c96:	bf00      	nop
	...

08001ca0 <read>:
                        n, TIME_INFINITE);
}

static size_t read(void *ip, uint8_t *bp, size_t n) {

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp,
 8001ca0:	300c      	adds	r0, #12
 8001ca2:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8001ca6:	f7ff be3b 	b.w	8001920 <chIQReadTimeout>
 8001caa:	bf00      	nop
 8001cac:	0000      	movs	r0, r0
	...

08001cb0 <writet>:
  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, timeout);
}

static size_t writet(void *ip, const uint8_t *bp, size_t n, systime_t timeout) {

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, timeout);
 8001cb0:	3030      	adds	r0, #48	; 0x30
 8001cb2:	f7ff bed5 	b.w	8001a60 <chOQWriteTimeout>
 8001cb6:	bf00      	nop
	...

08001cc0 <write>:
 * queue-level function or macro.
 */

static size_t write(void *ip, const uint8_t *bp, size_t n) {

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp,
 8001cc0:	3030      	adds	r0, #48	; 0x30
 8001cc2:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8001cc6:	f7ff becb 	b.w	8001a60 <chOQWriteTimeout>
 8001cca:	bf00      	nop
 8001ccc:	0000      	movs	r0, r0
	...

08001cd0 <gett>:
  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
}

static msg_t gett(void *ip, systime_t timeout) {

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, timeout);
 8001cd0:	300c      	adds	r0, #12
 8001cd2:	f7ff bdfd 	b.w	80018d0 <chIQGetTimeout>
 8001cd6:	bf00      	nop
	...

08001ce0 <get>:
  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
}

static msg_t get(void *ip) {

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, TIME_INFINITE);
 8001ce0:	300c      	adds	r0, #12
 8001ce2:	f64f 71ff 	movw	r1, #65535	; 0xffff
 8001ce6:	f7ff bdf3 	b.w	80018d0 <chIQGetTimeout>
 8001cea:	bf00      	nop
 8001cec:	0000      	movs	r0, r0
	...

08001cf0 <putt>:
}

static msg_t putt(void *ip, uint8_t b, systime_t timeout) {

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
 8001cf0:	3030      	adds	r0, #48	; 0x30
 8001cf2:	f7ff be65 	b.w	80019c0 <chOQPutTimeout>
 8001cf6:	bf00      	nop
	...

08001d00 <put>:
                       n, TIME_INFINITE);
}

static msg_t put(void *ip, uint8_t b) {

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
 8001d00:	3030      	adds	r0, #48	; 0x30
 8001d02:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8001d06:	f7ff be5b 	b.w	80019c0 <chOQPutTimeout>
 8001d0a:	bf00      	nop
 8001d0c:	0000      	movs	r0, r0
	...

08001d10 <sdInit>:
 *
 * @init
 */
void sdInit(void) {

  sd_lld_init();
 8001d10:	f001 b826 	b.w	8002d60 <sd_lld_init>
	...

08001d20 <sdObjectInit>:
 *                      some data is written in the Queue. The value can be
 *                      @p NULL.
 *
 * @init
 */
void sdObjectInit(SerialDriver *sdp, qnotify_t inotify, qnotify_t onotify) {
 8001d20:	b530      	push	{r4, r5, lr}
 8001d22:	4604      	mov	r4, r0
 8001d24:	4615      	mov	r5, r2
 8001d26:	460b      	mov	r3, r1

  sdp->vmt = &vmt;
 8001d28:	490c      	ldr	r1, [pc, #48]	; (8001d5c <sdObjectInit+0x3c>)
 *                      some data is written in the Queue. The value can be
 *                      @p NULL.
 *
 * @init
 */
void sdObjectInit(SerialDriver *sdp, qnotify_t inotify, qnotify_t onotify) {
 8001d2a:	b083      	sub	sp, #12

  sdp->vmt = &vmt;
 8001d2c:	f840 1b04 	str.w	r1, [r0], #4
  osalEventObjectInit(&sdp->event);
  sdp->state = SD_STOP;
 8001d30:	2201      	movs	r2, #1
  iqObjectInit(&sdp->iqueue, sdp->ib, SERIAL_BUFFERS_SIZE, inotify, sdp);
 8001d32:	9400      	str	r4, [sp, #0]
 8001d34:	f104 0154 	add.w	r1, r4, #84	; 0x54
 *
 * @init
 */
static inline void chEvtObjectInit(event_source_t *esp) {

  esp->es_next = (event_listener_t *)esp;
 8001d38:	6060      	str	r0, [r4, #4]
 */
void sdObjectInit(SerialDriver *sdp, qnotify_t inotify, qnotify_t onotify) {

  sdp->vmt = &vmt;
  osalEventObjectInit(&sdp->event);
  sdp->state = SD_STOP;
 8001d3a:	7222      	strb	r2, [r4, #8]
  iqObjectInit(&sdp->iqueue, sdp->ib, SERIAL_BUFFERS_SIZE, inotify, sdp);
 8001d3c:	f104 000c 	add.w	r0, r4, #12
 8001d40:	2280      	movs	r2, #128	; 0x80
 8001d42:	f7ff fd95 	bl	8001870 <chIQObjectInit>
  oqObjectInit(&sdp->oqueue, sdp->ob, SERIAL_BUFFERS_SIZE, onotify, sdp);
 8001d46:	9400      	str	r4, [sp, #0]
 8001d48:	462b      	mov	r3, r5
 8001d4a:	f104 0030 	add.w	r0, r4, #48	; 0x30
 8001d4e:	f104 01d4 	add.w	r1, r4, #212	; 0xd4
 8001d52:	2280      	movs	r2, #128	; 0x80
 8001d54:	f7ff fe24 	bl	80019a0 <chOQObjectInit>
}
 8001d58:	b003      	add	sp, #12
 8001d5a:	bd30      	pop	{r4, r5, pc}
 8001d5c:	080046c0 	.word	0x080046c0

08001d60 <sdStart>:
 *                      If this parameter is set to @p NULL then a default
 *                      configuration is used.
 *
 * @api
 */
void sdStart(SerialDriver *sdp, const SerialConfig *config) {
 8001d60:	b510      	push	{r4, lr}

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8001d62:	2320      	movs	r3, #32
 8001d64:	4604      	mov	r4, r0
 8001d66:	f383 8811 	msr	BASEPRI, r3
  osalDbgCheck(sdp != NULL);

  osalSysLock();
  osalDbgAssert((sdp->state == SD_STOP) || (sdp->state == SD_READY),
                "invalid state");
  sd_lld_start(sdp, config);
 8001d6a:	f001 f811 	bl	8002d90 <sd_lld_start>
  sdp->state = SD_READY;
 8001d6e:	2302      	movs	r3, #2
 8001d70:	7223      	strb	r3, [r4, #8]
 8001d72:	2300      	movs	r3, #0
 8001d74:	f383 8811 	msr	BASEPRI, r3
 8001d78:	bd10      	pop	{r4, pc}
 8001d7a:	bf00      	nop
 8001d7c:	0000      	movs	r0, r0
	...

08001d80 <sdIncomingDataI>:
 * @param[in] sdp       pointer to a @p SerialDriver structure
 * @param[in] b         the byte to be written in the driver's Input Queue
 *
 * @iclass
 */
void sdIncomingDataI(SerialDriver *sdp, uint8_t b) {
 8001d80:	b538      	push	{r3, r4, r5, lr}
 */
static inline bool chIQIsEmptyI(input_queue_t *iqp) {

  chDbgCheckClassI();

  return (bool)(chQSpaceI(iqp) == 0U);
 8001d82:	6943      	ldr	r3, [r0, #20]
 8001d84:	4604      	mov	r4, r0
 8001d86:	460d      	mov	r5, r1

  osalDbgCheckClassI();
  osalDbgCheck(sdp != NULL);

  if (iqIsEmptyI(&sdp->iqueue))
 8001d88:	b13b      	cbz	r3, 8001d9a <sdIncomingDataI+0x1a>
    chnAddFlagsI(sdp, CHN_INPUT_AVAILABLE);
  if (iqPutI(&sdp->iqueue, b) < Q_OK)
 8001d8a:	4629      	mov	r1, r5
 8001d8c:	f104 000c 	add.w	r0, r4, #12
 8001d90:	f7ff fd7e 	bl	8001890 <chIQPutI>
 8001d94:	2800      	cmp	r0, #0
 8001d96:	db0b      	blt.n	8001db0 <sdIncomingDataI+0x30>
 8001d98:	bd38      	pop	{r3, r4, r5, pc}
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {

  chEvtBroadcastFlagsI(esp, flags);
 8001d9a:	3004      	adds	r0, #4
 8001d9c:	2104      	movs	r1, #4
 8001d9e:	f7ff fd4f 	bl	8001840 <chEvtBroadcastFlagsI>
 8001da2:	4629      	mov	r1, r5
 8001da4:	f104 000c 	add.w	r0, r4, #12
 8001da8:	f7ff fd72 	bl	8001890 <chIQPutI>
 8001dac:	2800      	cmp	r0, #0
 8001dae:	daf3      	bge.n	8001d98 <sdIncomingDataI+0x18>
 8001db0:	1d20      	adds	r0, r4, #4
 8001db2:	2180      	movs	r1, #128	; 0x80
    chnAddFlagsI(sdp, SD_OVERRUN_ERROR);
}
 8001db4:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 8001db8:	f7ff bd42 	b.w	8001840 <chEvtBroadcastFlagsI>
 8001dbc:	0000      	movs	r0, r0
	...

08001dc0 <sduInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void sduInit(void) {
 8001dc0:	4770      	bx	lr
 8001dc2:	bf00      	nop
	...

08001dd0 <set_address>:
/**
 * @brief  SET ADDRESS transaction callback.
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 */
static void set_address(USBDriver *usbp) {
 8001dd0:	b510      	push	{r4, lr}
 8001dd2:	4604      	mov	r4, r0

  usbp->address = usbp->setup[2];
 8001dd4:	f890 3076 	ldrb.w	r3, [r0, #118]	; 0x76
 8001dd8:	f880 307e 	strb.w	r3, [r0, #126]	; 0x7e
  usb_lld_set_address(usbp);
 8001ddc:	f001 f980 	bl	80030e0 <usb_lld_set_address>
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_ADDRESS);
 8001de0:	6863      	ldr	r3, [r4, #4]
 8001de2:	681b      	ldr	r3, [r3, #0]
 8001de4:	b113      	cbz	r3, 8001dec <set_address+0x1c>
 8001de6:	4620      	mov	r0, r4
 8001de8:	2101      	movs	r1, #1
 8001dea:	4798      	blx	r3
  usbp->state = USB_SELECTED;
 8001dec:	2303      	movs	r3, #3
 8001dee:	7023      	strb	r3, [r4, #0]
 8001df0:	bd10      	pop	{r4, pc}
 8001df2:	bf00      	nop
	...

08001e00 <usbInit>:
 *
 * @init
 */
void usbInit(void) {

  usb_lld_init();
 8001e00:	f001 b966 	b.w	80030d0 <usb_lld_init>
	...

08001e10 <usbObjectInit>:
 *
 * @param[out] usbp     pointer to the @p USBDriver object
 *
 * @init
 */
void usbObjectInit(USBDriver *usbp) {
 8001e10:	b430      	push	{r4, r5}
 8001e12:	f100 0544 	add.w	r5, r0, #68	; 0x44
  unsigned i;

  usbp->state        = USB_STOP;
  usbp->config       = NULL;
 8001e16:	4629      	mov	r1, r5
 8001e18:	2300      	movs	r3, #0
 * @init
 */
void usbObjectInit(USBDriver *usbp) {
  unsigned i;

  usbp->state        = USB_STOP;
 8001e1a:	2401      	movs	r4, #1
  usbp->config       = NULL;
  for (i = 0; i < (unsigned)USB_MAX_ENDPOINTS; i++) {
    usbp->in_params[i]  = NULL;
 8001e1c:	461a      	mov	r2, r3
 */
void usbObjectInit(USBDriver *usbp) {
  unsigned i;

  usbp->state        = USB_STOP;
  usbp->config       = NULL;
 8001e1e:	6043      	str	r3, [r0, #4]
 * @init
 */
void usbObjectInit(USBDriver *usbp) {
  unsigned i;

  usbp->state        = USB_STOP;
 8001e20:	7004      	strb	r4, [r0, #0]
 8001e22:	f100 0328 	add.w	r3, r0, #40	; 0x28
  usbp->config       = NULL;
  for (i = 0; i < (unsigned)USB_MAX_ENDPOINTS; i++) {
    usbp->in_params[i]  = NULL;
 8001e26:	f843 2f04 	str.w	r2, [r3, #4]!
void usbObjectInit(USBDriver *usbp) {
  unsigned i;

  usbp->state        = USB_STOP;
  usbp->config       = NULL;
  for (i = 0; i < (unsigned)USB_MAX_ENDPOINTS; i++) {
 8001e2a:	42ab      	cmp	r3, r5
    usbp->in_params[i]  = NULL;
 8001e2c:	f04f 0400 	mov.w	r4, #0
    usbp->out_params[i] = NULL;
 8001e30:	f841 2f04 	str.w	r2, [r1, #4]!
void usbObjectInit(USBDriver *usbp) {
  unsigned i;

  usbp->state        = USB_STOP;
  usbp->config       = NULL;
  for (i = 0; i < (unsigned)USB_MAX_ENDPOINTS; i++) {
 8001e34:	d1f7      	bne.n	8001e26 <usbObjectInit+0x16>
    usbp->in_params[i]  = NULL;
    usbp->out_params[i] = NULL;
  }
  usbp->transmitting = 0;
 8001e36:	8104      	strh	r4, [r0, #8]
  usbp->receiving    = 0;
 8001e38:	8144      	strh	r4, [r0, #10]
}
 8001e3a:	bc30      	pop	{r4, r5}
 8001e3c:	4770      	bx	lr
 8001e3e:	bf00      	nop

08001e40 <usbDisableEndpointsI>:

  osalDbgCheckClassI();
  osalDbgCheck(usbp != NULL);
  osalDbgAssert(usbp->state == USB_ACTIVE, "invalid state");

  usbp->transmitting &= 1U;
 8001e40:	8902      	ldrh	r2, [r0, #8]
  usbp->receiving    &= 1U;
 8001e42:	8943      	ldrh	r3, [r0, #10]

  osalDbgCheckClassI();
  osalDbgCheck(usbp != NULL);
  osalDbgAssert(usbp->state == USB_ACTIVE, "invalid state");

  usbp->transmitting &= 1U;
 8001e44:	f002 0201 	and.w	r2, r2, #1
  usbp->receiving    &= 1U;
 8001e48:	f003 0301 	and.w	r3, r3, #1

  osalDbgCheckClassI();
  osalDbgCheck(usbp != NULL);
  osalDbgAssert(usbp->state == USB_ACTIVE, "invalid state");

  usbp->transmitting &= 1U;
 8001e4c:	8102      	strh	r2, [r0, #8]
  usbp->receiving    &= 1U;
 8001e4e:	8143      	strh	r3, [r0, #10]
 8001e50:	f100 0128 	add.w	r1, r0, #40	; 0x28
 8001e54:	f100 030c 	add.w	r3, r0, #12
        osalThreadResumeI(&usbp->epc[i]->out_state->thread, MSG_RESET);
      }
      osalSysUnlockFromISR();
    }
#endif
    usbp->epc[i] = NULL;
 8001e58:	2200      	movs	r2, #0
 8001e5a:	f843 2f04 	str.w	r2, [r3, #4]!
  osalDbgAssert(usbp->state == USB_ACTIVE, "invalid state");

  usbp->transmitting &= 1U;
  usbp->receiving    &= 1U;

  for (i = 1; i <= (unsigned)USB_MAX_ENDPOINTS; i++) {
 8001e5e:	428b      	cmp	r3, r1
 8001e60:	d1fb      	bne.n	8001e5a <usbDisableEndpointsI+0x1a>
#endif
    usbp->epc[i] = NULL;
  }

  /* Low level endpoints deactivation.*/
  usb_lld_disable_endpoints(usbp);
 8001e62:	f001 b9e5 	b.w	8003230 <usb_lld_disable_endpoints>
 8001e66:	bf00      	nop
	...

08001e70 <usbStartReceiveI>:
 *                      the packet size because the excess is discarded.
 *
 * @iclass
 */
void usbStartReceiveI(USBDriver *usbp, usbep_t ep,
                      uint8_t *buf, size_t n) {
 8001e70:	b5f0      	push	{r4, r5, r6, r7, lr}
  /* Marking the endpoint as active.*/
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);

  /* Setting up the transfer.*/
  /*lint -save -e661 [18.1] pclint is confused by the check on ep.*/
  osp = usbp->epc[ep]->out_state;
 8001e72:	eb00 0681 	add.w	r6, r0, r1, lsl #2
 8001e76:	f8d6 e00c 	ldr.w	lr, [r6, #12]
  osalDbgCheckClassI();
  osalDbgCheck((usbp != NULL) && (ep <= (usbep_t)USB_MAX_ENDPOINTS));
  osalDbgAssert(!usbGetReceiveStatusI(usbp, ep), "already receiving");

  /* Marking the endpoint as active.*/
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
 8001e7a:	8947      	ldrh	r7, [r0, #10]
 8001e7c:	2601      	movs	r6, #1

  /* Setting up the transfer.*/
  /*lint -save -e661 [18.1] pclint is confused by the check on ep.*/
  osp = usbp->epc[ep]->out_state;
 8001e7e:	f8de 4018 	ldr.w	r4, [lr, #24]
  osalDbgCheckClassI();
  osalDbgCheck((usbp != NULL) && (ep <= (usbep_t)USB_MAX_ENDPOINTS));
  osalDbgAssert(!usbGetReceiveStatusI(usbp, ep), "already receiving");

  /* Marking the endpoint as active.*/
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
 8001e82:	408e      	lsls	r6, r1
 8001e84:	433e      	orrs	r6, r7
  /*lint -save -e661 [18.1] pclint is confused by the check on ep.*/
  osp = usbp->epc[ep]->out_state;
  /*lint -restore*/
  osp->rxbuf  = buf;
  osp->rxsize = n;
  osp->rxcnt  = 0;
 8001e86:	2700      	movs	r7, #0
  osalDbgCheckClassI();
  osalDbgCheck((usbp != NULL) && (ep <= (usbep_t)USB_MAX_ENDPOINTS));
  osalDbgAssert(!usbGetReceiveStatusI(usbp, ep), "already receiving");

  /* Marking the endpoint as active.*/
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
 8001e88:	8146      	strh	r6, [r0, #10]

  /* Setting up the transfer.*/
  /*lint -save -e661 [18.1] pclint is confused by the check on ep.*/
  osp = usbp->epc[ep]->out_state;
  /*lint -restore*/
  osp->rxbuf  = buf;
 8001e8a:	60a2      	str	r2, [r4, #8]
  osp->rxsize = n;
  osp->rxcnt  = 0;
 8001e8c:	e884 0088 	stmia.w	r4, {r3, r7}
  osp->thread = NULL;
#endif

  /* Starting transfer.*/
  usb_lld_start_out(usbp, ep);
}
 8001e90:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
#if USB_USE_WAIT == TRUE
  osp->thread = NULL;
#endif

  /* Starting transfer.*/
  usb_lld_start_out(usbp, ep);
 8001e94:	f001 ba2c 	b.w	80032f0 <usb_lld_start_out>
	...

08001ea0 <usbStartTransmitI>:
 * @param[in] n         transaction size
 *
 * @iclass
 */
void usbStartTransmitI(USBDriver *usbp, usbep_t ep,
                       const uint8_t *buf, size_t n) {
 8001ea0:	b5f0      	push	{r4, r5, r6, r7, lr}
  /* Marking the endpoint as active.*/
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);

  /* Setting up the transfer.*/
  /*lint -save -e661 [18.1] pclint is confused by the check on ep.*/
  isp = usbp->epc[ep]->in_state;
 8001ea2:	eb00 0681 	add.w	r6, r0, r1, lsl #2
 8001ea6:	f8d6 e00c 	ldr.w	lr, [r6, #12]
  osalDbgCheckClassI();
  osalDbgCheck((usbp != NULL) && (ep <= (usbep_t)USB_MAX_ENDPOINTS));
  osalDbgAssert(!usbGetTransmitStatusI(usbp, ep), "already transmitting");

  /* Marking the endpoint as active.*/
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
 8001eaa:	8907      	ldrh	r7, [r0, #8]
 8001eac:	2601      	movs	r6, #1

  /* Setting up the transfer.*/
  /*lint -save -e661 [18.1] pclint is confused by the check on ep.*/
  isp = usbp->epc[ep]->in_state;
 8001eae:	f8de 4014 	ldr.w	r4, [lr, #20]
  osalDbgCheckClassI();
  osalDbgCheck((usbp != NULL) && (ep <= (usbep_t)USB_MAX_ENDPOINTS));
  osalDbgAssert(!usbGetTransmitStatusI(usbp, ep), "already transmitting");

  /* Marking the endpoint as active.*/
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
 8001eb2:	408e      	lsls	r6, r1
 8001eb4:	433e      	orrs	r6, r7
  /*lint -save -e661 [18.1] pclint is confused by the check on ep.*/
  isp = usbp->epc[ep]->in_state;
  /*lint -restore*/
  isp->txbuf  = buf;
  isp->txsize = n;
  isp->txcnt  = 0;
 8001eb6:	2700      	movs	r7, #0
  osalDbgCheckClassI();
  osalDbgCheck((usbp != NULL) && (ep <= (usbep_t)USB_MAX_ENDPOINTS));
  osalDbgAssert(!usbGetTransmitStatusI(usbp, ep), "already transmitting");

  /* Marking the endpoint as active.*/
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
 8001eb8:	8106      	strh	r6, [r0, #8]

  /* Setting up the transfer.*/
  /*lint -save -e661 [18.1] pclint is confused by the check on ep.*/
  isp = usbp->epc[ep]->in_state;
  /*lint -restore*/
  isp->txbuf  = buf;
 8001eba:	60a2      	str	r2, [r4, #8]
  isp->txsize = n;
  isp->txcnt  = 0;
 8001ebc:	e884 0088 	stmia.w	r4, {r3, r7}
  isp->thread = NULL;
#endif

  /* Starting transfer.*/
  usb_lld_start_in(usbp, ep);
}
 8001ec0:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
#if USB_USE_WAIT == TRUE
  isp->thread = NULL;
#endif

  /* Starting transfer.*/
  usb_lld_start_in(usbp, ep);
 8001ec4:	f001 ba3c 	b.w	8003340 <usb_lld_start_in>
	...

08001ed0 <_usb_reset>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
void _usb_reset(USBDriver *usbp) {
 8001ed0:	b570      	push	{r4, r5, r6, lr}
 8001ed2:	4604      	mov	r4, r0

  /* State transition.*/
  usbp->state         = USB_READY;

  /* Resetting internal state.*/
  usbp->status        = 0;
 8001ed4:	2300      	movs	r3, #0
 */
void _usb_reset(USBDriver *usbp) {
  unsigned i;

  /* State transition.*/
  usbp->state         = USB_READY;
 8001ed6:	2202      	movs	r2, #2
        osalThreadResumeI(&usbp->epc[i]->out_state->thread, MSG_RESET);
      }
      osalSysUnlockFromISR();
    }
#endif
    usbp->epc[i] = NULL;
 8001ed8:	4619      	mov	r1, r3
 */
void _usb_reset(USBDriver *usbp) {
  unsigned i;

  /* State transition.*/
  usbp->state         = USB_READY;
 8001eda:	7002      	strb	r2, [r0, #0]

  /* Resetting internal state.*/
  usbp->status        = 0;
 8001edc:	f8a0 307c 	strh.w	r3, [r0, #124]	; 0x7c
  usbp->address       = 0;
 8001ee0:	f880 307e 	strb.w	r3, [r0, #126]	; 0x7e
  usbp->configuration = 0;
 8001ee4:	f880 307f 	strb.w	r3, [r0, #127]	; 0x7f
  usbp->transmitting  = 0;
 8001ee8:	8103      	strh	r3, [r0, #8]
  usbp->receiving     = 0;
 8001eea:	8143      	strh	r3, [r0, #10]
 8001eec:	f100 0228 	add.w	r2, r0, #40	; 0x28
 8001ef0:	f100 0308 	add.w	r3, r0, #8
        osalThreadResumeI(&usbp->epc[i]->out_state->thread, MSG_RESET);
      }
      osalSysUnlockFromISR();
    }
#endif
    usbp->epc[i] = NULL;
 8001ef4:	f843 1f04 	str.w	r1, [r3, #4]!
  usbp->configuration = 0;
  usbp->transmitting  = 0;
  usbp->receiving     = 0;

  /* Invalidates all endpoints into the USBDriver structure.*/
  for (i = 0; i <= (unsigned)USB_MAX_ENDPOINTS; i++) {
 8001ef8:	4293      	cmp	r3, r2
        osalThreadResumeI(&usbp->epc[i]->out_state->thread, MSG_RESET);
      }
      osalSysUnlockFromISR();
    }
#endif
    usbp->epc[i] = NULL;
 8001efa:	f04f 0500 	mov.w	r5, #0
  usbp->configuration = 0;
  usbp->transmitting  = 0;
  usbp->receiving     = 0;

  /* Invalidates all endpoints into the USBDriver structure.*/
  for (i = 0; i <= (unsigned)USB_MAX_ENDPOINTS; i++) {
 8001efe:	d1f9      	bne.n	8001ef4 <_usb_reset+0x24>
#endif
    usbp->epc[i] = NULL;
  }

  /* EP0 state machine initialization.*/
  usbp->ep0state = USB_EP0_WAITING_SETUP;
 8001f00:	f884 5064 	strb.w	r5, [r4, #100]	; 0x64

  /* Low level reset.*/
  usb_lld_reset(usbp);
 8001f04:	4620      	mov	r0, r4
 8001f06:	f001 f96b 	bl	80031e0 <usb_lld_reset>

  /* Notification of reset event.*/
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_RESET);
 8001f0a:	6863      	ldr	r3, [r4, #4]
 8001f0c:	681b      	ldr	r3, [r3, #0]
 8001f0e:	b123      	cbz	r3, 8001f1a <_usb_reset+0x4a>
 8001f10:	4620      	mov	r0, r4
 8001f12:	4629      	mov	r1, r5
}
 8001f14:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}

  /* Low level reset.*/
  usb_lld_reset(usbp);

  /* Notification of reset event.*/
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_RESET);
 8001f18:	4718      	bx	r3
 8001f1a:	bd70      	pop	{r4, r5, r6, pc}
 8001f1c:	0000      	movs	r0, r0
	...

08001f20 <_usb_suspend>:
  /* State transition.*/
  usbp->saved_state = usbp->state;
  usbp->state       = USB_SUSPENDED;

  /* Notification of suspend event.*/
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_SUSPEND);
 8001f20:	6842      	ldr	r2, [r0, #4]
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
void _usb_suspend(USBDriver *usbp) {
 8001f22:	b410      	push	{r4}
  /* State transition.*/
  usbp->saved_state = usbp->state;
  usbp->state       = USB_SUSPENDED;

  /* Notification of suspend event.*/
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_SUSPEND);
 8001f24:	6812      	ldr	r2, [r2, #0]
 */
void _usb_suspend(USBDriver *usbp) {
  /* No state change, suspend always returns to previous state. */

  /* State transition.*/
  usbp->saved_state = usbp->state;
 8001f26:	7804      	ldrb	r4, [r0, #0]
  usbp->state       = USB_SUSPENDED;
 8001f28:	2105      	movs	r1, #5
 */
void _usb_suspend(USBDriver *usbp) {
  /* No state change, suspend always returns to previous state. */

  /* State transition.*/
  usbp->saved_state = usbp->state;
 8001f2a:	f880 4080 	strb.w	r4, [r0, #128]	; 0x80
  usbp->state       = USB_SUSPENDED;
 8001f2e:	7001      	strb	r1, [r0, #0]

  /* Notification of suspend event.*/
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_SUSPEND);
 8001f30:	b11a      	cbz	r2, 8001f3a <_usb_suspend+0x1a>
 8001f32:	2104      	movs	r1, #4
        osalSysUnlockFromISR();
      }
    }
  }
#endif
}
 8001f34:	f85d 4b04 	ldr.w	r4, [sp], #4
  /* State transition.*/
  usbp->saved_state = usbp->state;
  usbp->state       = USB_SUSPENDED;

  /* Notification of suspend event.*/
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_SUSPEND);
 8001f38:	4710      	bx	r2
        osalSysUnlockFromISR();
      }
    }
  }
#endif
}
 8001f3a:	f85d 4b04 	ldr.w	r4, [sp], #4
 8001f3e:	4770      	bx	lr

08001f40 <_usb_wakeup>:

  /* State transition, returning to the previous state.*/
  usbp->state = usbp->saved_state;

  /* Notification of suspend event.*/
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_WAKEUP);
 8001f40:	6842      	ldr	r2, [r0, #4]
 * @notapi
 */
void _usb_wakeup(USBDriver *usbp) {

  /* State transition, returning to the previous state.*/
  usbp->state = usbp->saved_state;
 8001f42:	f890 1080 	ldrb.w	r1, [r0, #128]	; 0x80

  /* Notification of suspend event.*/
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_WAKEUP);
 8001f46:	6812      	ldr	r2, [r2, #0]
 * @notapi
 */
void _usb_wakeup(USBDriver *usbp) {

  /* State transition, returning to the previous state.*/
  usbp->state = usbp->saved_state;
 8001f48:	7001      	strb	r1, [r0, #0]

  /* Notification of suspend event.*/
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_WAKEUP);
 8001f4a:	b10a      	cbz	r2, 8001f50 <_usb_wakeup+0x10>
 8001f4c:	2105      	movs	r1, #5
 8001f4e:	4710      	bx	r2
 8001f50:	4770      	bx	lr
 8001f52:	bf00      	nop
	...

08001f60 <_usb_ep0setup>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number, always zero
 *
 * @notapi
 */
void _usb_ep0setup(USBDriver *usbp, usbep_t ep) {
 8001f60:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8001f62:	4604      	mov	r4, r0
  size_t max;

  usbp->ep0state = USB_EP0_WAITING_SETUP;
 8001f64:	2300      	movs	r3, #0
 8001f66:	f880 3064 	strb.w	r3, [r0, #100]	; 0x64
  usbReadSetup(usbp, ep, usbp->setup);
 8001f6a:	f100 0274 	add.w	r2, r0, #116	; 0x74
 8001f6e:	f001 f99f 	bl	80032b0 <usb_lld_read_setup>

  /* First verify if the application has an handler installed for this
     request.*/
  /*lint -save -e9007 [13.5] No side effects, it is intentional.*/
  if ((usbp->config->requests_hook_cb == NULL) ||
 8001f72:	6863      	ldr	r3, [r4, #4]
 8001f74:	689b      	ldr	r3, [r3, #8]
 8001f76:	b313      	cbz	r3, 8001fbe <_usb_ep0setup+0x5e>
      !(usbp->config->requests_hook_cb(usbp))) {
 8001f78:	4620      	mov	r0, r4
 8001f7a:	4798      	blx	r3
  usbReadSetup(usbp, ep, usbp->setup);

  /* First verify if the application has an handler installed for this
     request.*/
  /*lint -save -e9007 [13.5] No side effects, it is intentional.*/
  if ((usbp->config->requests_hook_cb == NULL) ||
 8001f7c:	b1f8      	cbz	r0, 8001fbe <_usb_ep0setup+0x5e>
 8001f7e:	6ee5      	ldr	r5, [r4, #108]	; 0x6c
 8001f80:	f894 3074 	ldrb.w	r3, [r4, #116]	; 0x74

static uint16_t get_hword(uint8_t *p) {
  uint16_t hw;

  hw  = (uint16_t)*p++;
  hw |= (uint16_t)*p << 8U;
 8001f84:	f894 107b 	ldrb.w	r1, [r4, #123]	; 0x7b
 8001f88:	f894 207a 	ldrb.w	r2, [r4, #122]	; 0x7a
  }
#endif
  /* Transfer preparation. The request handler must have populated
     correctly the fields ep0next, ep0n and ep0endcb using the macro
     usbSetupTransfer().*/
  max = (size_t)get_hword(&usbp->setup[6]);
 8001f8c:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
  /* The transfer size cannot exceed the specified amount.*/
  if (usbp->ep0n > max) {
 8001f90:	42aa      	cmp	r2, r5
    usbp->ep0n = max;
 8001f92:	bf3c      	itt	cc
 8001f94:	4615      	movcc	r5, r2
 8001f96:	66e2      	strcc	r2, [r4, #108]	; 0x6c
  }
  if ((usbp->setup[0] & USB_RTYPE_DIR_MASK) == USB_RTYPE_DIR_DEV2HOST) {
 8001f98:	061b      	lsls	r3, r3, #24
 8001f9a:	d47a      	bmi.n	8002092 <_usb_ep0setup+0x132>
#endif
    }
  }
  else {
    /* OUT phase.*/
    if (usbp->ep0n != 0U) {
 8001f9c:	2d00      	cmp	r5, #0
 8001f9e:	d168      	bne.n	8002072 <_usb_ep0setup+0x112>
      osalSysUnlockFromISR();
    }
    else {
      /* No receive phase, directly sending the zero sized status
         packet.*/
      usbp->ep0state = USB_EP0_SENDING_STS;
 8001fa0:	2305      	movs	r3, #5
 8001fa2:	f884 3064 	strb.w	r3, [r4, #100]	; 0x64
 8001fa6:	2320      	movs	r3, #32
 8001fa8:	f383 8811 	msr	BASEPRI, r3
#if (USB_EP0_STATUS_STAGE == USB_EP0_STATUS_STAGE_SW)
      osalSysLockFromISR();
      usbStartTransmitI(usbp, 0, NULL, 0);
 8001fac:	4620      	mov	r0, r4
 8001fae:	4629      	mov	r1, r5
 8001fb0:	462a      	mov	r2, r5
 8001fb2:	462b      	mov	r3, r5
 8001fb4:	f7ff ff74 	bl	8001ea0 <usbStartTransmitI>
 8001fb8:	f385 8811 	msr	BASEPRI, r5
 8001fbc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      !(usbp->config->requests_hook_cb(usbp))) {
  /*lint -restore*/
    /* Invoking the default handler, if this fails then stalls the
       endpoint zero as error.*/
    /*lint -save -e9007 [13.5] No side effects, it is intentional.*/
    if (((usbp->setup[0] & USB_RTYPE_TYPE_MASK) != USB_RTYPE_TYPE_STD) ||
 8001fbe:	f894 3074 	ldrb.w	r3, [r4, #116]	; 0x74
 8001fc2:	f013 0760 	ands.w	r7, r3, #96	; 0x60
 8001fc6:	d011      	beq.n	8001fec <_usb_ep0setup+0x8c>
        !default_handler(usbp)) {
    /*lint -restore*/
      /* Error response, the state machine goes into an error state, the low
         level layer will have to reset it to USB_EP0_WAITING_SETUP after
         receiving a SETUP packet.*/
      usb_lld_stall_in(usbp, 0);
 8001fc8:	4620      	mov	r0, r4
 8001fca:	2100      	movs	r1, #0
 8001fcc:	f001 f9f8 	bl	80033c0 <usb_lld_stall_in>
      usb_lld_stall_out(usbp, 0);
 8001fd0:	4620      	mov	r0, r4
 8001fd2:	2100      	movs	r1, #0
 8001fd4:	f001 f9dc 	bl	8003390 <usb_lld_stall_out>
      _usb_isr_invoke_event_cb(usbp, USB_EVENT_STALLED);
 8001fd8:	6863      	ldr	r3, [r4, #4]
 8001fda:	681b      	ldr	r3, [r3, #0]
 8001fdc:	b113      	cbz	r3, 8001fe4 <_usb_ep0setup+0x84>
 8001fde:	4620      	mov	r0, r4
 8001fe0:	2106      	movs	r1, #6
 8001fe2:	4798      	blx	r3
      usbp->ep0state = USB_EP0_ERROR;
 8001fe4:	2306      	movs	r3, #6
 8001fe6:	f884 3064 	strb.w	r3, [r4, #100]	; 0x64
      return;
 8001fea:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  const USBDescriptor *dp;

  /* Decoding the request.*/
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
                                        USB_RTYPE_TYPE_MASK)) |
           ((uint32_t)usbp->setup[1] << 8U))) {
 8001fec:	f894 5075 	ldrb.w	r5, [r4, #117]	; 0x75
 */
static bool default_handler(USBDriver *usbp) {
  const USBDescriptor *dp;

  /* Decoding the request.*/
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 8001ff0:	f003 027f 	and.w	r2, r3, #127	; 0x7f
                                        USB_RTYPE_TYPE_MASK)) |
 8001ff4:	ea42 2605 	orr.w	r6, r2, r5, lsl #8
 */
static bool default_handler(USBDriver *usbp) {
  const USBDescriptor *dp;

  /* Decoding the request.*/
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 8001ff8:	f5b6 7f40 	cmp.w	r6, #768	; 0x300
 8001ffc:	f000 8104 	beq.w	8002208 <_usb_ep0setup+0x2a8>
 8002000:	d916      	bls.n	8002030 <_usb_ep0setup+0xd0>
 8002002:	f5b6 6fc0 	cmp.w	r6, #1536	; 0x600
 8002006:	f000 80e6 	beq.w	80021d6 <_usb_ep0setup+0x276>
 800200a:	d962      	bls.n	80020d2 <_usb_ep0setup+0x172>
 800200c:	f5b6 6f10 	cmp.w	r6, #2304	; 0x900
 8002010:	d06d      	beq.n	80020ee <_usb_ep0setup+0x18e>
 8002012:	f640 4202 	movw	r2, #3074	; 0xc02
 8002016:	4296      	cmp	r6, r2
 8002018:	f000 80d6 	beq.w	80021c8 <_usb_ep0setup+0x268>
 800201c:	f5b6 6f00 	cmp.w	r6, #2048	; 0x800
 8002020:	d1d2      	bne.n	8001fc8 <_usb_ep0setup+0x68>
    usbSetupTransfer(usbp, (uint8_t *)dp->ud_string, dp->ud_size, NULL);
    /*lint -restore*/
    return true;
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_GET_CONFIGURATION << 8):
    /* Returning the last selected configuration.*/
    usbSetupTransfer(usbp, &usbp->configuration, 1, NULL);
 8002022:	f104 027f 	add.w	r2, r4, #127	; 0x7f
 8002026:	2501      	movs	r5, #1
 8002028:	6727      	str	r7, [r4, #112]	; 0x70
 800202a:	66a2      	str	r2, [r4, #104]	; 0x68
 800202c:	66e5      	str	r5, [r4, #108]	; 0x6c
 800202e:	e7a9      	b.n	8001f84 <_usb_ep0setup+0x24>
 */
static bool default_handler(USBDriver *usbp) {
  const USBDescriptor *dp;

  /* Decoding the request.*/
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 8002030:	2e02      	cmp	r6, #2
 8002032:	f000 80af 	beq.w	8002194 <_usb_ep0setup+0x234>
 8002036:	f240 80a5 	bls.w	8002184 <_usb_ep0setup+0x224>
 800203a:	f5b6 7f80 	cmp.w	r6, #256	; 0x100
 800203e:	d06b      	beq.n	8002118 <_usb_ep0setup+0x1b8>
 8002040:	f5b6 7f81 	cmp.w	r6, #258	; 0x102
 8002044:	d1c0      	bne.n	8001fc8 <_usb_ep0setup+0x68>
        return false;
      }
    }
  case (uint32_t)USB_RTYPE_RECIPIENT_ENDPOINT | ((uint32_t)USB_REQ_CLEAR_FEATURE << 8):
    /* Only ENDPOINT_HALT is handled as feature.*/
    if (usbp->setup[2] != USB_FEATURE_ENDPOINT_HALT) {
 8002046:	f894 2076 	ldrb.w	r2, [r4, #118]	; 0x76
 800204a:	2a00      	cmp	r2, #0
 800204c:	d1bc      	bne.n	8001fc8 <_usb_ep0setup+0x68>
      return false;
    }
    /* Clearing the EP status, not valid for EP0, it is ignored in that case.*/
    if ((usbp->setup[4] & 0x0FU) != 0U) {
 800204e:	f894 2078 	ldrb.w	r2, [r4, #120]	; 0x78
 8002052:	f012 010f 	ands.w	r1, r2, #15
 8002056:	d007      	beq.n	8002068 <_usb_ep0setup+0x108>
      if ((usbp->setup[4] & 0x80U) != 0U) {
 8002058:	0615      	lsls	r5, r2, #24
        usb_lld_clear_in(usbp, usbp->setup[4] & 0x0FU);
 800205a:	4620      	mov	r0, r4
    if (usbp->setup[2] != USB_FEATURE_ENDPOINT_HALT) {
      return false;
    }
    /* Clearing the EP status, not valid for EP0, it is ignored in that case.*/
    if ((usbp->setup[4] & 0x0FU) != 0U) {
      if ((usbp->setup[4] & 0x80U) != 0U) {
 800205c:	f100 80f0 	bmi.w	8002240 <_usb_ep0setup+0x2e0>
        usb_lld_clear_in(usbp, usbp->setup[4] & 0x0FU);
      }
      else {
        usb_lld_clear_out(usbp, usbp->setup[4] & 0x0FU);
 8002060:	f001 f9c6 	bl	80033f0 <usb_lld_clear_out>
 8002064:	f894 3074 	ldrb.w	r3, [r4, #116]	; 0x74
      }
      else {
        usb_lld_stall_out(usbp, usbp->setup[4] & 0x0FU);
      }
    }
    usbSetupTransfer(usbp, NULL, 0, NULL);
 8002068:	2500      	movs	r5, #0
 800206a:	66a5      	str	r5, [r4, #104]	; 0x68
 800206c:	66e5      	str	r5, [r4, #108]	; 0x6c
 800206e:	6725      	str	r5, [r4, #112]	; 0x70
 8002070:	e788      	b.n	8001f84 <_usb_ep0setup+0x24>
  }
  else {
    /* OUT phase.*/
    if (usbp->ep0n != 0U) {
      /* Starts the receive phase.*/
      usbp->ep0state = USB_EP0_RX;
 8002072:	2304      	movs	r3, #4
 8002074:	f884 3064 	strb.w	r3, [r4, #100]	; 0x64
 8002078:	2320      	movs	r3, #32
 800207a:	f383 8811 	msr	BASEPRI, r3
      osalSysLockFromISR();
      usbStartReceiveI(usbp, 0, usbp->ep0next, usbp->ep0n);
 800207e:	2100      	movs	r1, #0
 8002080:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
 8002082:	4620      	mov	r0, r4
 8002084:	6ea2      	ldr	r2, [r4, #104]	; 0x68
 8002086:	f7ff fef3 	bl	8001e70 <usbStartReceiveI>
 800208a:	2300      	movs	r3, #0
 800208c:	f383 8811 	msr	BASEPRI, r3
 8002090:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  if (usbp->ep0n > max) {
    usbp->ep0n = max;
  }
  if ((usbp->setup[0] & USB_RTYPE_DIR_MASK) == USB_RTYPE_DIR_DEV2HOST) {
    /* IN phase.*/
    if (usbp->ep0n != 0U) {
 8002092:	b17d      	cbz	r5, 80020b4 <_usb_ep0setup+0x154>
      /* Starts the transmit phase.*/
      usbp->ep0state = USB_EP0_TX;
 8002094:	2301      	movs	r3, #1
 8002096:	f884 3064 	strb.w	r3, [r4, #100]	; 0x64
 800209a:	2320      	movs	r3, #32
 800209c:	f383 8811 	msr	BASEPRI, r3
      osalSysLockFromISR();
      usbStartTransmitI(usbp, 0, usbp->ep0next, usbp->ep0n);
 80020a0:	2100      	movs	r1, #0
 80020a2:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
 80020a4:	4620      	mov	r0, r4
 80020a6:	6ea2      	ldr	r2, [r4, #104]	; 0x68
 80020a8:	f7ff fefa 	bl	8001ea0 <usbStartTransmitI>
 80020ac:	2300      	movs	r3, #0
 80020ae:	f383 8811 	msr	BASEPRI, r3
 80020b2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      osalSysUnlockFromISR();
    }
    else {
      /* No transmission phase, directly receiving the zero sized status
         packet.*/
      usbp->ep0state = USB_EP0_WAITING_STS;
 80020b4:	2303      	movs	r3, #3
 80020b6:	f884 3064 	strb.w	r3, [r4, #100]	; 0x64
 80020ba:	2320      	movs	r3, #32
 80020bc:	f383 8811 	msr	BASEPRI, r3
#if (USB_EP0_STATUS_STAGE == USB_EP0_STATUS_STAGE_SW)
      osalSysLockFromISR();
      usbStartReceiveI(usbp, 0, NULL, 0);
 80020c0:	4620      	mov	r0, r4
 80020c2:	4629      	mov	r1, r5
 80020c4:	462a      	mov	r2, r5
 80020c6:	462b      	mov	r3, r5
 80020c8:	f7ff fed2 	bl	8001e70 <usbStartReceiveI>
 80020cc:	f385 8811 	msr	BASEPRI, r5
 80020d0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 */
static bool default_handler(USBDriver *usbp) {
  const USBDescriptor *dp;

  /* Decoding the request.*/
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 80020d2:	f240 3202 	movw	r2, #770	; 0x302
 80020d6:	4296      	cmp	r6, r2
 80020d8:	d02e      	beq.n	8002138 <_usb_ep0setup+0x1d8>
 80020da:	f5b6 6fa0 	cmp.w	r6, #1280	; 0x500
 80020de:	f47f af73 	bne.w	8001fc8 <_usb_ep0setup+0x68>
        (usbp->setup[1] == USB_REQ_SET_ADDRESS)) {
      set_address(usbp);
    }
    usbSetupTransfer(usbp, NULL, 0, NULL);
#else
    usbSetupTransfer(usbp, NULL, 0, set_address);
 80020e2:	4a5c      	ldr	r2, [pc, #368]	; (8002254 <_usb_ep0setup+0x2f4>)
 80020e4:	66a7      	str	r7, [r4, #104]	; 0x68
 80020e6:	66e7      	str	r7, [r4, #108]	; 0x6c
 80020e8:	463d      	mov	r5, r7
 80020ea:	6722      	str	r2, [r4, #112]	; 0x70
 80020ec:	e74a      	b.n	8001f84 <_usb_ep0setup+0x24>
    usbSetupTransfer(usbp, &usbp->configuration, 1, NULL);
    return true;
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_SET_CONFIGURATION << 8):
    /* Handling configuration selection from the host only if it is different
       from the current configuration.*/
    if (usbp->configuration != usbp->setup[2]) {
 80020ee:	f894 2076 	ldrb.w	r2, [r4, #118]	; 0x76
 80020f2:	f894 107f 	ldrb.w	r1, [r4, #127]	; 0x7f
 80020f6:	4291      	cmp	r1, r2
 80020f8:	d0b6      	beq.n	8002068 <_usb_ep0setup+0x108>
      /* If the USB device is already active then we have to perform the clear
         procedure on the current configuration.*/
      if (usbp->state == USB_ACTIVE) {
 80020fa:	7823      	ldrb	r3, [r4, #0]
 80020fc:	2b04      	cmp	r3, #4
 80020fe:	d02d      	beq.n	800215c <_usb_ep0setup+0x1fc>
        chSysUnlockFromISR ();
        usbp->configuration = 0U;
        usbp->state = USB_SELECTED;
        _usb_isr_invoke_event_cb(usbp, USB_EVENT_UNCONFIGURED);
      }
      if (usbp->setup[2] != 0U) {
 8002100:	b34a      	cbz	r2, 8002156 <_usb_ep0setup+0x1f6>
        /* New configuration.*/
        usbp->configuration = usbp->setup[2];
        usbp->state = USB_ACTIVE;
        _usb_isr_invoke_event_cb(usbp, USB_EVENT_CONFIGURED);
 8002102:	6863      	ldr	r3, [r4, #4]
        usbp->state = USB_SELECTED;
        _usb_isr_invoke_event_cb(usbp, USB_EVENT_UNCONFIGURED);
      }
      if (usbp->setup[2] != 0U) {
        /* New configuration.*/
        usbp->configuration = usbp->setup[2];
 8002104:	f884 207f 	strb.w	r2, [r4, #127]	; 0x7f
        usbp->state = USB_ACTIVE;
        _usb_isr_invoke_event_cb(usbp, USB_EVENT_CONFIGURED);
 8002108:	681b      	ldr	r3, [r3, #0]
        _usb_isr_invoke_event_cb(usbp, USB_EVENT_UNCONFIGURED);
      }
      if (usbp->setup[2] != 0U) {
        /* New configuration.*/
        usbp->configuration = usbp->setup[2];
        usbp->state = USB_ACTIVE;
 800210a:	2204      	movs	r2, #4
 800210c:	7022      	strb	r2, [r4, #0]
        _usb_isr_invoke_event_cb(usbp, USB_EVENT_CONFIGURED);
 800210e:	b313      	cbz	r3, 8002156 <_usb_ep0setup+0x1f6>
 8002110:	4620      	mov	r0, r4
 8002112:	2102      	movs	r1, #2
 8002114:	4798      	blx	r3
 8002116:	e01e      	b.n	8002156 <_usb_ep0setup+0x1f6>
    usbSetupTransfer(usbp, (uint8_t *)&usbp->status, 2, NULL);
    return true;
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_CLEAR_FEATURE << 8):
    /* Only the DEVICE_REMOTE_WAKEUP is handled here, any other feature
       number is handled as an error.*/
    if (usbp->setup[2] == USB_FEATURE_DEVICE_REMOTE_WAKEUP) {
 8002118:	f894 2076 	ldrb.w	r2, [r4, #118]	; 0x76
 800211c:	2a01      	cmp	r2, #1
 800211e:	f47f af53 	bne.w	8001fc8 <_usb_ep0setup+0x68>
      usbp->status &= ~2U;
 8002122:	f8b4 207c 	ldrh.w	r2, [r4, #124]	; 0x7c
      usbSetupTransfer(usbp, NULL, 0, NULL);
 8002126:	66a7      	str	r7, [r4, #104]	; 0x68
    return true;
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_CLEAR_FEATURE << 8):
    /* Only the DEVICE_REMOTE_WAKEUP is handled here, any other feature
       number is handled as an error.*/
    if (usbp->setup[2] == USB_FEATURE_DEVICE_REMOTE_WAKEUP) {
      usbp->status &= ~2U;
 8002128:	f022 0202 	bic.w	r2, r2, #2
      usbSetupTransfer(usbp, NULL, 0, NULL);
 800212c:	66e7      	str	r7, [r4, #108]	; 0x6c
 800212e:	6727      	str	r7, [r4, #112]	; 0x70
 8002130:	463d      	mov	r5, r7
    return true;
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_CLEAR_FEATURE << 8):
    /* Only the DEVICE_REMOTE_WAKEUP is handled here, any other feature
       number is handled as an error.*/
    if (usbp->setup[2] == USB_FEATURE_DEVICE_REMOTE_WAKEUP) {
      usbp->status &= ~2U;
 8002132:	f8a4 207c 	strh.w	r2, [r4, #124]	; 0x7c
 8002136:	e725      	b.n	8001f84 <_usb_ep0setup+0x24>
    }
    usbSetupTransfer(usbp, NULL, 0, NULL);
    return true;
  case (uint32_t)USB_RTYPE_RECIPIENT_ENDPOINT | ((uint32_t)USB_REQ_SET_FEATURE << 8):
    /* Only ENDPOINT_HALT is handled as feature.*/
    if (usbp->setup[2] != USB_FEATURE_ENDPOINT_HALT) {
 8002138:	f894 2076 	ldrb.w	r2, [r4, #118]	; 0x76
 800213c:	2a00      	cmp	r2, #0
 800213e:	f47f af43 	bne.w	8001fc8 <_usb_ep0setup+0x68>
      return false;
    }
    /* Stalling the EP, not valid for EP0, it is ignored in that case.*/
    if ((usbp->setup[4] & 0x0FU) != 0U) {
 8002142:	f894 2078 	ldrb.w	r2, [r4, #120]	; 0x78
 8002146:	f012 010f 	ands.w	r1, r2, #15
 800214a:	d08d      	beq.n	8002068 <_usb_ep0setup+0x108>
      if ((usbp->setup[4] & 0x80U) != 0U) {
 800214c:	0612      	lsls	r2, r2, #24
        usb_lld_stall_in(usbp, usbp->setup[4] & 0x0FU);
 800214e:	4620      	mov	r0, r4
    if (usbp->setup[2] != USB_FEATURE_ENDPOINT_HALT) {
      return false;
    }
    /* Stalling the EP, not valid for EP0, it is ignored in that case.*/
    if ((usbp->setup[4] & 0x0FU) != 0U) {
      if ((usbp->setup[4] & 0x80U) != 0U) {
 8002150:	d47b      	bmi.n	800224a <_usb_ep0setup+0x2ea>
        usb_lld_stall_in(usbp, usbp->setup[4] & 0x0FU);
      }
      else {
        usb_lld_stall_out(usbp, usbp->setup[4] & 0x0FU);
 8002152:	f001 f91d 	bl	8003390 <usb_lld_stall_out>
 8002156:	f894 3074 	ldrb.w	r3, [r4, #116]	; 0x74
 800215a:	e785      	b.n	8002068 <_usb_ep0setup+0x108>
 800215c:	2320      	movs	r3, #32
 800215e:	f383 8811 	msr	BASEPRI, r3
      /* If the USB device is already active then we have to perform the clear
         procedure on the current configuration.*/
      if (usbp->state == USB_ACTIVE) {
        /* Current configuration cleared.*/
        chSysLockFromISR ();
        usbDisableEndpointsI(usbp);
 8002162:	4620      	mov	r0, r4
 8002164:	f7ff fe6c 	bl	8001e40 <usbDisableEndpointsI>
 8002168:	f387 8811 	msr	BASEPRI, r7
        chSysUnlockFromISR ();
        usbp->configuration = 0U;
        usbp->state = USB_SELECTED;
        _usb_isr_invoke_event_cb(usbp, USB_EVENT_UNCONFIGURED);
 800216c:	6863      	ldr	r3, [r4, #4]
      if (usbp->state == USB_ACTIVE) {
        /* Current configuration cleared.*/
        chSysLockFromISR ();
        usbDisableEndpointsI(usbp);
        chSysUnlockFromISR ();
        usbp->configuration = 0U;
 800216e:	f884 707f 	strb.w	r7, [r4, #127]	; 0x7f
        usbp->state = USB_SELECTED;
        _usb_isr_invoke_event_cb(usbp, USB_EVENT_UNCONFIGURED);
 8002172:	681b      	ldr	r3, [r3, #0]
        /* Current configuration cleared.*/
        chSysLockFromISR ();
        usbDisableEndpointsI(usbp);
        chSysUnlockFromISR ();
        usbp->configuration = 0U;
        usbp->state = USB_SELECTED;
 8002174:	2103      	movs	r1, #3
 8002176:	7021      	strb	r1, [r4, #0]
        _usb_isr_invoke_event_cb(usbp, USB_EVENT_UNCONFIGURED);
 8002178:	b10b      	cbz	r3, 800217e <_usb_ep0setup+0x21e>
 800217a:	4620      	mov	r0, r4
 800217c:	4798      	blx	r3
 800217e:	f894 2076 	ldrb.w	r2, [r4, #118]	; 0x76
 8002182:	e7bd      	b.n	8002100 <_usb_ep0setup+0x1a0>
 */
static bool default_handler(USBDriver *usbp) {
  const USBDescriptor *dp;

  /* Decoding the request.*/
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 8002184:	b9ee      	cbnz	r6, 80021c2 <_usb_ep0setup+0x262>
                                        USB_RTYPE_TYPE_MASK)) |
           ((uint32_t)usbp->setup[1] << 8U))) {
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_GET_STATUS << 8):
    /* Just returns the current status word.*/
    usbSetupTransfer(usbp, (uint8_t *)&usbp->status, 2, NULL);
 8002186:	f104 027c 	add.w	r2, r4, #124	; 0x7c
 800218a:	2502      	movs	r5, #2
 800218c:	6726      	str	r6, [r4, #112]	; 0x70
 800218e:	66a2      	str	r2, [r4, #104]	; 0x68
 8002190:	66e5      	str	r5, [r4, #108]	; 0x6c
 8002192:	e6f7      	b.n	8001f84 <_usb_ep0setup+0x24>
    usbSetupTransfer(usbp, (uint8_t *)zero_status, 2, NULL);
    /*lint -restore*/
    return true;
  case (uint32_t)USB_RTYPE_RECIPIENT_ENDPOINT | ((uint32_t)USB_REQ_GET_STATUS << 8):
    /* Sending the EP status.*/
    if ((usbp->setup[4] & 0x80U) != 0U) {
 8002194:	f894 1078 	ldrb.w	r1, [r4, #120]	; 0x78
      switch (usb_lld_get_status_in(usbp, usbp->setup[4] & 0x0FU)) {
 8002198:	4620      	mov	r0, r4
    usbSetupTransfer(usbp, (uint8_t *)zero_status, 2, NULL);
    /*lint -restore*/
    return true;
  case (uint32_t)USB_RTYPE_RECIPIENT_ENDPOINT | ((uint32_t)USB_REQ_GET_STATUS << 8):
    /* Sending the EP status.*/
    if ((usbp->setup[4] & 0x80U) != 0U) {
 800219a:	f011 0f80 	tst.w	r1, #128	; 0x80
      switch (usb_lld_get_status_in(usbp, usbp->setup[4] & 0x0FU)) {
 800219e:	f001 010f 	and.w	r1, r1, #15
    usbSetupTransfer(usbp, (uint8_t *)zero_status, 2, NULL);
    /*lint -restore*/
    return true;
  case (uint32_t)USB_RTYPE_RECIPIENT_ENDPOINT | ((uint32_t)USB_REQ_GET_STATUS << 8):
    /* Sending the EP status.*/
    if ((usbp->setup[4] & 0x80U) != 0U) {
 80021a2:	d141      	bne.n	8002228 <_usb_ep0setup+0x2c8>
      default:
        return false;
      }
    }
    else {
      switch (usb_lld_get_status_out(usbp, usbp->setup[4] & 0x0FU)) {
 80021a4:	f001 f864 	bl	8003270 <usb_lld_get_status_out>
 80021a8:	2801      	cmp	r0, #1
 80021aa:	d041      	beq.n	8002230 <_usb_ep0setup+0x2d0>
 80021ac:	2802      	cmp	r0, #2
 80021ae:	f47f af0b 	bne.w	8001fc8 <_usb_ep0setup+0x68>
        usbSetupTransfer(usbp, (uint8_t *)halted_status, 2, NULL);
        /*lint -restore*/
        return true;
      case EP_STATUS_ACTIVE:
        /*lint -save -e9005 [11.8] Removing const is fine.*/
        usbSetupTransfer(usbp, (uint8_t *)active_status, 2, NULL);
 80021b2:	4b29      	ldr	r3, [pc, #164]	; (8002258 <_usb_ep0setup+0x2f8>)
 80021b4:	66e0      	str	r0, [r4, #108]	; 0x6c
 80021b6:	66a3      	str	r3, [r4, #104]	; 0x68
 80021b8:	6727      	str	r7, [r4, #112]	; 0x70
 80021ba:	4605      	mov	r5, r0
 80021bc:	f894 3074 	ldrb.w	r3, [r4, #116]	; 0x74
 80021c0:	e6e0      	b.n	8001f84 <_usb_ep0setup+0x24>
 */
static bool default_handler(USBDriver *usbp) {
  const USBDescriptor *dp;

  /* Decoding the request.*/
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 80021c2:	2e01      	cmp	r6, #1
 80021c4:	f47f af00 	bne.w	8001fc8 <_usb_ep0setup+0x68>
  case (uint32_t)USB_RTYPE_RECIPIENT_INTERFACE | ((uint32_t)USB_REQ_GET_STATUS << 8):
  case (uint32_t)USB_RTYPE_RECIPIENT_ENDPOINT | ((uint32_t)USB_REQ_SYNCH_FRAME << 8):
    /* Just sending two zero bytes, the application can change the behavior
       using a hook..*/
    /*lint -save -e9005 [11.8] Removing const is fine.*/
    usbSetupTransfer(usbp, (uint8_t *)zero_status, 2, NULL);
 80021c8:	4924      	ldr	r1, [pc, #144]	; (800225c <_usb_ep0setup+0x2fc>)
 80021ca:	2502      	movs	r5, #2
 80021cc:	2200      	movs	r2, #0
 80021ce:	66a1      	str	r1, [r4, #104]	; 0x68
 80021d0:	66e5      	str	r5, [r4, #108]	; 0x6c
 80021d2:	6722      	str	r2, [r4, #112]	; 0x70
 80021d4:	e6d6      	b.n	8001f84 <_usb_ep0setup+0x24>
    usbSetupTransfer(usbp, NULL, 0, set_address);
#endif
    return true;
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_GET_DESCRIPTOR << 8):
    /* Handling descriptor requests from the host.*/
    dp = usbp->config->get_descriptor_cb(usbp, usbp->setup[3],
 80021d6:	6861      	ldr	r1, [r4, #4]

static uint16_t get_hword(uint8_t *p) {
  uint16_t hw;

  hw  = (uint16_t)*p++;
  hw |= (uint16_t)*p << 8U;
 80021d8:	f894 2079 	ldrb.w	r2, [r4, #121]	; 0x79
 80021dc:	f894 3078 	ldrb.w	r3, [r4, #120]	; 0x78
    usbSetupTransfer(usbp, NULL, 0, set_address);
#endif
    return true;
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_GET_DESCRIPTOR << 8):
    /* Handling descriptor requests from the host.*/
    dp = usbp->config->get_descriptor_cb(usbp, usbp->setup[3],
 80021e0:	684d      	ldr	r5, [r1, #4]
 80021e2:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 80021e6:	4620      	mov	r0, r4
 80021e8:	f894 1077 	ldrb.w	r1, [r4, #119]	; 0x77
 80021ec:	f894 2076 	ldrb.w	r2, [r4, #118]	; 0x76
 80021f0:	47a8      	blx	r5
                                         usbp->setup[2],
                                         get_hword(&usbp->setup[4]));
    if (dp == NULL) {
 80021f2:	2800      	cmp	r0, #0
 80021f4:	f43f aee8 	beq.w	8001fc8 <_usb_ep0setup+0x68>
      return false;
    }
    /*lint -save -e9005 [11.8] Removing const is fine.*/
    usbSetupTransfer(usbp, (uint8_t *)dp->ud_string, dp->ud_size, NULL);
 80021f8:	6843      	ldr	r3, [r0, #4]
 80021fa:	6805      	ldr	r5, [r0, #0]
 80021fc:	66a3      	str	r3, [r4, #104]	; 0x68
 80021fe:	66e5      	str	r5, [r4, #108]	; 0x6c
 8002200:	6727      	str	r7, [r4, #112]	; 0x70
 8002202:	f894 3074 	ldrb.w	r3, [r4, #116]	; 0x74
 8002206:	e6bd      	b.n	8001f84 <_usb_ep0setup+0x24>
    }
    return false;
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_SET_FEATURE << 8):
    /* Only the DEVICE_REMOTE_WAKEUP is handled here, any other feature
       number is handled as an error.*/
    if (usbp->setup[2] == USB_FEATURE_DEVICE_REMOTE_WAKEUP) {
 8002208:	f894 2076 	ldrb.w	r2, [r4, #118]	; 0x76
 800220c:	2a01      	cmp	r2, #1
 800220e:	f47f aedb 	bne.w	8001fc8 <_usb_ep0setup+0x68>
      usbp->status |= 2U;
 8002212:	f8b4 207c 	ldrh.w	r2, [r4, #124]	; 0x7c
      usbSetupTransfer(usbp, NULL, 0, NULL);
 8002216:	66a7      	str	r7, [r4, #104]	; 0x68
    return false;
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_SET_FEATURE << 8):
    /* Only the DEVICE_REMOTE_WAKEUP is handled here, any other feature
       number is handled as an error.*/
    if (usbp->setup[2] == USB_FEATURE_DEVICE_REMOTE_WAKEUP) {
      usbp->status |= 2U;
 8002218:	f042 0202 	orr.w	r2, r2, #2
      usbSetupTransfer(usbp, NULL, 0, NULL);
 800221c:	66e7      	str	r7, [r4, #108]	; 0x6c
 800221e:	6727      	str	r7, [r4, #112]	; 0x70
 8002220:	463d      	mov	r5, r7
    return false;
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_SET_FEATURE << 8):
    /* Only the DEVICE_REMOTE_WAKEUP is handled here, any other feature
       number is handled as an error.*/
    if (usbp->setup[2] == USB_FEATURE_DEVICE_REMOTE_WAKEUP) {
      usbp->status |= 2U;
 8002222:	f8a4 207c 	strh.w	r2, [r4, #124]	; 0x7c
 8002226:	e6ad      	b.n	8001f84 <_usb_ep0setup+0x24>
    /*lint -restore*/
    return true;
  case (uint32_t)USB_RTYPE_RECIPIENT_ENDPOINT | ((uint32_t)USB_REQ_GET_STATUS << 8):
    /* Sending the EP status.*/
    if ((usbp->setup[4] & 0x80U) != 0U) {
      switch (usb_lld_get_status_in(usbp, usbp->setup[4] & 0x0FU)) {
 8002228:	f001 f832 	bl	8003290 <usb_lld_get_status_in>
 800222c:	2801      	cmp	r0, #1
 800222e:	d1bd      	bne.n	80021ac <_usb_ep0setup+0x24c>
    }
    else {
      switch (usb_lld_get_status_out(usbp, usbp->setup[4] & 0x0FU)) {
      case EP_STATUS_STALLED:
        /*lint -save -e9005 [11.8] Removing const is fine.*/
        usbSetupTransfer(usbp, (uint8_t *)halted_status, 2, NULL);
 8002230:	4b0b      	ldr	r3, [pc, #44]	; (8002260 <_usb_ep0setup+0x300>)
 8002232:	66e6      	str	r6, [r4, #108]	; 0x6c
 8002234:	66a3      	str	r3, [r4, #104]	; 0x68
 8002236:	6727      	str	r7, [r4, #112]	; 0x70
 8002238:	4635      	mov	r5, r6
 800223a:	f894 3074 	ldrb.w	r3, [r4, #116]	; 0x74
 800223e:	e6a1      	b.n	8001f84 <_usb_ep0setup+0x24>
      return false;
    }
    /* Clearing the EP status, not valid for EP0, it is ignored in that case.*/
    if ((usbp->setup[4] & 0x0FU) != 0U) {
      if ((usbp->setup[4] & 0x80U) != 0U) {
        usb_lld_clear_in(usbp, usbp->setup[4] & 0x0FU);
 8002240:	f001 f8ee 	bl	8003420 <usb_lld_clear_in>
 8002244:	f894 3074 	ldrb.w	r3, [r4, #116]	; 0x74
 8002248:	e70e      	b.n	8002068 <_usb_ep0setup+0x108>
      return false;
    }
    /* Stalling the EP, not valid for EP0, it is ignored in that case.*/
    if ((usbp->setup[4] & 0x0FU) != 0U) {
      if ((usbp->setup[4] & 0x80U) != 0U) {
        usb_lld_stall_in(usbp, usbp->setup[4] & 0x0FU);
 800224a:	f001 f8b9 	bl	80033c0 <usb_lld_stall_in>
 800224e:	f894 3074 	ldrb.w	r3, [r4, #116]	; 0x74
 8002252:	e709      	b.n	8002068 <_usb_ep0setup+0x108>
 8002254:	08001dd1 	.word	0x08001dd1
 8002258:	080046f0 	.word	0x080046f0
 800225c:	080046e0 	.word	0x080046e0
 8002260:	08004700 	.word	0x08004700
	...

08002270 <_usb_ep0in>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number, always zero
 *
 * @notapi
 */
void _usb_ep0in(USBDriver *usbp, usbep_t ep) {
 8002270:	b538      	push	{r3, r4, r5, lr}
  size_t max;

  (void)ep;
  switch (usbp->ep0state) {
 8002272:	f890 3064 	ldrb.w	r3, [r0, #100]	; 0x64
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number, always zero
 *
 * @notapi
 */
void _usb_ep0in(USBDriver *usbp, usbep_t ep) {
 8002276:	4604      	mov	r4, r0
  size_t max;

  (void)ep;
  switch (usbp->ep0state) {
 8002278:	2b06      	cmp	r3, #6
 800227a:	d815      	bhi.n	80022a8 <_usb_ep0in+0x38>
 800227c:	e8df f003 	tbb	[pc, r3]
 8002280:	04251504 	.word	0x04251504
 8002284:	3504      	.short	0x3504
 8002286:	04          	.byte	0x04
 8002287:	00          	.byte	0x00
    /* Falling through is intentional.*/
  case USB_EP0_ERROR:
    /* Error response, the state machine goes into an error state, the low
       level layer will have to reset it to USB_EP0_WAITING_SETUP after
       receiving a SETUP packet.*/
    usb_lld_stall_in(usbp, 0);
 8002288:	2100      	movs	r1, #0
 800228a:	f001 f899 	bl	80033c0 <usb_lld_stall_in>
    usb_lld_stall_out(usbp, 0);
 800228e:	4620      	mov	r0, r4
 8002290:	2100      	movs	r1, #0
 8002292:	f001 f87d 	bl	8003390 <usb_lld_stall_out>
    _usb_isr_invoke_event_cb(usbp, USB_EVENT_STALLED);
 8002296:	6863      	ldr	r3, [r4, #4]
 8002298:	681b      	ldr	r3, [r3, #0]
 800229a:	b113      	cbz	r3, 80022a2 <_usb_ep0in+0x32>
 800229c:	4620      	mov	r0, r4
 800229e:	2106      	movs	r1, #6
 80022a0:	4798      	blx	r3
    usbp->ep0state = USB_EP0_ERROR;
 80022a2:	2306      	movs	r3, #6
 80022a4:	f884 3064 	strb.w	r3, [r4, #100]	; 0x64
 80022a8:	bd38      	pop	{r3, r4, r5, pc}

static uint16_t get_hword(uint8_t *p) {
  uint16_t hw;

  hw  = (uint16_t)*p++;
  hw |= (uint16_t)*p << 8U;
 80022aa:	f890 107b 	ldrb.w	r1, [r0, #123]	; 0x7b
 80022ae:	f890 307a 	ldrb.w	r3, [r0, #122]	; 0x7a
  case USB_EP0_TX:
    max = (size_t)get_hword(&usbp->setup[6]);
    /* If the transmitted size is less than the requested size and it is a
       multiple of the maximum packet size then a zero size packet must be
       transmitted.*/
    if ((usbp->ep0n < max) &&
 80022b2:	6ec2      	ldr	r2, [r0, #108]	; 0x6c
  size_t max;

  (void)ep;
  switch (usbp->ep0state) {
  case USB_EP0_TX:
    max = (size_t)get_hword(&usbp->setup[6]);
 80022b4:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
    /* If the transmitted size is less than the requested size and it is a
       multiple of the maximum packet size then a zero size packet must be
       transmitted.*/
    if ((usbp->ep0n < max) &&
 80022b8:	4293      	cmp	r3, r2
 80022ba:	d906      	bls.n	80022ca <_usb_ep0in+0x5a>
        ((usbp->ep0n % usbp->epc[0]->in_maxsize) == 0U)) {
 80022bc:	68c3      	ldr	r3, [r0, #12]
 80022be:	8a1d      	ldrh	r5, [r3, #16]
 80022c0:	fbb2 f3f5 	udiv	r3, r2, r5
 80022c4:	fb05 2513 	mls	r5, r5, r3, r2
  case USB_EP0_TX:
    max = (size_t)get_hword(&usbp->setup[6]);
    /* If the transmitted size is less than the requested size and it is a
       multiple of the maximum packet size then a zero size packet must be
       transmitted.*/
    if ((usbp->ep0n < max) &&
 80022c8:	b1b5      	cbz	r5, 80022f8 <_usb_ep0in+0x88>
      return;
    }
    /* Falls into, it is intentional.*/
  case USB_EP0_WAITING_TX0:
    /* Transmit phase over, receiving the zero sized status packet.*/
    usbp->ep0state = USB_EP0_WAITING_STS;
 80022ca:	2303      	movs	r3, #3
 80022cc:	f884 3064 	strb.w	r3, [r4, #100]	; 0x64
 80022d0:	2320      	movs	r3, #32
 80022d2:	f383 8811 	msr	BASEPRI, r3
#if (USB_EP0_STATUS_STAGE == USB_EP0_STATUS_STAGE_SW)
    osalSysLockFromISR();
    usbStartReceiveI(usbp, 0, NULL, 0);
 80022d6:	2100      	movs	r1, #0
 80022d8:	460b      	mov	r3, r1
 80022da:	4620      	mov	r0, r4
 80022dc:	460a      	mov	r2, r1
 80022de:	f7ff fdc7 	bl	8001e70 <usbStartReceiveI>
 80022e2:	2300      	movs	r3, #0
 80022e4:	f383 8811 	msr	BASEPRI, r3
 80022e8:	bd38      	pop	{r3, r4, r5, pc}
    usb_lld_end_setup(usbp, ep);
#endif
    return;
  case USB_EP0_SENDING_STS:
    /* Status packet sent, invoking the callback if defined.*/
    if (usbp->ep0endcb != NULL) {
 80022ea:	6f03      	ldr	r3, [r0, #112]	; 0x70
 80022ec:	b103      	cbz	r3, 80022f0 <_usb_ep0in+0x80>
      usbp->ep0endcb(usbp);
 80022ee:	4798      	blx	r3
    }
    usbp->ep0state = USB_EP0_WAITING_SETUP;
 80022f0:	2300      	movs	r3, #0
 80022f2:	f884 3064 	strb.w	r3, [r4, #100]	; 0x64
    return;
 80022f6:	bd38      	pop	{r3, r4, r5, pc}
 80022f8:	2320      	movs	r3, #32
 80022fa:	f383 8811 	msr	BASEPRI, r3
       multiple of the maximum packet size then a zero size packet must be
       transmitted.*/
    if ((usbp->ep0n < max) &&
        ((usbp->ep0n % usbp->epc[0]->in_maxsize) == 0U)) {
      osalSysLockFromISR();
      usbStartTransmitI(usbp, 0, NULL, 0);
 80022fe:	4629      	mov	r1, r5
 8002300:	462a      	mov	r2, r5
 8002302:	462b      	mov	r3, r5
 8002304:	f7ff fdcc 	bl	8001ea0 <usbStartTransmitI>
 8002308:	f385 8811 	msr	BASEPRI, r5
      osalSysUnlockFromISR();
      usbp->ep0state = USB_EP0_WAITING_TX0;
 800230c:	2302      	movs	r3, #2
 800230e:	f884 3064 	strb.w	r3, [r4, #100]	; 0x64
      return;
 8002312:	bd38      	pop	{r3, r4, r5, pc}
	...

08002320 <_usb_ep0out>:
 * @notapi
 */
void _usb_ep0out(USBDriver *usbp, usbep_t ep) {

  (void)ep;
  switch (usbp->ep0state) {
 8002320:	f890 2064 	ldrb.w	r2, [r0, #100]	; 0x64
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number, always zero
 *
 * @notapi
 */
void _usb_ep0out(USBDriver *usbp, usbep_t ep) {
 8002324:	b538      	push	{r3, r4, r5, lr}
 8002326:	2a06      	cmp	r2, #6
 8002328:	d80a      	bhi.n	8002340 <_usb_ep0out+0x20>
 800232a:	2301      	movs	r3, #1
 800232c:	4093      	lsls	r3, r2
 800232e:	f013 0f67 	tst.w	r3, #103	; 0x67
 8002332:	4604      	mov	r4, r0
 8002334:	d111      	bne.n	800235a <_usb_ep0out+0x3a>
 8002336:	f013 0508 	ands.w	r5, r3, #8
 800233a:	d102      	bne.n	8002342 <_usb_ep0out+0x22>
 800233c:	06db      	lsls	r3, r3, #27
 800233e:	d41d      	bmi.n	800237c <_usb_ep0out+0x5c>
 8002340:	bd38      	pop	{r3, r4, r5, pc}
    return;
  case USB_EP0_WAITING_STS:
    /* Status packet received, it must be zero sized, invoking the callback
       if defined.*/
#if (USB_EP0_STATUS_STAGE == USB_EP0_STATUS_STAGE_SW)
    if (usbGetReceiveTransactionSizeX(usbp, 0) != 0U) {
 8002342:	68c3      	ldr	r3, [r0, #12]
 8002344:	699b      	ldr	r3, [r3, #24]
 8002346:	685b      	ldr	r3, [r3, #4]
 8002348:	2b00      	cmp	r3, #0
 800234a:	d1f9      	bne.n	8002340 <_usb_ep0out+0x20>
      break;
    }
#endif
    if (usbp->ep0endcb != NULL) {
 800234c:	6f03      	ldr	r3, [r0, #112]	; 0x70
 800234e:	b103      	cbz	r3, 8002352 <_usb_ep0out+0x32>
      usbp->ep0endcb(usbp);
 8002350:	4798      	blx	r3
    }
    usbp->ep0state = USB_EP0_WAITING_SETUP;
 8002352:	2300      	movs	r3, #0
 8002354:	f884 3064 	strb.w	r3, [r4, #100]	; 0x64
    return;
 8002358:	bd38      	pop	{r3, r4, r5, pc}
    /* Falling through is intentional.*/
  case USB_EP0_ERROR:
    /* Error response, the state machine goes into an error state, the low
       level layer will have to reset it to USB_EP0_WAITING_SETUP after
       receiving a SETUP packet.*/
    usb_lld_stall_in(usbp, 0);
 800235a:	2100      	movs	r1, #0
 800235c:	f001 f830 	bl	80033c0 <usb_lld_stall_in>
    usb_lld_stall_out(usbp, 0);
 8002360:	4620      	mov	r0, r4
 8002362:	2100      	movs	r1, #0
 8002364:	f001 f814 	bl	8003390 <usb_lld_stall_out>
    _usb_isr_invoke_event_cb(usbp, USB_EVENT_STALLED);
 8002368:	6863      	ldr	r3, [r4, #4]
 800236a:	681b      	ldr	r3, [r3, #0]
 800236c:	b113      	cbz	r3, 8002374 <_usb_ep0out+0x54>
 800236e:	4620      	mov	r0, r4
 8002370:	2106      	movs	r1, #6
 8002372:	4798      	blx	r3
    usbp->ep0state = USB_EP0_ERROR;
 8002374:	2306      	movs	r3, #6
 8002376:	f884 3064 	strb.w	r3, [r4, #100]	; 0x64
 800237a:	bd38      	pop	{r3, r4, r5, pc}

  (void)ep;
  switch (usbp->ep0state) {
  case USB_EP0_RX:
    /* Receive phase over, sending the zero sized status packet.*/
    usbp->ep0state = USB_EP0_SENDING_STS;
 800237c:	2305      	movs	r3, #5
 800237e:	f880 3064 	strb.w	r3, [r0, #100]	; 0x64
 8002382:	2320      	movs	r3, #32
 8002384:	f383 8811 	msr	BASEPRI, r3
#if (USB_EP0_STATUS_STAGE == USB_EP0_STATUS_STAGE_SW)
    osalSysLockFromISR();
    usbStartTransmitI(usbp, 0, NULL, 0);
 8002388:	4629      	mov	r1, r5
 800238a:	462a      	mov	r2, r5
 800238c:	462b      	mov	r3, r5
 800238e:	f7ff fd87 	bl	8001ea0 <usbStartTransmitI>
 8002392:	f385 8811 	msr	BASEPRI, r5
 8002396:	bd38      	pop	{r3, r4, r5, pc}
	...

080023a0 <nvicEnableVector>:
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 80023a0:	0943      	lsrs	r3, r0, #5
 80023a2:	009b      	lsls	r3, r3, #2
 * @brief   Sets the priority of an interrupt handler and enables it.
 *
 * @param[in] n         the interrupt number
 * @param[in] prio      the interrupt priority
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {
 80023a4:	b410      	push	{r4}

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 80023a6:	0109      	lsls	r1, r1, #4
 80023a8:	f100 4460 	add.w	r4, r0, #3758096384	; 0xe0000000
 80023ac:	f103 4360 	add.w	r3, r3, #3758096384	; 0xe0000000
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 80023b0:	f000 001f 	and.w	r0, r0, #31
 80023b4:	2201      	movs	r2, #1

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 80023b6:	f504 4461 	add.w	r4, r4, #57600	; 0xe100
 80023ba:	f503 4361 	add.w	r3, r3, #57600	; 0xe100
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 80023be:	4082      	lsls	r2, r0

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 80023c0:	b2c9      	uxtb	r1, r1
 80023c2:	f884 1300 	strb.w	r1, [r4, #768]	; 0x300
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 80023c6:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 80023ca:	601a      	str	r2, [r3, #0]
}
 80023cc:	f85d 4b04 	ldr.w	r4, [sp], #4
 80023d0:	4770      	bx	lr
 80023d2:	bf00      	nop
	...

080023e0 <nvicSetSystemHandlerPriority>:
  SCB->SHP[_SHP_IDX(handler)] = (SCB->SHP[_SHP_IDX(handler)] & ~(0xFFU << _BIT_SHIFT(handler))) |
                                (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(handler));
#elif defined(__CORE_CM7_H_GENERIC)
  SCB->SHPR[handler] = NVIC_PRIORITY_MASK(prio);
#else
  SCB->SHP[handler] = NVIC_PRIORITY_MASK(prio);
 80023e0:	0109      	lsls	r1, r1, #4
 80023e2:	f100 4060 	add.w	r0, r0, #3758096384	; 0xe0000000
 80023e6:	b2c9      	uxtb	r1, r1
 80023e8:	f500 406d 	add.w	r0, r0, #60672	; 0xed00
 80023ec:	7601      	strb	r1, [r0, #24]
 80023ee:	4770      	bx	lr

080023f0 <Vector12C>:
/**
 * @brief   DMA2 streams 4 and 5 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH45_HANDLER) {
 80023f0:	b570      	push	{r4, r5, r6, lr}

  OSAL_IRQ_PROLOGUE();

  /* Check on channel 4 of DMA2.*/
  dmaServeInterrupt(STM32_DMA2_STREAM4);
 80023f2:	4c18      	ldr	r4, [pc, #96]	; (8002454 <Vector12C+0x64>)
 80023f4:	f8d4 30c8 	ldr.w	r3, [r4, #200]	; 0xc8
 80023f8:	f894 20d8 	ldrb.w	r2, [r4, #216]	; 0xd8
 80023fc:	6819      	ldr	r1, [r3, #0]
 80023fe:	f894 50d9 	ldrb.w	r5, [r4, #217]	; 0xd9
 8002402:	40d1      	lsrs	r1, r2
 8002404:	f011 010f 	ands.w	r1, r1, #15
 8002408:	d00a      	beq.n	8002420 <Vector12C+0x30>
 800240a:	4813      	ldr	r0, [pc, #76]	; (8002458 <Vector12C+0x68>)
 800240c:	fa01 f602 	lsl.w	r6, r1, r2
 8002410:	f850 2035 	ldr.w	r2, [r0, r5, lsl #3]
 8002414:	605e      	str	r6, [r3, #4]
 8002416:	b11a      	cbz	r2, 8002420 <Vector12C+0x30>
 8002418:	eb00 00c5 	add.w	r0, r0, r5, lsl #3
 800241c:	6840      	ldr	r0, [r0, #4]
 800241e:	4790      	blx	r2

  /* Check on channel 5 of DMA2.*/
  dmaServeInterrupt(STM32_DMA2_STREAM5);
 8002420:	f8d4 20dc 	ldr.w	r2, [r4, #220]	; 0xdc
 8002424:	f894 00ec 	ldrb.w	r0, [r4, #236]	; 0xec
 8002428:	6811      	ldr	r1, [r2, #0]
 800242a:	f894 40ed 	ldrb.w	r4, [r4, #237]	; 0xed
 800242e:	40c1      	lsrs	r1, r0
 8002430:	f011 010f 	ands.w	r1, r1, #15
 8002434:	d00a      	beq.n	800244c <Vector12C+0x5c>
 8002436:	4b08      	ldr	r3, [pc, #32]	; (8002458 <Vector12C+0x68>)
 8002438:	fa01 f000 	lsl.w	r0, r1, r0
 800243c:	f853 5034 	ldr.w	r5, [r3, r4, lsl #3]
 8002440:	6050      	str	r0, [r2, #4]
 8002442:	b11d      	cbz	r5, 800244c <Vector12C+0x5c>
 8002444:	eb03 03c4 	add.w	r3, r3, r4, lsl #3
 8002448:	6858      	ldr	r0, [r3, #4]
 800244a:	47a8      	blx	r5

  OSAL_IRQ_EPILOGUE();
}
 800244c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  dmaServeInterrupt(STM32_DMA2_STREAM4);

  /* Check on channel 5 of DMA2.*/
  dmaServeInterrupt(STM32_DMA2_STREAM5);

  OSAL_IRQ_EPILOGUE();
 8002450:	f7ff bb9e 	b.w	8001b90 <_port_irq_epilogue>
 8002454:	08004710 	.word	0x08004710
 8002458:	20000a48 	.word	0x20000a48
 800245c:	00000000 	.word	0x00000000

08002460 <hal_lld_init>:
 * @notapi
 */
void hal_lld_init(void) {

  /* Reset of all peripherals.*/
  rccResetAPB1(0xFFFFFFFF);
 8002460:	4b0c      	ldr	r3, [pc, #48]	; (8002494 <hal_lld_init+0x34>)
 8002462:	f04f 31ff 	mov.w	r1, #4294967295
 8002466:	2200      	movs	r2, #0
 8002468:	6918      	ldr	r0, [r3, #16]
 800246a:	6119      	str	r1, [r3, #16]
 800246c:	611a      	str	r2, [r3, #16]
  rccResetAPB2(0xFFFFFFFF);
 800246e:	68d8      	ldr	r0, [r3, #12]
 8002470:	60d9      	str	r1, [r3, #12]
 8002472:	60da      	str	r2, [r3, #12]

  /* PWR and BD clocks enabled.*/
  rccEnablePWRInterface(FALSE);
 8002474:	69da      	ldr	r2, [r3, #28]
 *          of the whole BKP domain.
 */
static void hal_lld_backup_domain_init(void) {

  /* Backup domain access enabled and left open.*/
  PWR->CR |= PWR_CR_DBP;
 8002476:	4908      	ldr	r1, [pc, #32]	; (8002498 <hal_lld_init+0x38>)
  /* Reset of all peripherals.*/
  rccResetAPB1(0xFFFFFFFF);
  rccResetAPB2(0xFFFFFFFF);

  /* PWR and BD clocks enabled.*/
  rccEnablePWRInterface(FALSE);
 8002478:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 800247c:	61da      	str	r2, [r3, #28]
  rccEnableBKPInterface(FALSE);
 800247e:	69da      	ldr	r2, [r3, #28]
 8002480:	f042 6200 	orr.w	r2, r2, #134217728	; 0x8000000
 8002484:	61da      	str	r2, [r3, #28]
 *          of the whole BKP domain.
 */
static void hal_lld_backup_domain_init(void) {

  /* Backup domain access enabled and left open.*/
  PWR->CR |= PWR_CR_DBP;
 8002486:	680b      	ldr	r3, [r1, #0]
 8002488:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 800248c:	600b      	str	r3, [r1, #0]

  /* Initializes the backup domain.*/
  hal_lld_backup_domain_init();

#if defined(STM32_DMA_REQUIRED)
  dmaInit();
 800248e:	f000 b93f 	b.w	8002710 <dmaInit>
 8002492:	bf00      	nop
 8002494:	40021000 	.word	0x40021000
 8002498:	40007000 	.word	0x40007000
 800249c:	00000000 	.word	0x00000000

080024a0 <stm32_clock_init>:
void stm32_clock_init(void) {

#if !STM32_NO_INIT
  /* HSI setup, it enforces the reset situation in order to handle possible
     problems with JTAG probes and re-initializations.*/
  RCC->CR |= RCC_CR_HSION;                  /* Make sure HSI is ON.         */
 80024a0:	4b1f      	ldr	r3, [pc, #124]	; (8002520 <stm32_clock_init+0x80>)
  while (!(RCC->CR & RCC_CR_HSIRDY))
 80024a2:	4619      	mov	r1, r3
void stm32_clock_init(void) {

#if !STM32_NO_INIT
  /* HSI setup, it enforces the reset situation in order to handle possible
     problems with JTAG probes and re-initializations.*/
  RCC->CR |= RCC_CR_HSION;                  /* Make sure HSI is ON.         */
 80024a4:	681a      	ldr	r2, [r3, #0]
 80024a6:	f042 0201 	orr.w	r2, r2, #1
 80024aa:	601a      	str	r2, [r3, #0]
  while (!(RCC->CR & RCC_CR_HSIRDY))
 80024ac:	680b      	ldr	r3, [r1, #0]
 80024ae:	4a1c      	ldr	r2, [pc, #112]	; (8002520 <stm32_clock_init+0x80>)
 80024b0:	079b      	lsls	r3, r3, #30
 80024b2:	d5fb      	bpl.n	80024ac <stm32_clock_init+0xc>
    ;                                       /* Wait until HSI is stable.    */
  RCC->CR &= RCC_CR_HSITRIM | RCC_CR_HSION; /* CR Reset value.              */
  RCC->CFGR = 0;                            /* CFGR reset value.            */
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
 80024b4:	4611      	mov	r1, r2
  /* HSI setup, it enforces the reset situation in order to handle possible
     problems with JTAG probes and re-initializations.*/
  RCC->CR |= RCC_CR_HSION;                  /* Make sure HSI is ON.         */
  while (!(RCC->CR & RCC_CR_HSIRDY))
    ;                                       /* Wait until HSI is stable.    */
  RCC->CR &= RCC_CR_HSITRIM | RCC_CR_HSION; /* CR Reset value.              */
 80024b6:	6813      	ldr	r3, [r2, #0]
  RCC->CFGR = 0;                            /* CFGR reset value.            */
 80024b8:	2000      	movs	r0, #0
  /* HSI setup, it enforces the reset situation in order to handle possible
     problems with JTAG probes and re-initializations.*/
  RCC->CR |= RCC_CR_HSION;                  /* Make sure HSI is ON.         */
  while (!(RCC->CR & RCC_CR_HSIRDY))
    ;                                       /* Wait until HSI is stable.    */
  RCC->CR &= RCC_CR_HSITRIM | RCC_CR_HSION; /* CR Reset value.              */
 80024ba:	f003 03f9 	and.w	r3, r3, #249	; 0xf9
 80024be:	6013      	str	r3, [r2, #0]
  RCC->CFGR = 0;                            /* CFGR reset value.            */
 80024c0:	6050      	str	r0, [r2, #4]
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
 80024c2:	684b      	ldr	r3, [r1, #4]
 80024c4:	4a16      	ldr	r2, [pc, #88]	; (8002520 <stm32_clock_init+0x80>)
 80024c6:	f013 0f0c 	tst.w	r3, #12
 80024ca:	d1fa      	bne.n	80024c2 <stm32_clock_init+0x22>
  /* HSE Bypass.*/
  RCC->CR |= RCC_CR_HSEON | RCC_CR_HSEBYP;
#endif
  /* HSE activation.*/
  RCC->CR |= RCC_CR_HSEON;
  while (!(RCC->CR & RCC_CR_HSERDY))
 80024cc:	4611      	mov	r1, r2
#if defined(STM32_HSE_BYPASS)
  /* HSE Bypass.*/
  RCC->CR |= RCC_CR_HSEON | RCC_CR_HSEBYP;
#endif
  /* HSE activation.*/
  RCC->CR |= RCC_CR_HSEON;
 80024ce:	6813      	ldr	r3, [r2, #0]
 80024d0:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 80024d4:	6013      	str	r3, [r2, #0]
  while (!(RCC->CR & RCC_CR_HSERDY))
 80024d6:	680b      	ldr	r3, [r1, #0]
 80024d8:	4a11      	ldr	r2, [pc, #68]	; (8002520 <stm32_clock_init+0x80>)
 80024da:	0398      	lsls	r0, r3, #14
 80024dc:	d5fb      	bpl.n	80024d6 <stm32_clock_init+0x36>

#if STM32_ACTIVATE_PLL
  /* PLL activation.*/
  RCC->CFGR |= STM32_PLLMUL | STM32_PLLXTPRE | STM32_PLLSRC;
  RCC->CR   |= RCC_CR_PLLON;
  while (!(RCC->CR & RCC_CR_PLLRDY))
 80024de:	4611      	mov	r1, r2
    ;                                       /* Waits until LSI is stable.   */
#endif

#if STM32_ACTIVATE_PLL
  /* PLL activation.*/
  RCC->CFGR |= STM32_PLLMUL | STM32_PLLXTPRE | STM32_PLLSRC;
 80024e0:	6853      	ldr	r3, [r2, #4]
 80024e2:	f443 13e8 	orr.w	r3, r3, #1900544	; 0x1d0000
 80024e6:	6053      	str	r3, [r2, #4]
  RCC->CR   |= RCC_CR_PLLON;
 80024e8:	6813      	ldr	r3, [r2, #0]
 80024ea:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 80024ee:	6013      	str	r3, [r2, #0]
  while (!(RCC->CR & RCC_CR_PLLRDY))
 80024f0:	680b      	ldr	r3, [r1, #0]
 80024f2:	4a0b      	ldr	r2, [pc, #44]	; (8002520 <stm32_clock_init+0x80>)
 80024f4:	019b      	lsls	r3, r3, #6
 80024f6:	d5fb      	bpl.n	80024f0 <stm32_clock_init+0x50>

  /* Switching to the configured clock source if it is different from HSI.*/
#if (STM32_SW != STM32_SW_HSI)
  /* Switches clock source.*/
  RCC->CFGR |= STM32_SW;
  while ((RCC->CFGR & RCC_CFGR_SWS) != (STM32_SW << 2))
 80024f8:	4611      	mov	r1, r2
    defined(STM32F10X_HD) || defined(STM32F10X_XL) ||                       \
    defined(__DOXYGEN__)
/*
 * Clocks initialization for all sub-families except CL.
 */
void stm32_clock_init(void) {
 80024fa:	b410      	push	{r4}
              STM32_PLLSRC | STM32_ADCPRE | STM32_PPRE2  | STM32_PPRE1    |
              STM32_HPRE;
#endif

  /* Flash setup and final clock selection.   */
  FLASH->ACR = STM32_FLASHBITS;
 80024fc:	4b09      	ldr	r3, [pc, #36]	; (8002524 <stm32_clock_init+0x84>)
    ;                                       /* Waits until PLL is stable.   */
#endif

  /* Clock settings.*/
#if STM32_HAS_USB
  RCC->CFGR = STM32_MCOSEL | STM32_USBPRE | STM32_PLLMUL | STM32_PLLXTPRE |
 80024fe:	4c0a      	ldr	r4, [pc, #40]	; (8002528 <stm32_clock_init+0x88>)
              STM32_PLLSRC | STM32_ADCPRE | STM32_PPRE2  | STM32_PPRE1    |
              STM32_HPRE;
#endif

  /* Flash setup and final clock selection.   */
  FLASH->ACR = STM32_FLASHBITS;
 8002500:	2012      	movs	r0, #18
    ;                                       /* Waits until PLL is stable.   */
#endif

  /* Clock settings.*/
#if STM32_HAS_USB
  RCC->CFGR = STM32_MCOSEL | STM32_USBPRE | STM32_PLLMUL | STM32_PLLXTPRE |
 8002502:	6054      	str	r4, [r2, #4]
              STM32_PLLSRC | STM32_ADCPRE | STM32_PPRE2  | STM32_PPRE1    |
              STM32_HPRE;
#endif

  /* Flash setup and final clock selection.   */
  FLASH->ACR = STM32_FLASHBITS;
 8002504:	6018      	str	r0, [r3, #0]

  /* Switching to the configured clock source if it is different from HSI.*/
#if (STM32_SW != STM32_SW_HSI)
  /* Switches clock source.*/
  RCC->CFGR |= STM32_SW;
 8002506:	6853      	ldr	r3, [r2, #4]
 8002508:	f043 0302 	orr.w	r3, r3, #2
 800250c:	6053      	str	r3, [r2, #4]
  while ((RCC->CFGR & RCC_CFGR_SWS) != (STM32_SW << 2))
 800250e:	684b      	ldr	r3, [r1, #4]
 8002510:	f003 030c 	and.w	r3, r3, #12
 8002514:	2b08      	cmp	r3, #8
 8002516:	d1fa      	bne.n	800250e <stm32_clock_init+0x6e>

#if !STM32_HSI_ENABLED
  RCC->CR &= ~RCC_CR_HSION;
#endif
#endif /* !STM32_NO_INIT */
}
 8002518:	f85d 4b04 	ldr.w	r4, [sp], #4
 800251c:	4770      	bx	lr
 800251e:	bf00      	nop
 8002520:	40021000 	.word	0x40021000
 8002524:	40022000 	.word	0x40022000
 8002528:	001de400 	.word	0x001de400
 800252c:	00000000 	.word	0x00000000

08002530 <Vector6C>:
/**
 * @brief   DMA1 stream 1 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH1_HANDLER) {
 8002530:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM1);
 8002532:	4b07      	ldr	r3, [pc, #28]	; (8002550 <Vector6C+0x20>)
 8002534:	6819      	ldr	r1, [r3, #0]
 8002536:	f011 010f 	ands.w	r1, r1, #15
 800253a:	d005      	beq.n	8002548 <Vector6C+0x18>
 800253c:	4a05      	ldr	r2, [pc, #20]	; (8002554 <Vector6C+0x24>)
 800253e:	6059      	str	r1, [r3, #4]
 8002540:	6813      	ldr	r3, [r2, #0]
 8002542:	b10b      	cbz	r3, 8002548 <Vector6C+0x18>
 8002544:	6850      	ldr	r0, [r2, #4]
 8002546:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
}
 8002548:	e8bd 4008 	ldmia.w	sp!, {r3, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM1);

  OSAL_IRQ_EPILOGUE();
 800254c:	f7ff bb20 	b.w	8001b90 <_port_irq_epilogue>
 8002550:	40020000 	.word	0x40020000
 8002554:	20000a48 	.word	0x20000a48
	...

08002560 <Vector70>:
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH2_HANDLER) {

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM2);
 8002560:	4b09      	ldr	r3, [pc, #36]	; (8002588 <Vector70+0x28>)
 8002562:	6819      	ldr	r1, [r3, #0]
 8002564:	f3c1 1103 	ubfx	r1, r1, #4, #4
 8002568:	b159      	cbz	r1, 8002582 <Vector70+0x22>
 800256a:	4808      	ldr	r0, [pc, #32]	; (800258c <Vector70+0x2c>)
/**
 * @brief   DMA1 stream 2 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH2_HANDLER) {
 800256c:	b510      	push	{r4, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM2);
 800256e:	6884      	ldr	r4, [r0, #8]
 8002570:	010a      	lsls	r2, r1, #4
 8002572:	605a      	str	r2, [r3, #4]
 8002574:	b10c      	cbz	r4, 800257a <Vector70+0x1a>
 8002576:	68c0      	ldr	r0, [r0, #12]
 8002578:	47a0      	blx	r4

  OSAL_IRQ_EPILOGUE();
}
 800257a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM2);

  OSAL_IRQ_EPILOGUE();
 800257e:	f7ff bb07 	b.w	8001b90 <_port_irq_epilogue>
 8002582:	f7ff bb05 	b.w	8001b90 <_port_irq_epilogue>
 8002586:	bf00      	nop
 8002588:	40020000 	.word	0x40020000
 800258c:	20000a48 	.word	0x20000a48

08002590 <Vector74>:
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH3_HANDLER) {

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM3);
 8002590:	4b09      	ldr	r3, [pc, #36]	; (80025b8 <Vector74+0x28>)
 8002592:	6819      	ldr	r1, [r3, #0]
 8002594:	f3c1 2103 	ubfx	r1, r1, #8, #4
 8002598:	b159      	cbz	r1, 80025b2 <Vector74+0x22>
 800259a:	4808      	ldr	r0, [pc, #32]	; (80025bc <Vector74+0x2c>)
/**
 * @brief   DMA1 stream 3 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH3_HANDLER) {
 800259c:	b510      	push	{r4, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM3);
 800259e:	6904      	ldr	r4, [r0, #16]
 80025a0:	020a      	lsls	r2, r1, #8
 80025a2:	605a      	str	r2, [r3, #4]
 80025a4:	b10c      	cbz	r4, 80025aa <Vector74+0x1a>
 80025a6:	6940      	ldr	r0, [r0, #20]
 80025a8:	47a0      	blx	r4

  OSAL_IRQ_EPILOGUE();
}
 80025aa:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM3);

  OSAL_IRQ_EPILOGUE();
 80025ae:	f7ff baef 	b.w	8001b90 <_port_irq_epilogue>
 80025b2:	f7ff baed 	b.w	8001b90 <_port_irq_epilogue>
 80025b6:	bf00      	nop
 80025b8:	40020000 	.word	0x40020000
 80025bc:	20000a48 	.word	0x20000a48

080025c0 <Vector78>:
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH4_HANDLER) {

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM4);
 80025c0:	4b09      	ldr	r3, [pc, #36]	; (80025e8 <Vector78+0x28>)
 80025c2:	6819      	ldr	r1, [r3, #0]
 80025c4:	f3c1 3103 	ubfx	r1, r1, #12, #4
 80025c8:	b159      	cbz	r1, 80025e2 <Vector78+0x22>
 80025ca:	4808      	ldr	r0, [pc, #32]	; (80025ec <Vector78+0x2c>)
/**
 * @brief   DMA1 stream 4 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH4_HANDLER) {
 80025cc:	b510      	push	{r4, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM4);
 80025ce:	6984      	ldr	r4, [r0, #24]
 80025d0:	030a      	lsls	r2, r1, #12
 80025d2:	605a      	str	r2, [r3, #4]
 80025d4:	b10c      	cbz	r4, 80025da <Vector78+0x1a>
 80025d6:	69c0      	ldr	r0, [r0, #28]
 80025d8:	47a0      	blx	r4

  OSAL_IRQ_EPILOGUE();
}
 80025da:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM4);

  OSAL_IRQ_EPILOGUE();
 80025de:	f7ff bad7 	b.w	8001b90 <_port_irq_epilogue>
 80025e2:	f7ff bad5 	b.w	8001b90 <_port_irq_epilogue>
 80025e6:	bf00      	nop
 80025e8:	40020000 	.word	0x40020000
 80025ec:	20000a48 	.word	0x20000a48

080025f0 <Vector7C>:
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH5_HANDLER) {

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM5);
 80025f0:	4b09      	ldr	r3, [pc, #36]	; (8002618 <Vector7C+0x28>)
 80025f2:	6819      	ldr	r1, [r3, #0]
 80025f4:	f3c1 4103 	ubfx	r1, r1, #16, #4
 80025f8:	b159      	cbz	r1, 8002612 <Vector7C+0x22>
 80025fa:	4808      	ldr	r0, [pc, #32]	; (800261c <Vector7C+0x2c>)
/**
 * @brief   DMA1 stream 5 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH5_HANDLER) {
 80025fc:	b510      	push	{r4, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM5);
 80025fe:	6a04      	ldr	r4, [r0, #32]
 8002600:	040a      	lsls	r2, r1, #16
 8002602:	605a      	str	r2, [r3, #4]
 8002604:	b10c      	cbz	r4, 800260a <Vector7C+0x1a>
 8002606:	6a40      	ldr	r0, [r0, #36]	; 0x24
 8002608:	47a0      	blx	r4

  OSAL_IRQ_EPILOGUE();
}
 800260a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM5);

  OSAL_IRQ_EPILOGUE();
 800260e:	f7ff babf 	b.w	8001b90 <_port_irq_epilogue>
 8002612:	f7ff babd 	b.w	8001b90 <_port_irq_epilogue>
 8002616:	bf00      	nop
 8002618:	40020000 	.word	0x40020000
 800261c:	20000a48 	.word	0x20000a48

08002620 <Vector80>:
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH6_HANDLER) {

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM6);
 8002620:	4b09      	ldr	r3, [pc, #36]	; (8002648 <Vector80+0x28>)
 8002622:	6819      	ldr	r1, [r3, #0]
 8002624:	f3c1 5103 	ubfx	r1, r1, #20, #4
 8002628:	b159      	cbz	r1, 8002642 <Vector80+0x22>
 800262a:	4808      	ldr	r0, [pc, #32]	; (800264c <Vector80+0x2c>)
/**
 * @brief   DMA1 stream 6 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH6_HANDLER) {
 800262c:	b510      	push	{r4, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM6);
 800262e:	6a84      	ldr	r4, [r0, #40]	; 0x28
 8002630:	050a      	lsls	r2, r1, #20
 8002632:	605a      	str	r2, [r3, #4]
 8002634:	b10c      	cbz	r4, 800263a <Vector80+0x1a>
 8002636:	6ac0      	ldr	r0, [r0, #44]	; 0x2c
 8002638:	47a0      	blx	r4

  OSAL_IRQ_EPILOGUE();
}
 800263a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM6);

  OSAL_IRQ_EPILOGUE();
 800263e:	f7ff baa7 	b.w	8001b90 <_port_irq_epilogue>
 8002642:	f7ff baa5 	b.w	8001b90 <_port_irq_epilogue>
 8002646:	bf00      	nop
 8002648:	40020000 	.word	0x40020000
 800264c:	20000a48 	.word	0x20000a48

08002650 <Vector84>:
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH7_HANDLER) {

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM7);
 8002650:	4b09      	ldr	r3, [pc, #36]	; (8002678 <Vector84+0x28>)
 8002652:	6819      	ldr	r1, [r3, #0]
 8002654:	f3c1 6103 	ubfx	r1, r1, #24, #4
 8002658:	b159      	cbz	r1, 8002672 <Vector84+0x22>
 800265a:	4808      	ldr	r0, [pc, #32]	; (800267c <Vector84+0x2c>)
/**
 * @brief   DMA1 stream 7 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH7_HANDLER) {
 800265c:	b510      	push	{r4, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM7);
 800265e:	6b04      	ldr	r4, [r0, #48]	; 0x30
 8002660:	060a      	lsls	r2, r1, #24
 8002662:	605a      	str	r2, [r3, #4]
 8002664:	b10c      	cbz	r4, 800266a <Vector84+0x1a>
 8002666:	6b40      	ldr	r0, [r0, #52]	; 0x34
 8002668:	47a0      	blx	r4

  OSAL_IRQ_EPILOGUE();
}
 800266a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM7);

  OSAL_IRQ_EPILOGUE();
 800266e:	f7ff ba8f 	b.w	8001b90 <_port_irq_epilogue>
 8002672:	f7ff ba8d 	b.w	8001b90 <_port_irq_epilogue>
 8002676:	bf00      	nop
 8002678:	40020000 	.word	0x40020000
 800267c:	20000a48 	.word	0x20000a48

08002680 <Vector120>:
/**
 * @brief   DMA2 stream 1 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH1_HANDLER) {
 8002680:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA2_STREAM1);
 8002682:	4b07      	ldr	r3, [pc, #28]	; (80026a0 <Vector120+0x20>)
 8002684:	6819      	ldr	r1, [r3, #0]
 8002686:	f011 010f 	ands.w	r1, r1, #15
 800268a:	d005      	beq.n	8002698 <Vector120+0x18>
 800268c:	4a05      	ldr	r2, [pc, #20]	; (80026a4 <Vector120+0x24>)
 800268e:	6059      	str	r1, [r3, #4]
 8002690:	6b93      	ldr	r3, [r2, #56]	; 0x38
 8002692:	b10b      	cbz	r3, 8002698 <Vector120+0x18>
 8002694:	6bd0      	ldr	r0, [r2, #60]	; 0x3c
 8002696:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
}
 8002698:	e8bd 4008 	ldmia.w	sp!, {r3, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA2_STREAM1);

  OSAL_IRQ_EPILOGUE();
 800269c:	f7ff ba78 	b.w	8001b90 <_port_irq_epilogue>
 80026a0:	40020400 	.word	0x40020400
 80026a4:	20000a48 	.word	0x20000a48
	...

080026b0 <Vector124>:
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH2_HANDLER) {

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA2_STREAM2);
 80026b0:	4b09      	ldr	r3, [pc, #36]	; (80026d8 <Vector124+0x28>)
 80026b2:	6819      	ldr	r1, [r3, #0]
 80026b4:	f3c1 1103 	ubfx	r1, r1, #4, #4
 80026b8:	b159      	cbz	r1, 80026d2 <Vector124+0x22>
 80026ba:	4808      	ldr	r0, [pc, #32]	; (80026dc <Vector124+0x2c>)
/**
 * @brief   DMA2 stream 2 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH2_HANDLER) {
 80026bc:	b510      	push	{r4, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA2_STREAM2);
 80026be:	6c04      	ldr	r4, [r0, #64]	; 0x40
 80026c0:	010a      	lsls	r2, r1, #4
 80026c2:	605a      	str	r2, [r3, #4]
 80026c4:	b10c      	cbz	r4, 80026ca <Vector124+0x1a>
 80026c6:	6c40      	ldr	r0, [r0, #68]	; 0x44
 80026c8:	47a0      	blx	r4

  OSAL_IRQ_EPILOGUE();
}
 80026ca:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA2_STREAM2);

  OSAL_IRQ_EPILOGUE();
 80026ce:	f7ff ba5f 	b.w	8001b90 <_port_irq_epilogue>
 80026d2:	f7ff ba5d 	b.w	8001b90 <_port_irq_epilogue>
 80026d6:	bf00      	nop
 80026d8:	40020400 	.word	0x40020400
 80026dc:	20000a48 	.word	0x20000a48

080026e0 <Vector128>:
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH3_HANDLER) {

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA2_STREAM3);
 80026e0:	4b09      	ldr	r3, [pc, #36]	; (8002708 <Vector128+0x28>)
 80026e2:	6819      	ldr	r1, [r3, #0]
 80026e4:	f3c1 2103 	ubfx	r1, r1, #8, #4
 80026e8:	b159      	cbz	r1, 8002702 <Vector128+0x22>
 80026ea:	4808      	ldr	r0, [pc, #32]	; (800270c <Vector128+0x2c>)
/**
 * @brief   DMA2 stream 3 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH3_HANDLER) {
 80026ec:	b510      	push	{r4, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA2_STREAM3);
 80026ee:	6c84      	ldr	r4, [r0, #72]	; 0x48
 80026f0:	020a      	lsls	r2, r1, #8
 80026f2:	605a      	str	r2, [r3, #4]
 80026f4:	b10c      	cbz	r4, 80026fa <Vector128+0x1a>
 80026f6:	6cc0      	ldr	r0, [r0, #76]	; 0x4c
 80026f8:	47a0      	blx	r4

  OSAL_IRQ_EPILOGUE();
}
 80026fa:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA2_STREAM3);

  OSAL_IRQ_EPILOGUE();
 80026fe:	f7ff ba47 	b.w	8001b90 <_port_irq_epilogue>
 8002702:	f7ff ba45 	b.w	8001b90 <_port_irq_epilogue>
 8002706:	bf00      	nop
 8002708:	40020400 	.word	0x40020400
 800270c:	20000a48 	.word	0x20000a48

08002710 <dmaInit>:
 * @init
 */
void dmaInit(void) {
  int i;

  dma_streams_mask = 0U;
 8002710:	2000      	movs	r0, #0
  for (i = 0; i < STM32_DMA_STREAMS; i++) {
 8002712:	4603      	mov	r3, r0
    _stm32_dma_streams[i].channel->CCR = 0U;
 8002714:	4601      	mov	r1, r0
/**
 * @brief   STM32 DMA helper initialization.
 *
 * @init
 */
void dmaInit(void) {
 8002716:	b430      	push	{r4, r5}
  int i;

  dma_streams_mask = 0U;
 8002718:	4d09      	ldr	r5, [pc, #36]	; (8002740 <dmaInit+0x30>)
 800271a:	4a0a      	ldr	r2, [pc, #40]	; (8002744 <dmaInit+0x34>)
 800271c:	4c0a      	ldr	r4, [pc, #40]	; (8002748 <dmaInit+0x38>)
 800271e:	6028      	str	r0, [r5, #0]
  for (i = 0; i < STM32_DMA_STREAMS; i++) {
    _stm32_dma_streams[i].channel->CCR = 0U;
 8002720:	6850      	ldr	r0, [r2, #4]
 8002722:	3214      	adds	r2, #20
 8002724:	6001      	str	r1, [r0, #0]
    _stm32_dma_isr_redir[i].dma_func = NULL;
 8002726:	f844 1033 	str.w	r1, [r4, r3, lsl #3]
 */
void dmaInit(void) {
  int i;

  dma_streams_mask = 0U;
  for (i = 0; i < STM32_DMA_STREAMS; i++) {
 800272a:	3301      	adds	r3, #1
 800272c:	2b0c      	cmp	r3, #12
 800272e:	d1f7      	bne.n	8002720 <dmaInit+0x10>
    _stm32_dma_streams[i].channel->CCR = 0U;
    _stm32_dma_isr_redir[i].dma_func = NULL;
  }
  DMA1->IFCR = 0xFFFFFFFFU;
 8002730:	4906      	ldr	r1, [pc, #24]	; (800274c <dmaInit+0x3c>)
#if STM32_DMA2_NUM_CHANNELS > 0
  DMA2->IFCR = 0xFFFFFFFFU;
 8002732:	4a07      	ldr	r2, [pc, #28]	; (8002750 <dmaInit+0x40>)
  dma_streams_mask = 0U;
  for (i = 0; i < STM32_DMA_STREAMS; i++) {
    _stm32_dma_streams[i].channel->CCR = 0U;
    _stm32_dma_isr_redir[i].dma_func = NULL;
  }
  DMA1->IFCR = 0xFFFFFFFFU;
 8002734:	f04f 33ff 	mov.w	r3, #4294967295
 8002738:	604b      	str	r3, [r1, #4]
#if STM32_DMA2_NUM_CHANNELS > 0
  DMA2->IFCR = 0xFFFFFFFFU;
#endif
}
 800273a:	bc30      	pop	{r4, r5}
    _stm32_dma_streams[i].channel->CCR = 0U;
    _stm32_dma_isr_redir[i].dma_func = NULL;
  }
  DMA1->IFCR = 0xFFFFFFFFU;
#if STM32_DMA2_NUM_CHANNELS > 0
  DMA2->IFCR = 0xFFFFFFFFU;
 800273c:	6053      	str	r3, [r2, #4]
#endif
}
 800273e:	4770      	bx	lr
 8002740:	20000aa8 	.word	0x20000aa8
 8002744:	08004710 	.word	0x08004710
 8002748:	20000a48 	.word	0x20000a48
 800274c:	40020000 	.word	0x40020000
 8002750:	40020400 	.word	0x40020400
	...

08002760 <SysTick_Handler>:
 * @brief   System Timer vector.
 * @details This interrupt is used for system tick in periodic mode.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(SysTick_Handler) {
 8002760:	b508      	push	{r3, lr}
 8002762:	2320      	movs	r3, #32
 8002764:	f383 8811 	msr	BASEPRI, r3
 *          service from the HAL.
 */
#if (OSAL_ST_MODE != OSAL_ST_MODE_NONE) || defined(__DOXYGEN__)
static inline void osalOsTimerHandlerI(void) {

  chSysTimerHandlerI();
 8002768:	f7fe fdd2 	bl	8001310 <chSysTimerHandlerI>
 800276c:	2300      	movs	r3, #0
 800276e:	f383 8811 	msr	BASEPRI, r3
  osalSysLockFromISR();
  osalOsTimerHandlerI();
  osalSysUnlockFromISR();

  OSAL_IRQ_EPILOGUE();
}
 8002772:	e8bd 4008 	ldmia.w	sp!, {r3, lr}

  osalSysLockFromISR();
  osalOsTimerHandlerI();
  osalSysUnlockFromISR();

  OSAL_IRQ_EPILOGUE();
 8002776:	f7ff ba0b 	b.w	8001b90 <_port_irq_epilogue>
 800277a:	bf00      	nop
 800277c:	0000      	movs	r0, r0
	...

08002780 <st_lld_init>:
#endif /* OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING */

#if OSAL_ST_MODE == OSAL_ST_MODE_PERIODIC
  /* Periodic systick mode, the Cortex-Mx internal systick timer is used
     in this mode.*/
  SysTick->LOAD = (STM32_HCLK / OSAL_ST_FREQUENCY) - 1;
 8002780:	f648 409f 	movw	r0, #35999	; 0x8c9f
 8002784:	4b04      	ldr	r3, [pc, #16]	; (8002798 <st_lld_init+0x18>)
  SysTick->VAL = 0;
 8002786:	2100      	movs	r1, #0
  SysTick->CTRL = SysTick_CTRL_CLKSOURCE_Msk |
 8002788:	2207      	movs	r2, #7
#endif /* OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING */

#if OSAL_ST_MODE == OSAL_ST_MODE_PERIODIC
  /* Periodic systick mode, the Cortex-Mx internal systick timer is used
     in this mode.*/
  SysTick->LOAD = (STM32_HCLK / OSAL_ST_FREQUENCY) - 1;
 800278a:	6058      	str	r0, [r3, #4]
  SysTick->VAL = 0;
 800278c:	6099      	str	r1, [r3, #8]
  SysTick->CTRL = SysTick_CTRL_CLKSOURCE_Msk |
                  SysTick_CTRL_ENABLE_Msk |
                  SysTick_CTRL_TICKINT_Msk;

  /* IRQ enabled.*/
  nvicSetSystemHandlerPriority(HANDLER_SYSTICK, STM32_ST_IRQ_PRIORITY);
 800278e:	200b      	movs	r0, #11
 8002790:	2108      	movs	r1, #8
#if OSAL_ST_MODE == OSAL_ST_MODE_PERIODIC
  /* Periodic systick mode, the Cortex-Mx internal systick timer is used
     in this mode.*/
  SysTick->LOAD = (STM32_HCLK / OSAL_ST_FREQUENCY) - 1;
  SysTick->VAL = 0;
  SysTick->CTRL = SysTick_CTRL_CLKSOURCE_Msk |
 8002792:	601a      	str	r2, [r3, #0]
                  SysTick_CTRL_ENABLE_Msk |
                  SysTick_CTRL_TICKINT_Msk;

  /* IRQ enabled.*/
  nvicSetSystemHandlerPriority(HANDLER_SYSTICK, STM32_ST_IRQ_PRIORITY);
 8002794:	f7ff be24 	b.w	80023e0 <nvicSetSystemHandlerPriority>
 8002798:	e000e010 	.word	0xe000e010
 800279c:	00000000 	.word	0x00000000

080027a0 <adc_lld_init>:
/**
 * @brief   Low level ADC driver initialization.
 *
 * @notapi
 */
void adc_lld_init(void) {
 80027a0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}

#if STM32_ADC_USE_ADC1
  /* Driver initialization.*/
  adcObjectInit(&ADCD1);
 80027a2:	4c16      	ldr	r4, [pc, #88]	; (80027fc <adc_lld_init+0x5c>)
                  STM32_DMA_CR_MINC        | STM32_DMA_CR_TCIE        |
                  STM32_DMA_CR_TEIE;

  /* Temporary activation.*/
  rccEnableADC1(FALSE);
  ADC1->CR1 = 0;
 80027a4:	2700      	movs	r7, #0
 */
void adc_lld_init(void) {

#if STM32_ADC_USE_ADC1
  /* Driver initialization.*/
  adcObjectInit(&ADCD1);
 80027a6:	4620      	mov	r0, r4
 80027a8:	f7ff fa4a 	bl	8001c40 <adcObjectInit>
  ADCD1.adc = ADC1;
 80027ac:	4b14      	ldr	r3, [pc, #80]	; (8002800 <adc_lld_init+0x60>)
  ADCD1.dmastp  = STM32_DMA1_STREAM1;
  ADCD1.dmamode = STM32_DMA_CR_PL(STM32_ADC_ADC1_DMA_PRIORITY) |
 80027ae:	f242 5e8a 	movw	lr, #9610	; 0x258a
  ADC1->CR1 = 0;
  ADC1->CR2 = ADC_CR2_ADON;

  /* Reset calibration just to be safe.*/
  ADC1->CR2 = ADC_CR2_ADON | ADC_CR2_RSTCAL;
  while ((ADC1->CR2 & ADC_CR2_RSTCAL) != 0)
 80027b2:	4619      	mov	r1, r3
                  STM32_DMA_CR_MSIZE_HWORD | STM32_DMA_CR_PSIZE_HWORD |
                  STM32_DMA_CR_MINC        | STM32_DMA_CR_TCIE        |
                  STM32_DMA_CR_TEIE;

  /* Temporary activation.*/
  rccEnableADC1(FALSE);
 80027b4:	4813      	ldr	r0, [pc, #76]	; (8002804 <adc_lld_init+0x64>)

#if STM32_ADC_USE_ADC1
  /* Driver initialization.*/
  adcObjectInit(&ADCD1);
  ADCD1.adc = ADC1;
  ADCD1.dmastp  = STM32_DMA1_STREAM1;
 80027b6:	f8df c050 	ldr.w	ip, [pc, #80]	; 8002808 <adc_lld_init+0x68>
                  STM32_DMA_CR_MSIZE_HWORD | STM32_DMA_CR_PSIZE_HWORD |
                  STM32_DMA_CR_MINC        | STM32_DMA_CR_TCIE        |
                  STM32_DMA_CR_TEIE;

  /* Temporary activation.*/
  rccEnableADC1(FALSE);
 80027ba:	6982      	ldr	r2, [r0, #24]
  ADC1->CR1 = 0;
  ADC1->CR2 = ADC_CR2_ADON;
 80027bc:	2601      	movs	r6, #1
                  STM32_DMA_CR_MSIZE_HWORD | STM32_DMA_CR_PSIZE_HWORD |
                  STM32_DMA_CR_MINC        | STM32_DMA_CR_TCIE        |
                  STM32_DMA_CR_TEIE;

  /* Temporary activation.*/
  rccEnableADC1(FALSE);
 80027be:	f442 7200 	orr.w	r2, r2, #512	; 0x200
  ADC1->CR1 = 0;
  ADC1->CR2 = ADC_CR2_ADON;

  /* Reset calibration just to be safe.*/
  ADC1->CR2 = ADC_CR2_ADON | ADC_CR2_RSTCAL;
 80027c2:	2509      	movs	r5, #9

#if STM32_ADC_USE_ADC1
  /* Driver initialization.*/
  adcObjectInit(&ADCD1);
  ADCD1.adc = ADC1;
  ADCD1.dmastp  = STM32_DMA1_STREAM1;
 80027c4:	f8c4 c018 	str.w	ip, [r4, #24]
  ADCD1.dmamode = STM32_DMA_CR_PL(STM32_ADC_ADC1_DMA_PRIORITY) |
 80027c8:	f8c4 e01c 	str.w	lr, [r4, #28]
void adc_lld_init(void) {

#if STM32_ADC_USE_ADC1
  /* Driver initialization.*/
  adcObjectInit(&ADCD1);
  ADCD1.adc = ADC1;
 80027cc:	6163      	str	r3, [r4, #20]
                  STM32_DMA_CR_MSIZE_HWORD | STM32_DMA_CR_PSIZE_HWORD |
                  STM32_DMA_CR_MINC        | STM32_DMA_CR_TCIE        |
                  STM32_DMA_CR_TEIE;

  /* Temporary activation.*/
  rccEnableADC1(FALSE);
 80027ce:	6182      	str	r2, [r0, #24]
  ADC1->CR1 = 0;
 80027d0:	605f      	str	r7, [r3, #4]
  ADC1->CR2 = ADC_CR2_ADON;
 80027d2:	609e      	str	r6, [r3, #8]

  /* Reset calibration just to be safe.*/
  ADC1->CR2 = ADC_CR2_ADON | ADC_CR2_RSTCAL;
 80027d4:	609d      	str	r5, [r3, #8]
  while ((ADC1->CR2 & ADC_CR2_RSTCAL) != 0)
 80027d6:	688b      	ldr	r3, [r1, #8]
 80027d8:	4a09      	ldr	r2, [pc, #36]	; (8002800 <adc_lld_init+0x60>)
 80027da:	071b      	lsls	r3, r3, #28
 80027dc:	d4fb      	bmi.n	80027d6 <adc_lld_init+0x36>
    ;

  /* Calibration.*/
  ADC1->CR2 = ADC_CR2_ADON | ADC_CR2_CAL;
  while ((ADC1->CR2 & ADC_CR2_CAL) != 0)
 80027de:	4611      	mov	r1, r2
  ADC1->CR2 = ADC_CR2_ADON | ADC_CR2_RSTCAL;
  while ((ADC1->CR2 & ADC_CR2_RSTCAL) != 0)
    ;

  /* Calibration.*/
  ADC1->CR2 = ADC_CR2_ADON | ADC_CR2_CAL;
 80027e0:	2305      	movs	r3, #5
 80027e2:	6093      	str	r3, [r2, #8]
  while ((ADC1->CR2 & ADC_CR2_CAL) != 0)
 80027e4:	688b      	ldr	r3, [r1, #8]
 80027e6:	4a06      	ldr	r2, [pc, #24]	; (8002800 <adc_lld_init+0x60>)
 80027e8:	f013 0304 	ands.w	r3, r3, #4
 80027ec:	d1fa      	bne.n	80027e4 <adc_lld_init+0x44>
    ;

  /* Return the ADC in low power mode.*/
  ADC1->CR2 = 0;
  rccDisableADC1(FALSE);
 80027ee:	4905      	ldr	r1, [pc, #20]	; (8002804 <adc_lld_init+0x64>)
  ADC1->CR2 = ADC_CR2_ADON | ADC_CR2_CAL;
  while ((ADC1->CR2 & ADC_CR2_CAL) != 0)
    ;

  /* Return the ADC in low power mode.*/
  ADC1->CR2 = 0;
 80027f0:	6093      	str	r3, [r2, #8]
  rccDisableADC1(FALSE);
 80027f2:	698b      	ldr	r3, [r1, #24]
 80027f4:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 80027f8:	618b      	str	r3, [r1, #24]
 80027fa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80027fc:	20000aac 	.word	0x20000aac
 8002800:	40012400 	.word	0x40012400
 8002804:	40021000 	.word	0x40021000
 8002808:	08004710 	.word	0x08004710
 800280c:	00000000 	.word	0x00000000

08002810 <_pal_lld_init>:
void _pal_lld_init(const PALConfig *config) {

  /*
   * Enables the GPIO related clocks.
   */
  rccEnableAPB2(APB2_EN_MASK, FALSE);
 8002810:	491e      	ldr	r1, [pc, #120]	; (800288c <_pal_lld_init+0x7c>)
 *
 * @param[in] config    the STM32 ports configuration
 *
 * @notapi
 */
void _pal_lld_init(const PALConfig *config) {
 8002812:	b4f0      	push	{r4, r5, r6, r7}

  /*
   * Enables the GPIO related clocks.
   */
  rccEnableAPB2(APB2_EN_MASK, FALSE);
 8002814:	698b      	ldr	r3, [r1, #24]

  /*
   * Initial GPIO setup.
   */
  GPIOA->ODR = config->PAData.odr;
 8002816:	4a1e      	ldr	r2, [pc, #120]	; (8002890 <_pal_lld_init+0x80>)
void _pal_lld_init(const PALConfig *config) {

  /*
   * Enables the GPIO related clocks.
   */
  rccEnableAPB2(APB2_EN_MASK, FALSE);
 8002818:	f443 73fe 	orr.w	r3, r3, #508	; 0x1fc
 800281c:	f043 0301 	orr.w	r3, r3, #1
 8002820:	618b      	str	r3, [r1, #24]

  /*
   * Initial GPIO setup.
   */
  GPIOA->ODR = config->PAData.odr;
 8002822:	6803      	ldr	r3, [r0, #0]
  GPIOA->CRH = config->PAData.crh;
  GPIOA->CRL = config->PAData.crl;
  GPIOB->ODR = config->PBData.odr;
 8002824:	4e1b      	ldr	r6, [pc, #108]	; (8002894 <_pal_lld_init+0x84>)
  rccEnableAPB2(APB2_EN_MASK, FALSE);

  /*
   * Initial GPIO setup.
   */
  GPIOA->ODR = config->PAData.odr;
 8002826:	60d3      	str	r3, [r2, #12]
  GPIOA->CRH = config->PAData.crh;
 8002828:	6883      	ldr	r3, [r0, #8]
  GPIOA->CRL = config->PAData.crl;
  GPIOB->ODR = config->PBData.odr;
  GPIOB->CRH = config->PBData.crh;
  GPIOB->CRL = config->PBData.crl;
  GPIOC->ODR = config->PCData.odr;
 800282a:	4d1b      	ldr	r5, [pc, #108]	; (8002898 <_pal_lld_init+0x88>)

  /*
   * Initial GPIO setup.
   */
  GPIOA->ODR = config->PAData.odr;
  GPIOA->CRH = config->PAData.crh;
 800282c:	6053      	str	r3, [r2, #4]
  GPIOA->CRL = config->PAData.crl;
 800282e:	6843      	ldr	r3, [r0, #4]
  GPIOB->CRH = config->PBData.crh;
  GPIOB->CRL = config->PBData.crl;
  GPIOC->ODR = config->PCData.odr;
  GPIOC->CRH = config->PCData.crh;
  GPIOC->CRL = config->PCData.crl;
  GPIOD->ODR = config->PDData.odr;
 8002830:	4c1a      	ldr	r4, [pc, #104]	; (800289c <_pal_lld_init+0x8c>)
  /*
   * Initial GPIO setup.
   */
  GPIOA->ODR = config->PAData.odr;
  GPIOA->CRH = config->PAData.crh;
  GPIOA->CRL = config->PAData.crl;
 8002832:	6013      	str	r3, [r2, #0]
  GPIOB->ODR = config->PBData.odr;
 8002834:	68c3      	ldr	r3, [r0, #12]
  GPIOC->CRL = config->PCData.crl;
  GPIOD->ODR = config->PDData.odr;
  GPIOD->CRH = config->PDData.crh;
  GPIOD->CRL = config->PDData.crl;
#if STM32_HAS_GPIOE || defined(__DOXYGEN__)
  GPIOE->ODR = config->PEData.odr;
 8002836:	f5a1 4178 	sub.w	r1, r1, #63488	; 0xf800
   * Initial GPIO setup.
   */
  GPIOA->ODR = config->PAData.odr;
  GPIOA->CRH = config->PAData.crh;
  GPIOA->CRL = config->PAData.crl;
  GPIOB->ODR = config->PBData.odr;
 800283a:	60f3      	str	r3, [r6, #12]
  GPIOB->CRH = config->PBData.crh;
 800283c:	6947      	ldr	r7, [r0, #20]
#if STM32_HAS_GPIOE || defined(__DOXYGEN__)
  GPIOE->ODR = config->PEData.odr;
  GPIOE->CRH = config->PEData.crh;
  GPIOE->CRL = config->PEData.crl;
#if STM32_HAS_GPIOF || defined(__DOXYGEN__)
  GPIOF->ODR = config->PFData.odr;
 800283e:	f502 52a0 	add.w	r2, r2, #5120	; 0x1400
   */
  GPIOA->ODR = config->PAData.odr;
  GPIOA->CRH = config->PAData.crh;
  GPIOA->CRL = config->PAData.crl;
  GPIOB->ODR = config->PBData.odr;
  GPIOB->CRH = config->PBData.crh;
 8002842:	6077      	str	r7, [r6, #4]
  GPIOB->CRL = config->PBData.crl;
 8002844:	6907      	ldr	r7, [r0, #16]
#if STM32_HAS_GPIOF || defined(__DOXYGEN__)
  GPIOF->ODR = config->PFData.odr;
  GPIOF->CRH = config->PFData.crh;
  GPIOF->CRL = config->PFData.crl;
#if STM32_HAS_GPIOG || defined(__DOXYGEN__)
  GPIOG->ODR = config->PGData.odr;
 8002846:	4b16      	ldr	r3, [pc, #88]	; (80028a0 <_pal_lld_init+0x90>)
  GPIOA->ODR = config->PAData.odr;
  GPIOA->CRH = config->PAData.crh;
  GPIOA->CRL = config->PAData.crl;
  GPIOB->ODR = config->PBData.odr;
  GPIOB->CRH = config->PBData.crh;
  GPIOB->CRL = config->PBData.crl;
 8002848:	6037      	str	r7, [r6, #0]
  GPIOC->ODR = config->PCData.odr;
 800284a:	6986      	ldr	r6, [r0, #24]
 800284c:	60ee      	str	r6, [r5, #12]
  GPIOC->CRH = config->PCData.crh;
 800284e:	6a06      	ldr	r6, [r0, #32]
 8002850:	606e      	str	r6, [r5, #4]
  GPIOC->CRL = config->PCData.crl;
 8002852:	69c6      	ldr	r6, [r0, #28]
 8002854:	602e      	str	r6, [r5, #0]
  GPIOD->ODR = config->PDData.odr;
 8002856:	6a45      	ldr	r5, [r0, #36]	; 0x24
 8002858:	60e5      	str	r5, [r4, #12]
  GPIOD->CRH = config->PDData.crh;
 800285a:	6ac5      	ldr	r5, [r0, #44]	; 0x2c
 800285c:	6065      	str	r5, [r4, #4]
  GPIOD->CRL = config->PDData.crl;
 800285e:	6a85      	ldr	r5, [r0, #40]	; 0x28
 8002860:	6025      	str	r5, [r4, #0]
#if STM32_HAS_GPIOE || defined(__DOXYGEN__)
  GPIOE->ODR = config->PEData.odr;
 8002862:	6b04      	ldr	r4, [r0, #48]	; 0x30
 8002864:	60cc      	str	r4, [r1, #12]
  GPIOE->CRH = config->PEData.crh;
 8002866:	6b84      	ldr	r4, [r0, #56]	; 0x38
 8002868:	604c      	str	r4, [r1, #4]
  GPIOE->CRL = config->PEData.crl;
 800286a:	6b44      	ldr	r4, [r0, #52]	; 0x34
 800286c:	600c      	str	r4, [r1, #0]
#if STM32_HAS_GPIOF || defined(__DOXYGEN__)
  GPIOF->ODR = config->PFData.odr;
 800286e:	6bc1      	ldr	r1, [r0, #60]	; 0x3c
  GPIOG->CRH = config->PGData.crh;
  GPIOG->CRL = config->PGData.crl;
#endif
#endif
#endif
}
 8002870:	bcf0      	pop	{r4, r5, r6, r7}
#if STM32_HAS_GPIOE || defined(__DOXYGEN__)
  GPIOE->ODR = config->PEData.odr;
  GPIOE->CRH = config->PEData.crh;
  GPIOE->CRL = config->PEData.crl;
#if STM32_HAS_GPIOF || defined(__DOXYGEN__)
  GPIOF->ODR = config->PFData.odr;
 8002872:	60d1      	str	r1, [r2, #12]
  GPIOF->CRH = config->PFData.crh;
 8002874:	6c41      	ldr	r1, [r0, #68]	; 0x44
 8002876:	6051      	str	r1, [r2, #4]
  GPIOF->CRL = config->PFData.crl;
 8002878:	6c01      	ldr	r1, [r0, #64]	; 0x40
 800287a:	6011      	str	r1, [r2, #0]
#if STM32_HAS_GPIOG || defined(__DOXYGEN__)
  GPIOG->ODR = config->PGData.odr;
 800287c:	6c82      	ldr	r2, [r0, #72]	; 0x48
 800287e:	60da      	str	r2, [r3, #12]
  GPIOG->CRH = config->PGData.crh;
 8002880:	6d02      	ldr	r2, [r0, #80]	; 0x50
 8002882:	605a      	str	r2, [r3, #4]
  GPIOG->CRL = config->PGData.crl;
 8002884:	6cc2      	ldr	r2, [r0, #76]	; 0x4c
 8002886:	601a      	str	r2, [r3, #0]
#endif
#endif
#endif
}
 8002888:	4770      	bx	lr
 800288a:	bf00      	nop
 800288c:	40021000 	.word	0x40021000
 8002890:	40010800 	.word	0x40010800
 8002894:	40010c00 	.word	0x40010c00
 8002898:	40011000 	.word	0x40011000
 800289c:	40011400 	.word	0x40011400
 80028a0:	40012000 	.word	0x40012000
	...

080028b0 <VectorC4>:
 * @param[in] i2cp      pointer to the @p I2CDriver object
 *
 * @notapi
 */
static void i2c_lld_serve_event_interrupt(I2CDriver *i2cp) {
  I2C_TypeDef *dp = i2cp->i2c;
 80028b0:	483a      	ldr	r0, [pc, #232]	; (800299c <VectorC4+0xec>)
/**
 * @brief   I2C2 event interrupt handler.
 *
 * @notapi
 */
OSAL_IRQ_HANDLER(STM32_I2C2_EVENT_HANDLER) {
 80028b2:	b570      	push	{r4, r5, r6, lr}
 * @param[in] i2cp      pointer to the @p I2CDriver object
 *
 * @notapi
 */
static void i2c_lld_serve_event_interrupt(I2CDriver *i2cp) {
  I2C_TypeDef *dp = i2cp->i2c;
 80028b4:	6b44      	ldr	r4, [r0, #52]	; 0x34
  uint32_t event = dp->SR1;

  /* Interrupts are disabled just before dmaStreamEnable() because there
     is no need of interrupts until next transaction begin. All the work is
     done by the DMA.*/
  switch (I2C_EV_MASK & (event | (regSR2 << 16))) {
 80028b6:	4a3a      	ldr	r2, [pc, #232]	; (80029a0 <VectorC4+0xf0>)
 *
 * @notapi
 */
static void i2c_lld_serve_event_interrupt(I2CDriver *i2cp) {
  I2C_TypeDef *dp = i2cp->i2c;
  uint32_t regSR2 = dp->SR2;
 80028b8:	69a3      	ldr	r3, [r4, #24]
  uint32_t event = dp->SR1;
 80028ba:	6965      	ldr	r5, [r4, #20]

  /* Interrupts are disabled just before dmaStreamEnable() because there
     is no need of interrupts until next transaction begin. All the work is
     done by the DMA.*/
  switch (I2C_EV_MASK & (event | (regSR2 << 16))) {
 80028bc:	ea45 4303 	orr.w	r3, r5, r3, lsl #16
 80028c0:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 80028c4:	4293      	cmp	r3, r2
 80028c6:	d04c      	beq.n	8002962 <VectorC4+0xb2>
 80028c8:	d81e      	bhi.n	8002908 <VectorC4+0x58>
 80028ca:	3a07      	subs	r2, #7
 80028cc:	4293      	cmp	r3, r2
 80028ce:	d03c      	beq.n	800294a <VectorC4+0x9a>
 80028d0:	3201      	adds	r2, #1
 80028d2:	4293      	cmp	r3, r2
 80028d4:	d110      	bne.n	80028f8 <VectorC4+0x48>
  case I2C_EV9_MASTER_ADD10:
    /* Set second addr byte (10-bit addressing)*/
    dp->DR = (0xFF & (i2cp->addr >> 1));
    break;
  case I2C_EV6_MASTER_REC_MODE_SELECTED:
    dp->CR2 &= ~I2C_CR2_ITEVTEN;
 80028d6:	6862      	ldr	r2, [r4, #4]
    dmaStreamEnable(i2cp->dmarx);
 80028d8:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
  case I2C_EV9_MASTER_ADD10:
    /* Set second addr byte (10-bit addressing)*/
    dp->DR = (0xFF & (i2cp->addr >> 1));
    break;
  case I2C_EV6_MASTER_REC_MODE_SELECTED:
    dp->CR2 &= ~I2C_CR2_ITEVTEN;
 80028da:	f422 7200 	bic.w	r2, r2, #512	; 0x200
    dmaStreamEnable(i2cp->dmarx);
 80028de:	685b      	ldr	r3, [r3, #4]
  case I2C_EV9_MASTER_ADD10:
    /* Set second addr byte (10-bit addressing)*/
    dp->DR = (0xFF & (i2cp->addr >> 1));
    break;
  case I2C_EV6_MASTER_REC_MODE_SELECTED:
    dp->CR2 &= ~I2C_CR2_ITEVTEN;
 80028e0:	6062      	str	r2, [r4, #4]
    dmaStreamEnable(i2cp->dmarx);
 80028e2:	681a      	ldr	r2, [r3, #0]
 80028e4:	f042 0201 	orr.w	r2, r2, #1
 80028e8:	601a      	str	r2, [r3, #0]
    dp->CR2 |= I2C_CR2_LAST;                 /* Needed in receiver mode. */
 80028ea:	6862      	ldr	r2, [r4, #4]
 80028ec:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 80028f0:	6062      	str	r2, [r4, #4]
    if (dmaStreamGetTransactionSize(i2cp->dmarx) < 2)
 80028f2:	685b      	ldr	r3, [r3, #4]
 80028f4:	2b01      	cmp	r3, #1
 80028f6:	d94b      	bls.n	8002990 <VectorC4+0xe0>
    break;
  default:
    break;
  }
  /* Clear ADDR flag. */
  if (event & (I2C_SR1_ADDR | I2C_SR1_ADD10))
 80028f8:	f015 0f0a 	tst.w	r5, #10
    (void)dp->SR2;
 80028fc:	bf18      	it	ne
 80028fe:	69a3      	ldrne	r3, [r4, #24]
  OSAL_IRQ_PROLOGUE();

  i2c_lld_serve_event_interrupt(&I2CD2);

  OSAL_IRQ_EPILOGUE();
}
 8002900:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}

  OSAL_IRQ_PROLOGUE();

  i2c_lld_serve_event_interrupt(&I2CD2);

  OSAL_IRQ_EPILOGUE();
 8002904:	f7ff b944 	b.w	8001b90 <_port_irq_epilogue>
  uint32_t event = dp->SR1;

  /* Interrupts are disabled just before dmaStreamEnable() because there
     is no need of interrupts until next transaction begin. All the work is
     done by the DMA.*/
  switch (I2C_EV_MASK & (event | (regSR2 << 16))) {
 8002908:	4a26      	ldr	r2, [pc, #152]	; (80029a4 <VectorC4+0xf4>)
 800290a:	4293      	cmp	r3, r2
 800290c:	d012      	beq.n	8002934 <VectorC4+0x84>
 800290e:	3202      	adds	r2, #2
 8002910:	4293      	cmp	r3, r2
 8002912:	d1f1      	bne.n	80028f8 <VectorC4+0x48>
    dp->CR2 &= ~I2C_CR2_ITEVTEN;
    dmaStreamEnable(i2cp->dmatx);
    break;
  case I2C_EV8_2_MASTER_BYTE_TRANSMITTED:
    /* Catches BTF event after the end of transmission.*/
    if (dmaStreamGetTransactionSize(i2cp->dmarx) > 0) {
 8002914:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 8002916:	685b      	ldr	r3, [r3, #4]
 8002918:	685e      	ldr	r6, [r3, #4]
 800291a:	b33e      	cbz	r6, 800296c <VectorC4+0xbc>
      /* Starts "read after write" operation, LSB = 1 -> receive.*/
      i2cp->addr |= 0x01;
      dp->CR1 |= I2C_CR1_START | I2C_CR1_ACK;
 800291c:	6823      	ldr	r3, [r4, #0]
    break;
  case I2C_EV8_2_MASTER_BYTE_TRANSMITTED:
    /* Catches BTF event after the end of transmission.*/
    if (dmaStreamGetTransactionSize(i2cp->dmarx) > 0) {
      /* Starts "read after write" operation, LSB = 1 -> receive.*/
      i2cp->addr |= 0x01;
 800291e:	8c02      	ldrh	r2, [r0, #32]
      dp->CR1 |= I2C_CR1_START | I2C_CR1_ACK;
 8002920:	f443 63a0 	orr.w	r3, r3, #1280	; 0x500
    break;
  case I2C_EV8_2_MASTER_BYTE_TRANSMITTED:
    /* Catches BTF event after the end of transmission.*/
    if (dmaStreamGetTransactionSize(i2cp->dmarx) > 0) {
      /* Starts "read after write" operation, LSB = 1 -> receive.*/
      i2cp->addr |= 0x01;
 8002924:	f042 0201 	orr.w	r2, r2, #1
 8002928:	8402      	strh	r2, [r0, #32]
      dp->CR1 |= I2C_CR1_START | I2C_CR1_ACK;
 800292a:	6023      	str	r3, [r4, #0]
  OSAL_IRQ_PROLOGUE();

  i2c_lld_serve_event_interrupt(&I2CD2);

  OSAL_IRQ_EPILOGUE();
}
 800292c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}

  OSAL_IRQ_PROLOGUE();

  i2c_lld_serve_event_interrupt(&I2CD2);

  OSAL_IRQ_EPILOGUE();
 8002930:	f7ff b92e 	b.w	8001b90 <_port_irq_epilogue>
    dp->CR2 |= I2C_CR2_LAST;                 /* Needed in receiver mode. */
    if (dmaStreamGetTransactionSize(i2cp->dmarx) < 2)
      dp->CR1 &= ~I2C_CR1_ACK;
    break;
  case I2C_EV6_MASTER_TRA_MODE_SELECTED:
    dp->CR2 &= ~I2C_CR2_ITEVTEN;
 8002934:	6863      	ldr	r3, [r4, #4]
    dmaStreamEnable(i2cp->dmatx);
 8002936:	6b02      	ldr	r2, [r0, #48]	; 0x30
    dp->CR2 |= I2C_CR2_LAST;                 /* Needed in receiver mode. */
    if (dmaStreamGetTransactionSize(i2cp->dmarx) < 2)
      dp->CR1 &= ~I2C_CR1_ACK;
    break;
  case I2C_EV6_MASTER_TRA_MODE_SELECTED:
    dp->CR2 &= ~I2C_CR2_ITEVTEN;
 8002938:	f423 7300 	bic.w	r3, r3, #512	; 0x200
    dmaStreamEnable(i2cp->dmatx);
 800293c:	6852      	ldr	r2, [r2, #4]
    dp->CR2 |= I2C_CR2_LAST;                 /* Needed in receiver mode. */
    if (dmaStreamGetTransactionSize(i2cp->dmarx) < 2)
      dp->CR1 &= ~I2C_CR1_ACK;
    break;
  case I2C_EV6_MASTER_TRA_MODE_SELECTED:
    dp->CR2 &= ~I2C_CR2_ITEVTEN;
 800293e:	6063      	str	r3, [r4, #4]
    dmaStreamEnable(i2cp->dmatx);
 8002940:	6813      	ldr	r3, [r2, #0]
 8002942:	f043 0301 	orr.w	r3, r3, #1
 8002946:	6013      	str	r3, [r2, #0]
 8002948:	e7d6      	b.n	80028f8 <VectorC4+0x48>
  /* Interrupts are disabled just before dmaStreamEnable() because there
     is no need of interrupts until next transaction begin. All the work is
     done by the DMA.*/
  switch (I2C_EV_MASK & (event | (regSR2 << 16))) {
  case I2C_EV5_MASTER_MODE_SELECT:
    if ((i2cp->addr >> 8) > 0) { 
 800294a:	8c03      	ldrh	r3, [r0, #32]
 800294c:	0a1a      	lsrs	r2, r3, #8
 800294e:	d00b      	beq.n	8002968 <VectorC4+0xb8>
      /* 10-bit address: 1 1 1 1 0 X X R/W */
      dp->DR = 0xF0 | (0x6 & (i2cp->addr >> 8)) | (0x1 & i2cp->addr);
 8002950:	f003 0301 	and.w	r3, r3, #1
 8002954:	f043 03f0 	orr.w	r3, r3, #240	; 0xf0
 8002958:	f002 0206 	and.w	r2, r2, #6
 800295c:	4313      	orrs	r3, r2
 800295e:	6123      	str	r3, [r4, #16]
 8002960:	e7ca      	b.n	80028f8 <VectorC4+0x48>
      dp->DR = i2cp->addr;
    }
    break;
  case I2C_EV9_MASTER_ADD10:
    /* Set second addr byte (10-bit addressing)*/
    dp->DR = (0xFF & (i2cp->addr >> 1));
 8002962:	8c03      	ldrh	r3, [r0, #32]
 8002964:	f3c3 0347 	ubfx	r3, r3, #1, #8
 8002968:	6123      	str	r3, [r4, #16]
 800296a:	e7c5      	b.n	80028f8 <VectorC4+0x48>
      /* Starts "read after write" operation, LSB = 1 -> receive.*/
      i2cp->addr |= 0x01;
      dp->CR1 |= I2C_CR1_START | I2C_CR1_ACK;
      return;
    }
    dp->CR2 &= ~I2C_CR2_ITEVTEN;
 800296c:	6863      	ldr	r3, [r4, #4]
 800296e:	2220      	movs	r2, #32
 8002970:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 8002974:	6063      	str	r3, [r4, #4]
    dp->CR1 |= I2C_CR1_STOP;
 8002976:	6823      	ldr	r3, [r4, #0]
 8002978:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 800297c:	6023      	str	r3, [r4, #0]
 800297e:	f382 8811 	msr	BASEPRI, r2
 *
 * @iclass
 */
static inline void osalThreadResumeI(thread_reference_t *trp, msg_t msg) {

  chThdResumeI(trp, msg);
 8002982:	301c      	adds	r0, #28
 8002984:	4631      	mov	r1, r6
 8002986:	f7fe feb3 	bl	80016f0 <chThdResumeI>
 800298a:	f386 8811 	msr	BASEPRI, r6
 800298e:	e7b3      	b.n	80028f8 <VectorC4+0x48>
  case I2C_EV6_MASTER_REC_MODE_SELECTED:
    dp->CR2 &= ~I2C_CR2_ITEVTEN;
    dmaStreamEnable(i2cp->dmarx);
    dp->CR2 |= I2C_CR2_LAST;                 /* Needed in receiver mode. */
    if (dmaStreamGetTransactionSize(i2cp->dmarx) < 2)
      dp->CR1 &= ~I2C_CR1_ACK;
 8002990:	6823      	ldr	r3, [r4, #0]
 8002992:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8002996:	6023      	str	r3, [r4, #0]
 8002998:	e7ae      	b.n	80028f8 <VectorC4+0x48>
 800299a:	bf00      	nop
 800299c:	20000acc 	.word	0x20000acc
 80029a0:	00030008 	.word	0x00030008
 80029a4:	00070082 	.word	0x00070082
	...

080029b0 <VectorC8>:
 * @brief   I2C2 error interrupt handler.
 *
 * @notapi
 */
OSAL_IRQ_HANDLER(STM32_I2C2_ERROR_HANDLER) {
  uint16_t sr = I2CD2.i2c->SR1;
 80029b0:	4936      	ldr	r1, [pc, #216]	; (8002a8c <VectorC8+0xdc>)
/**
 * @brief   I2C2 error interrupt handler.
 *
 * @notapi
 */
OSAL_IRQ_HANDLER(STM32_I2C2_ERROR_HANDLER) {
 80029b2:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  uint16_t sr = I2CD2.i2c->SR1;
 80029b4:	6b48      	ldr	r0, [r1, #52]	; 0x34
 * @notapi
 */
static void i2c_lld_serve_error_interrupt(I2CDriver *i2cp, uint16_t sr) {

  /* Clears interrupt flags just to be safe.*/
  dmaStreamDisable(i2cp->dmatx);
 80029b6:	6b0d      	ldr	r5, [r1, #48]	; 0x30
 * @brief   I2C2 error interrupt handler.
 *
 * @notapi
 */
OSAL_IRQ_HANDLER(STM32_I2C2_ERROR_HANDLER) {
  uint16_t sr = I2CD2.i2c->SR1;
 80029b8:	6947      	ldr	r7, [r0, #20]
 * @notapi
 */
static void i2c_lld_serve_error_interrupt(I2CDriver *i2cp, uint16_t sr) {

  /* Clears interrupt flags just to be safe.*/
  dmaStreamDisable(i2cp->dmatx);
 80029ba:	f8d5 e004 	ldr.w	lr, [r5, #4]
 * @brief   I2C2 error interrupt handler.
 *
 * @notapi
 */
OSAL_IRQ_HANDLER(STM32_I2C2_ERROR_HANDLER) {
  uint16_t sr = I2CD2.i2c->SR1;
 80029be:	b2ba      	uxth	r2, r7

  OSAL_IRQ_PROLOGUE();

  I2CD2.i2c->SR1 = ~(sr & I2C_ERROR_MASK);
 80029c0:	f402 435f 	and.w	r3, r2, #57088	; 0xdf00
 80029c4:	43db      	mvns	r3, r3
 80029c6:	6143      	str	r3, [r0, #20]
 * @notapi
 */
static void i2c_lld_serve_error_interrupt(I2CDriver *i2cp, uint16_t sr) {

  /* Clears interrupt flags just to be safe.*/
  dmaStreamDisable(i2cp->dmatx);
 80029c8:	f8de 6000 	ldr.w	r6, [lr]
  dmaStreamDisable(i2cp->dmarx);
 80029cc:	6acb      	ldr	r3, [r1, #44]	; 0x2c
 * @notapi
 */
static void i2c_lld_serve_error_interrupt(I2CDriver *i2cp, uint16_t sr) {

  /* Clears interrupt flags just to be safe.*/
  dmaStreamDisable(i2cp->dmatx);
 80029ce:	f026 060f 	bic.w	r6, r6, #15
 80029d2:	f8ce 6000 	str.w	r6, [lr]
 80029d6:	7c2e      	ldrb	r6, [r5, #16]
 80029d8:	240f      	movs	r4, #15
 80029da:	682d      	ldr	r5, [r5, #0]
 80029dc:	fa04 fe06 	lsl.w	lr, r4, r6
  dmaStreamDisable(i2cp->dmarx);
 80029e0:	685e      	ldr	r6, [r3, #4]
 * @notapi
 */
static void i2c_lld_serve_error_interrupt(I2CDriver *i2cp, uint16_t sr) {

  /* Clears interrupt flags just to be safe.*/
  dmaStreamDisable(i2cp->dmatx);
 80029e2:	f8c5 e004 	str.w	lr, [r5, #4]
  dmaStreamDisable(i2cp->dmarx);
 80029e6:	6835      	ldr	r5, [r6, #0]
 80029e8:	f8d3 e000 	ldr.w	lr, [r3]
 80029ec:	f025 050f 	bic.w	r5, r5, #15
 80029f0:	6035      	str	r5, [r6, #0]
 80029f2:	7c1d      	ldrb	r5, [r3, #16]

  i2cp->errors = I2C_NO_ERROR;

  if (sr & I2C_SR1_BERR)                            /* Bus error.           */
 80029f4:	f402 7380 	and.w	r3, r2, #256	; 0x100
 */
static void i2c_lld_serve_error_interrupt(I2CDriver *i2cp, uint16_t sr) {

  /* Clears interrupt flags just to be safe.*/
  dmaStreamDisable(i2cp->dmatx);
  dmaStreamDisable(i2cp->dmarx);
 80029f8:	40ac      	lsls	r4, r5

  i2cp->errors = I2C_NO_ERROR;

  if (sr & I2C_SR1_BERR)                            /* Bus error.           */
 80029fa:	b29b      	uxth	r3, r3
 */
static void i2c_lld_serve_error_interrupt(I2CDriver *i2cp, uint16_t sr) {

  /* Clears interrupt flags just to be safe.*/
  dmaStreamDisable(i2cp->dmatx);
  dmaStreamDisable(i2cp->dmarx);
 80029fc:	f8ce 4004 	str.w	r4, [lr, #4]

  i2cp->errors = I2C_NO_ERROR;

  if (sr & I2C_SR1_BERR)                            /* Bus error.           */
 8002a00:	2b00      	cmp	r3, #0
 8002a02:	d13a      	bne.n	8002a7a <VectorC8+0xca>

  /* Clears interrupt flags just to be safe.*/
  dmaStreamDisable(i2cp->dmatx);
  dmaStreamDisable(i2cp->dmarx);

  i2cp->errors = I2C_NO_ERROR;
 8002a04:	608b      	str	r3, [r1, #8]

  if (sr & I2C_SR1_BERR)                            /* Bus error.           */
    i2cp->errors |= I2C_BUS_ERROR;

  if (sr & I2C_SR1_ARLO)                            /* Arbitration lost.    */
 8002a06:	0595      	lsls	r5, r2, #22
    i2cp->errors |= I2C_ARBITRATION_LOST;
 8002a08:	bf44      	itt	mi
 8002a0a:	f043 0302 	orrmi.w	r3, r3, #2
 8002a0e:	608b      	strmi	r3, [r1, #8]

  if (sr & I2C_SR1_AF) {                            /* Acknowledge fail.    */
 8002a10:	0554      	lsls	r4, r2, #21
 8002a12:	d50a      	bpl.n	8002a2a <VectorC8+0x7a>
    i2cp->i2c->CR2 &= ~I2C_CR2_ITEVTEN;
 8002a14:	6844      	ldr	r4, [r0, #4]
    i2cp->i2c->CR1 |= I2C_CR1_STOP;                 /* Setting stop bit.    */
    i2cp->errors |= I2C_ACK_FAILURE;
 8002a16:	f043 0304 	orr.w	r3, r3, #4

  if (sr & I2C_SR1_ARLO)                            /* Arbitration lost.    */
    i2cp->errors |= I2C_ARBITRATION_LOST;

  if (sr & I2C_SR1_AF) {                            /* Acknowledge fail.    */
    i2cp->i2c->CR2 &= ~I2C_CR2_ITEVTEN;
 8002a1a:	f424 7400 	bic.w	r4, r4, #512	; 0x200
 8002a1e:	6044      	str	r4, [r0, #4]
    i2cp->i2c->CR1 |= I2C_CR1_STOP;                 /* Setting stop bit.    */
 8002a20:	6804      	ldr	r4, [r0, #0]
 8002a22:	f444 7400 	orr.w	r4, r4, #512	; 0x200
 8002a26:	6004      	str	r4, [r0, #0]
    i2cp->errors |= I2C_ACK_FAILURE;
 8002a28:	608b      	str	r3, [r1, #8]
  }

  if (sr & I2C_SR1_OVR)                             /* Overrun.             */
 8002a2a:	0516      	lsls	r6, r2, #20
    i2cp->errors |= I2C_OVERRUN;
 8002a2c:	bf44      	itt	mi
 8002a2e:	f043 0308 	orrmi.w	r3, r3, #8
 8002a32:	608b      	strmi	r3, [r1, #8]

  if (sr & I2C_SR1_TIMEOUT)                         /* SMBus Timeout.       */
 8002a34:	0455      	lsls	r5, r2, #17
    i2cp->errors |= I2C_TIMEOUT;
 8002a36:	bf44      	itt	mi
 8002a38:	f043 0320 	orrmi.w	r3, r3, #32
 8002a3c:	608b      	strmi	r3, [r1, #8]

  if (sr & I2C_SR1_PECERR)                          /* PEC error.           */
 8002a3e:	04d4      	lsls	r4, r2, #19
 8002a40:	d513      	bpl.n	8002a6a <VectorC8+0xba>
    i2cp->errors |= I2C_PEC_ERROR;
 8002a42:	f043 0310 	orr.w	r3, r3, #16

  if (sr & I2C_SR1_SMBALERT)                        /* SMBus alert.         */
 8002a46:	0438      	lsls	r0, r7, #16

  if (sr & I2C_SR1_TIMEOUT)                         /* SMBus Timeout.       */
    i2cp->errors |= I2C_TIMEOUT;

  if (sr & I2C_SR1_PECERR)                          /* PEC error.           */
    i2cp->errors |= I2C_PEC_ERROR;
 8002a48:	608b      	str	r3, [r1, #8]

  if (sr & I2C_SR1_SMBALERT)                        /* SMBus alert.         */
 8002a4a:	d41a      	bmi.n	8002a82 <VectorC8+0xd2>
 8002a4c:	2320      	movs	r3, #32
 8002a4e:	f383 8811 	msr	BASEPRI, r3
 8002a52:	480f      	ldr	r0, [pc, #60]	; (8002a90 <VectorC8+0xe0>)
 8002a54:	f06f 0101 	mvn.w	r1, #1
 8002a58:	f7fe fe4a 	bl	80016f0 <chThdResumeI>
 8002a5c:	2300      	movs	r3, #0
 8002a5e:	f383 8811 	msr	BASEPRI, r3

  I2CD2.i2c->SR1 = ~(sr & I2C_ERROR_MASK);
  i2c_lld_serve_error_interrupt(&I2CD2, sr);

  OSAL_IRQ_EPILOGUE();
}
 8002a62:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
  OSAL_IRQ_PROLOGUE();

  I2CD2.i2c->SR1 = ~(sr & I2C_ERROR_MASK);
  i2c_lld_serve_error_interrupt(&I2CD2, sr);

  OSAL_IRQ_EPILOGUE();
 8002a66:	f7ff b893 	b.w	8001b90 <_port_irq_epilogue>
    i2cp->errors |= I2C_TIMEOUT;

  if (sr & I2C_SR1_PECERR)                          /* PEC error.           */
    i2cp->errors |= I2C_PEC_ERROR;

  if (sr & I2C_SR1_SMBALERT)                        /* SMBus alert.         */
 8002a6a:	043a      	lsls	r2, r7, #16
 8002a6c:	d409      	bmi.n	8002a82 <VectorC8+0xd2>
    i2cp->errors |= I2C_SMB_ALERT;

  /* If some error has been identified then sends wakes the waiting thread.*/
  if (i2cp->errors != I2C_NO_ERROR)
 8002a6e:	2b00      	cmp	r3, #0
 8002a70:	d1ec      	bne.n	8002a4c <VectorC8+0x9c>

  I2CD2.i2c->SR1 = ~(sr & I2C_ERROR_MASK);
  i2c_lld_serve_error_interrupt(&I2CD2, sr);

  OSAL_IRQ_EPILOGUE();
}
 8002a72:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
  OSAL_IRQ_PROLOGUE();

  I2CD2.i2c->SR1 = ~(sr & I2C_ERROR_MASK);
  i2c_lld_serve_error_interrupt(&I2CD2, sr);

  OSAL_IRQ_EPILOGUE();
 8002a76:	f7ff b88b 	b.w	8001b90 <_port_irq_epilogue>
  dmaStreamDisable(i2cp->dmarx);

  i2cp->errors = I2C_NO_ERROR;

  if (sr & I2C_SR1_BERR)                            /* Bus error.           */
    i2cp->errors |= I2C_BUS_ERROR;
 8002a7a:	2401      	movs	r4, #1
 8002a7c:	4623      	mov	r3, r4
 8002a7e:	608c      	str	r4, [r1, #8]
 8002a80:	e7c1      	b.n	8002a06 <VectorC8+0x56>

  if (sr & I2C_SR1_PECERR)                          /* PEC error.           */
    i2cp->errors |= I2C_PEC_ERROR;

  if (sr & I2C_SR1_SMBALERT)                        /* SMBus alert.         */
    i2cp->errors |= I2C_SMB_ALERT;
 8002a82:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8002a86:	608b      	str	r3, [r1, #8]
 8002a88:	e7e0      	b.n	8002a4c <VectorC8+0x9c>
 8002a8a:	bf00      	nop
 8002a8c:	20000acc 	.word	0x20000acc
 8002a90:	20000ae8 	.word	0x20000ae8
	...

08002aa0 <i2c_lld_init>:
/**
 * @brief   Low level I2C driver initialization.
 *
 * @notapi
 */
void i2c_lld_init(void) {
 8002aa0:	b510      	push	{r4, lr}
  I2CD1.dmarx  = STM32_DMA_STREAM(STM32_I2C_I2C1_RX_DMA_STREAM);
  I2CD1.dmatx  = STM32_DMA_STREAM(STM32_I2C_I2C1_TX_DMA_STREAM);
#endif /* STM32_I2C_USE_I2C1 */

#if STM32_I2C_USE_I2C2
  i2cObjectInit(&I2CD2);
 8002aa2:	4c07      	ldr	r4, [pc, #28]	; (8002ac0 <i2c_lld_init+0x20>)
 8002aa4:	4620      	mov	r0, r4
 8002aa6:	f7ff f8db 	bl	8001c60 <i2cObjectInit>
  I2CD2.thread = NULL;
  I2CD2.i2c    = I2C2;
  I2CD2.dmarx  = STM32_DMA_STREAM(STM32_I2C_I2C2_RX_DMA_STREAM);
 8002aaa:	4b06      	ldr	r3, [pc, #24]	; (8002ac4 <i2c_lld_init+0x24>)
#endif /* STM32_I2C_USE_I2C1 */

#if STM32_I2C_USE_I2C2
  i2cObjectInit(&I2CD2);
  I2CD2.thread = NULL;
  I2CD2.i2c    = I2C2;
 8002aac:	4906      	ldr	r1, [pc, #24]	; (8002ac8 <i2c_lld_init+0x28>)
  I2CD1.dmatx  = STM32_DMA_STREAM(STM32_I2C_I2C1_TX_DMA_STREAM);
#endif /* STM32_I2C_USE_I2C1 */

#if STM32_I2C_USE_I2C2
  i2cObjectInit(&I2CD2);
  I2CD2.thread = NULL;
 8002aae:	2000      	movs	r0, #0
  I2CD2.i2c    = I2C2;
  I2CD2.dmarx  = STM32_DMA_STREAM(STM32_I2C_I2C2_RX_DMA_STREAM);
  I2CD2.dmatx  = STM32_DMA_STREAM(STM32_I2C_I2C2_TX_DMA_STREAM);
 8002ab0:	f1a3 0214 	sub.w	r2, r3, #20
  I2CD1.dmatx  = STM32_DMA_STREAM(STM32_I2C_I2C1_TX_DMA_STREAM);
#endif /* STM32_I2C_USE_I2C1 */

#if STM32_I2C_USE_I2C2
  i2cObjectInit(&I2CD2);
  I2CD2.thread = NULL;
 8002ab4:	61e0      	str	r0, [r4, #28]
  I2CD2.i2c    = I2C2;
 8002ab6:	6361      	str	r1, [r4, #52]	; 0x34
  I2CD2.dmarx  = STM32_DMA_STREAM(STM32_I2C_I2C2_RX_DMA_STREAM);
 8002ab8:	62e3      	str	r3, [r4, #44]	; 0x2c
  I2CD2.dmatx  = STM32_DMA_STREAM(STM32_I2C_I2C2_TX_DMA_STREAM);
 8002aba:	6322      	str	r2, [r4, #48]	; 0x30
 8002abc:	bd10      	pop	{r4, pc}
 8002abe:	bf00      	nop
 8002ac0:	20000acc 	.word	0x20000acc
 8002ac4:	08004760 	.word	0x08004760
 8002ac8:	40005800 	.word	0x40005800
 8002acc:	00000000 	.word	0x00000000

08002ad0 <pwm_lld_init>:
/**
 * @brief   Low level PWM driver initialization.
 *
 * @notapi
 */
void pwm_lld_init(void) {
 8002ad0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}

#if STM32_PWM_USE_TIM1
  /* Driver initialization.*/
  pwmObjectInit(&PWMD1);
 8002ad2:	4d0f      	ldr	r5, [pc, #60]	; (8002b10 <pwm_lld_init+0x40>)
  PWMD1.tim = STM32_TIM1;
#endif

#if STM32_PWM_USE_TIM2
  /* Driver initialization.*/
  pwmObjectInit(&PWMD2);
 8002ad4:	4f0f      	ldr	r7, [pc, #60]	; (8002b14 <pwm_lld_init+0x44>)
 */
void pwm_lld_init(void) {

#if STM32_PWM_USE_TIM1
  /* Driver initialization.*/
  pwmObjectInit(&PWMD1);
 8002ad6:	4628      	mov	r0, r5
 8002ad8:	f7ff f8d2 	bl	8001c80 <pwmObjectInit>
  PWMD2.tim = STM32_TIM2;
#endif

#if STM32_PWM_USE_TIM3
  /* Driver initialization.*/
  pwmObjectInit(&PWMD3);
 8002adc:	4e0e      	ldr	r6, [pc, #56]	; (8002b18 <pwm_lld_init+0x48>)

#if STM32_PWM_USE_TIM1
  /* Driver initialization.*/
  pwmObjectInit(&PWMD1);
  PWMD1.channels = STM32_TIM1_CHANNELS;
  PWMD1.tim = STM32_TIM1;
 8002ade:	4b0f      	ldr	r3, [pc, #60]	; (8002b1c <pwm_lld_init+0x4c>)
void pwm_lld_init(void) {

#if STM32_PWM_USE_TIM1
  /* Driver initialization.*/
  pwmObjectInit(&PWMD1);
  PWMD1.channels = STM32_TIM1_CHANNELS;
 8002ae0:	2404      	movs	r4, #4
  PWMD1.tim = STM32_TIM1;
#endif

#if STM32_PWM_USE_TIM2
  /* Driver initialization.*/
  pwmObjectInit(&PWMD2);
 8002ae2:	4638      	mov	r0, r7

#if STM32_PWM_USE_TIM1
  /* Driver initialization.*/
  pwmObjectInit(&PWMD1);
  PWMD1.channels = STM32_TIM1_CHANNELS;
  PWMD1.tim = STM32_TIM1;
 8002ae4:	61ab      	str	r3, [r5, #24]
void pwm_lld_init(void) {

#if STM32_PWM_USE_TIM1
  /* Driver initialization.*/
  pwmObjectInit(&PWMD1);
  PWMD1.channels = STM32_TIM1_CHANNELS;
 8002ae6:	742c      	strb	r4, [r5, #16]
  PWMD1.tim = STM32_TIM1;
#endif

#if STM32_PWM_USE_TIM2
  /* Driver initialization.*/
  pwmObjectInit(&PWMD2);
 8002ae8:	f7ff f8ca 	bl	8001c80 <pwmObjectInit>
  PWMD3.tim = STM32_TIM3;
#endif

#if STM32_PWM_USE_TIM4
  /* Driver initialization.*/
  pwmObjectInit(&PWMD4);
 8002aec:	4d0c      	ldr	r5, [pc, #48]	; (8002b20 <pwm_lld_init+0x50>)

#if STM32_PWM_USE_TIM2
  /* Driver initialization.*/
  pwmObjectInit(&PWMD2);
  PWMD2.channels = STM32_TIM2_CHANNELS;
  PWMD2.tim = STM32_TIM2;
 8002aee:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
#endif

#if STM32_PWM_USE_TIM3
  /* Driver initialization.*/
  pwmObjectInit(&PWMD3);
 8002af2:	4630      	mov	r0, r6

#if STM32_PWM_USE_TIM2
  /* Driver initialization.*/
  pwmObjectInit(&PWMD2);
  PWMD2.channels = STM32_TIM2_CHANNELS;
  PWMD2.tim = STM32_TIM2;
 8002af4:	61bb      	str	r3, [r7, #24]
#endif

#if STM32_PWM_USE_TIM2
  /* Driver initialization.*/
  pwmObjectInit(&PWMD2);
  PWMD2.channels = STM32_TIM2_CHANNELS;
 8002af6:	743c      	strb	r4, [r7, #16]
  PWMD2.tim = STM32_TIM2;
#endif

#if STM32_PWM_USE_TIM3
  /* Driver initialization.*/
  pwmObjectInit(&PWMD3);
 8002af8:	f7ff f8c2 	bl	8001c80 <pwmObjectInit>
  PWMD3.channels = STM32_TIM3_CHANNELS;
  PWMD3.tim = STM32_TIM3;
 8002afc:	4b09      	ldr	r3, [pc, #36]	; (8002b24 <pwm_lld_init+0x54>)
#endif

#if STM32_PWM_USE_TIM4
  /* Driver initialization.*/
  pwmObjectInit(&PWMD4);
 8002afe:	4628      	mov	r0, r5

#if STM32_PWM_USE_TIM3
  /* Driver initialization.*/
  pwmObjectInit(&PWMD3);
  PWMD3.channels = STM32_TIM3_CHANNELS;
  PWMD3.tim = STM32_TIM3;
 8002b00:	61b3      	str	r3, [r6, #24]
#endif

#if STM32_PWM_USE_TIM3
  /* Driver initialization.*/
  pwmObjectInit(&PWMD3);
  PWMD3.channels = STM32_TIM3_CHANNELS;
 8002b02:	7434      	strb	r4, [r6, #16]
  PWMD3.tim = STM32_TIM3;
#endif

#if STM32_PWM_USE_TIM4
  /* Driver initialization.*/
  pwmObjectInit(&PWMD4);
 8002b04:	f7ff f8bc 	bl	8001c80 <pwmObjectInit>
  PWMD4.channels = STM32_TIM4_CHANNELS;
  PWMD4.tim = STM32_TIM4;
 8002b08:	4b07      	ldr	r3, [pc, #28]	; (8002b28 <pwm_lld_init+0x58>)
#endif

#if STM32_PWM_USE_TIM4
  /* Driver initialization.*/
  pwmObjectInit(&PWMD4);
  PWMD4.channels = STM32_TIM4_CHANNELS;
 8002b0a:	742c      	strb	r4, [r5, #16]
  PWMD4.tim = STM32_TIM4;
 8002b0c:	61ab      	str	r3, [r5, #24]
 8002b0e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8002b10:	20000b04 	.word	0x20000b04
 8002b14:	20000b20 	.word	0x20000b20
 8002b18:	20000b3c 	.word	0x20000b3c
 8002b1c:	40012c00 	.word	0x40012c00
 8002b20:	20000b58 	.word	0x20000b58
 8002b24:	40000400 	.word	0x40000400
 8002b28:	40000800 	.word	0x40000800
 8002b2c:	00000000 	.word	0x00000000

08002b30 <pwm_lld_serve_interrupt>:
 * @notapi
 */
void pwm_lld_serve_interrupt(PWMDriver *pwmp) {
  uint32_t sr;

  sr  = pwmp->tim->SR;
 8002b30:	6983      	ldr	r3, [r0, #24]
 *
 * @param[in] pwmp      pointer to a @p PWMDriver object
 *
 * @notapi
 */
void pwm_lld_serve_interrupt(PWMDriver *pwmp) {
 8002b32:	b570      	push	{r4, r5, r6, lr}
  uint32_t sr;

  sr  = pwmp->tim->SR;
 8002b34:	691a      	ldr	r2, [r3, #16]
  sr &= pwmp->tim->DIER & STM32_TIM_DIER_IRQ_MASK;
 8002b36:	68dc      	ldr	r4, [r3, #12]
 *
 * @param[in] pwmp      pointer to a @p PWMDriver object
 *
 * @notapi
 */
void pwm_lld_serve_interrupt(PWMDriver *pwmp) {
 8002b38:	4605      	mov	r5, r0
 8002b3a:	4014      	ands	r4, r2
  uint32_t sr;

  sr  = pwmp->tim->SR;
  sr &= pwmp->tim->DIER & STM32_TIM_DIER_IRQ_MASK;
 8002b3c:	b2e2      	uxtb	r2, r4
  pwmp->tim->SR = ~sr;
 8002b3e:	43d2      	mvns	r2, r2
  if (((sr & STM32_TIM_SR_CC1IF) != 0) &&
 8002b40:	07a6      	lsls	r6, r4, #30
void pwm_lld_serve_interrupt(PWMDriver *pwmp) {
  uint32_t sr;

  sr  = pwmp->tim->SR;
  sr &= pwmp->tim->DIER & STM32_TIM_DIER_IRQ_MASK;
  pwmp->tim->SR = ~sr;
 8002b42:	611a      	str	r2, [r3, #16]
  if (((sr & STM32_TIM_SR_CC1IF) != 0) &&
 8002b44:	d503      	bpl.n	8002b4e <pwm_lld_serve_interrupt+0x1e>
      (pwmp->config->channels[0].callback != NULL))
 8002b46:	6843      	ldr	r3, [r0, #4]
 8002b48:	691b      	ldr	r3, [r3, #16]
  uint32_t sr;

  sr  = pwmp->tim->SR;
  sr &= pwmp->tim->DIER & STM32_TIM_DIER_IRQ_MASK;
  pwmp->tim->SR = ~sr;
  if (((sr & STM32_TIM_SR_CC1IF) != 0) &&
 8002b4a:	b103      	cbz	r3, 8002b4e <pwm_lld_serve_interrupt+0x1e>
      (pwmp->config->channels[0].callback != NULL))
    pwmp->config->channels[0].callback(pwmp);
 8002b4c:	4798      	blx	r3
  if (((sr & STM32_TIM_SR_CC2IF) != 0) &&
 8002b4e:	0760      	lsls	r0, r4, #29
 8002b50:	d504      	bpl.n	8002b5c <pwm_lld_serve_interrupt+0x2c>
      (pwmp->config->channels[1].callback != NULL))
 8002b52:	686b      	ldr	r3, [r5, #4]
 8002b54:	699b      	ldr	r3, [r3, #24]
  sr &= pwmp->tim->DIER & STM32_TIM_DIER_IRQ_MASK;
  pwmp->tim->SR = ~sr;
  if (((sr & STM32_TIM_SR_CC1IF) != 0) &&
      (pwmp->config->channels[0].callback != NULL))
    pwmp->config->channels[0].callback(pwmp);
  if (((sr & STM32_TIM_SR_CC2IF) != 0) &&
 8002b56:	b10b      	cbz	r3, 8002b5c <pwm_lld_serve_interrupt+0x2c>
      (pwmp->config->channels[1].callback != NULL))
    pwmp->config->channels[1].callback(pwmp);
 8002b58:	4628      	mov	r0, r5
 8002b5a:	4798      	blx	r3
  if (((sr & STM32_TIM_SR_CC3IF) != 0) &&
 8002b5c:	0721      	lsls	r1, r4, #28
 8002b5e:	d504      	bpl.n	8002b6a <pwm_lld_serve_interrupt+0x3a>
      (pwmp->config->channels[2].callback != NULL))
 8002b60:	686b      	ldr	r3, [r5, #4]
 8002b62:	6a1b      	ldr	r3, [r3, #32]
      (pwmp->config->channels[0].callback != NULL))
    pwmp->config->channels[0].callback(pwmp);
  if (((sr & STM32_TIM_SR_CC2IF) != 0) &&
      (pwmp->config->channels[1].callback != NULL))
    pwmp->config->channels[1].callback(pwmp);
  if (((sr & STM32_TIM_SR_CC3IF) != 0) &&
 8002b64:	b10b      	cbz	r3, 8002b6a <pwm_lld_serve_interrupt+0x3a>
      (pwmp->config->channels[2].callback != NULL))
    pwmp->config->channels[2].callback(pwmp);
 8002b66:	4628      	mov	r0, r5
 8002b68:	4798      	blx	r3
  if (((sr & STM32_TIM_SR_CC4IF) != 0) &&
 8002b6a:	06e2      	lsls	r2, r4, #27
 8002b6c:	d504      	bpl.n	8002b78 <pwm_lld_serve_interrupt+0x48>
      (pwmp->config->channels[3].callback != NULL))
 8002b6e:	686b      	ldr	r3, [r5, #4]
 8002b70:	6a9b      	ldr	r3, [r3, #40]	; 0x28
      (pwmp->config->channels[1].callback != NULL))
    pwmp->config->channels[1].callback(pwmp);
  if (((sr & STM32_TIM_SR_CC3IF) != 0) &&
      (pwmp->config->channels[2].callback != NULL))
    pwmp->config->channels[2].callback(pwmp);
  if (((sr & STM32_TIM_SR_CC4IF) != 0) &&
 8002b72:	b10b      	cbz	r3, 8002b78 <pwm_lld_serve_interrupt+0x48>
      (pwmp->config->channels[3].callback != NULL))
    pwmp->config->channels[3].callback(pwmp);
 8002b74:	4628      	mov	r0, r5
 8002b76:	4798      	blx	r3
  if (((sr & STM32_TIM_SR_UIF) != 0) && (pwmp->config->callback != NULL))
 8002b78:	07e3      	lsls	r3, r4, #31
 8002b7a:	d506      	bpl.n	8002b8a <pwm_lld_serve_interrupt+0x5a>
 8002b7c:	686b      	ldr	r3, [r5, #4]
 8002b7e:	689b      	ldr	r3, [r3, #8]
 8002b80:	b11b      	cbz	r3, 8002b8a <pwm_lld_serve_interrupt+0x5a>
    pwmp->config->callback(pwmp);
 8002b82:	4628      	mov	r0, r5
}
 8002b84:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    pwmp->config->channels[2].callback(pwmp);
  if (((sr & STM32_TIM_SR_CC4IF) != 0) &&
      (pwmp->config->channels[3].callback != NULL))
    pwmp->config->channels[3].callback(pwmp);
  if (((sr & STM32_TIM_SR_UIF) != 0) && (pwmp->config->callback != NULL))
    pwmp->config->callback(pwmp);
 8002b88:	4718      	bx	r3
 8002b8a:	bd70      	pop	{r4, r5, r6, pc}
 8002b8c:	0000      	movs	r0, r0
	...

08002b90 <VectorA4>:
 *          pointer is not equal to @p NULL in order to not perform an extra
 *          check in a potentially critical interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_TIM1_UP_HANDLER) {
 8002b90:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();

  pwm_lld_serve_interrupt(&PWMD1);
 8002b92:	4803      	ldr	r0, [pc, #12]	; (8002ba0 <VectorA4+0x10>)
 8002b94:	f7ff ffcc 	bl	8002b30 <pwm_lld_serve_interrupt>

  OSAL_IRQ_EPILOGUE();
}
 8002b98:	e8bd 4008 	ldmia.w	sp!, {r3, lr}

  OSAL_IRQ_PROLOGUE();

  pwm_lld_serve_interrupt(&PWMD1);

  OSAL_IRQ_EPILOGUE();
 8002b9c:	f7fe bff8 	b.w	8001b90 <_port_irq_epilogue>
 8002ba0:	20000b04 	.word	0x20000b04
	...

08002bb0 <VectorAC>:
 *          associated callback pointer is not equal to @p NULL in order to not
 *          perform an extra check in a potentially critical interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_TIM1_CC_HANDLER) {
 8002bb0:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();

  pwm_lld_serve_interrupt(&PWMD1);
 8002bb2:	4803      	ldr	r0, [pc, #12]	; (8002bc0 <VectorAC+0x10>)
 8002bb4:	f7ff ffbc 	bl	8002b30 <pwm_lld_serve_interrupt>

  OSAL_IRQ_EPILOGUE();
}
 8002bb8:	e8bd 4008 	ldmia.w	sp!, {r3, lr}

  OSAL_IRQ_PROLOGUE();

  pwm_lld_serve_interrupt(&PWMD1);

  OSAL_IRQ_EPILOGUE();
 8002bbc:	f7fe bfe8 	b.w	8001b90 <_port_irq_epilogue>
 8002bc0:	20000b04 	.word	0x20000b04
	...

08002bd0 <VectorB0>:
/**
 * @brief   TIM2 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_TIM2_HANDLER) {
 8002bd0:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();

  pwm_lld_serve_interrupt(&PWMD2);
 8002bd2:	4803      	ldr	r0, [pc, #12]	; (8002be0 <VectorB0+0x10>)
 8002bd4:	f7ff ffac 	bl	8002b30 <pwm_lld_serve_interrupt>

  OSAL_IRQ_EPILOGUE();
}
 8002bd8:	e8bd 4008 	ldmia.w	sp!, {r3, lr}

  OSAL_IRQ_PROLOGUE();

  pwm_lld_serve_interrupt(&PWMD2);

  OSAL_IRQ_EPILOGUE();
 8002bdc:	f7fe bfd8 	b.w	8001b90 <_port_irq_epilogue>
 8002be0:	20000b20 	.word	0x20000b20
	...

08002bf0 <VectorB4>:
/**
 * @brief   TIM3 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_TIM3_HANDLER) {
 8002bf0:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();

  pwm_lld_serve_interrupt(&PWMD3);
 8002bf2:	4803      	ldr	r0, [pc, #12]	; (8002c00 <VectorB4+0x10>)
 8002bf4:	f7ff ff9c 	bl	8002b30 <pwm_lld_serve_interrupt>

  OSAL_IRQ_EPILOGUE();
}
 8002bf8:	e8bd 4008 	ldmia.w	sp!, {r3, lr}

  OSAL_IRQ_PROLOGUE();

  pwm_lld_serve_interrupt(&PWMD3);

  OSAL_IRQ_EPILOGUE();
 8002bfc:	f7fe bfc8 	b.w	8001b90 <_port_irq_epilogue>
 8002c00:	20000b3c 	.word	0x20000b3c
	...

08002c10 <VectorB8>:
/**
 * @brief   TIM4 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_TIM4_HANDLER) {
 8002c10:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();

  pwm_lld_serve_interrupt(&PWMD4);
 8002c12:	4803      	ldr	r0, [pc, #12]	; (8002c20 <VectorB8+0x10>)
 8002c14:	f7ff ff8c 	bl	8002b30 <pwm_lld_serve_interrupt>

  OSAL_IRQ_EPILOGUE();
}
 8002c18:	e8bd 4008 	ldmia.w	sp!, {r3, lr}

  OSAL_IRQ_PROLOGUE();

  pwm_lld_serve_interrupt(&PWMD4);

  OSAL_IRQ_EPILOGUE();
 8002c1c:	f7fe bfb8 	b.w	8001b90 <_port_irq_epilogue>
 8002c20:	20000b58 	.word	0x20000b58
	...

08002c30 <notify4>:

#if STM32_SERIAL_USE_UART4 || defined(__DOXYGEN__)
static void notify4(io_queue_t *qp) {

  (void)qp;
  UART4->CR1 |= USART_CR1_TXEIE;
 8002c30:	4a02      	ldr	r2, [pc, #8]	; (8002c3c <notify4+0xc>)
 8002c32:	68d3      	ldr	r3, [r2, #12]
 8002c34:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8002c38:	60d3      	str	r3, [r2, #12]
 8002c3a:	4770      	bx	lr
 8002c3c:	40004c00 	.word	0x40004c00

08002c40 <Vector110>:
/**
 * @brief   UART4 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_UART4_HANDLER) {
 8002c40:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 * @brief   Common IRQ handler.
 *
 * @param[in] sdp       communication channel associated to the USART
 */
static void serve_interrupt(SerialDriver *sdp) {
  USART_TypeDef *u = sdp->usart;
 8002c42:	4e43      	ldr	r6, [pc, #268]	; (8002d50 <Vector110+0x110>)
 8002c44:	f8d6 5154 	ldr.w	r5, [r6, #340]	; 0x154
  uint16_t cr1 = u->CR1;
 8002c48:	68ef      	ldr	r7, [r5, #12]
  uint16_t sr = u->SR;
 8002c4a:	682b      	ldr	r3, [r5, #0]

  /* Special case, LIN break detection.*/
  if (sr & USART_SR_LBD) {
 8002c4c:	05da      	lsls	r2, r3, #23
 * @param[in] sdp       communication channel associated to the USART
 */
static void serve_interrupt(SerialDriver *sdp) {
  USART_TypeDef *u = sdp->usart;
  uint16_t cr1 = u->CR1;
  uint16_t sr = u->SR;
 8002c4e:	b29c      	uxth	r4, r3

  /* Special case, LIN break detection.*/
  if (sr & USART_SR_LBD) {
 8002c50:	d44f      	bmi.n	8002cf2 <Vector110+0xb2>
 8002c52:	2320      	movs	r3, #32
 8002c54:	f383 8811 	msr	BASEPRI, r3
    osalSysUnlockFromISR();
  }

  /* Data available.*/
  osalSysLockFromISR();
  while (sr & (USART_SR_RXNE | USART_SR_ORE | USART_SR_NE | USART_SR_FE |
 8002c58:	f014 0f2f 	tst.w	r4, #47	; 0x2f
 8002c5c:	d108      	bne.n	8002c70 <Vector110+0x30>
 8002c5e:	e029      	b.n	8002cb4 <Vector110+0x74>

    /* Error condition detection.*/
    if (sr & (USART_SR_ORE | USART_SR_NE | USART_SR_FE  | USART_SR_PE))
      set_error(sdp, sr);
    b = u->DR;
    if (sr & USART_SR_RXNE)
 8002c60:	06a0      	lsls	r0, r4, #26
    uint8_t b;

    /* Error condition detection.*/
    if (sr & (USART_SR_ORE | USART_SR_NE | USART_SR_FE  | USART_SR_PE))
      set_error(sdp, sr);
    b = u->DR;
 8002c62:	6869      	ldr	r1, [r5, #4]
    if (sr & USART_SR_RXNE)
 8002c64:	d41d      	bmi.n	8002ca2 <Vector110+0x62>
      sdIncomingDataI(sdp, b);
    sr = u->SR;
 8002c66:	682c      	ldr	r4, [r5, #0]
 8002c68:	b2a4      	uxth	r4, r4
    osalSysUnlockFromISR();
  }

  /* Data available.*/
  osalSysLockFromISR();
  while (sr & (USART_SR_RXNE | USART_SR_ORE | USART_SR_NE | USART_SR_FE |
 8002c6a:	f014 0f2f 	tst.w	r4, #47	; 0x2f
 8002c6e:	d021      	beq.n	8002cb4 <Vector110+0x74>
               USART_SR_PE)) {
    uint8_t b;

    /* Error condition detection.*/
    if (sr & (USART_SR_ORE | USART_SR_NE | USART_SR_FE  | USART_SR_PE))
 8002c70:	0723      	lsls	r3, r4, #28
 8002c72:	d0f5      	beq.n	8002c60 <Vector110+0x20>
 */
static void set_error(SerialDriver *sdp, uint16_t sr) {
  eventflags_t sts = 0;

  if (sr & USART_SR_ORE)
    sts |= SD_OVERRUN_ERROR;
 8002c74:	f014 0f08 	tst.w	r4, #8
 8002c78:	bf0c      	ite	eq
 8002c7a:	2100      	moveq	r1, #0
 8002c7c:	2180      	movne	r1, #128	; 0x80
  if (sr & USART_SR_PE)
 8002c7e:	07e0      	lsls	r0, r4, #31
    sts |= SD_PARITY_ERROR;
 8002c80:	bf48      	it	mi
 8002c82:	f041 0120 	orrmi.w	r1, r1, #32
  if (sr & USART_SR_FE)
 8002c86:	07a2      	lsls	r2, r4, #30
    sts |= SD_FRAMING_ERROR;
 8002c88:	bf48      	it	mi
 8002c8a:	f041 0140 	orrmi.w	r1, r1, #64	; 0x40
  if (sr & USART_SR_NE)
 8002c8e:	0763      	lsls	r3, r4, #29
    sts |= SD_NOISE_ERROR;
 8002c90:	bf48      	it	mi
 8002c92:	f441 7180 	orrmi.w	r1, r1, #256	; 0x100
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {

  chEvtBroadcastFlagsI(esp, flags);
 8002c96:	482f      	ldr	r0, [pc, #188]	; (8002d54 <Vector110+0x114>)
 8002c98:	f7fe fdd2 	bl	8001840 <chEvtBroadcastFlagsI>

    /* Error condition detection.*/
    if (sr & (USART_SR_ORE | USART_SR_NE | USART_SR_FE  | USART_SR_PE))
      set_error(sdp, sr);
    b = u->DR;
    if (sr & USART_SR_RXNE)
 8002c9c:	06a0      	lsls	r0, r4, #26
    uint8_t b;

    /* Error condition detection.*/
    if (sr & (USART_SR_ORE | USART_SR_NE | USART_SR_FE  | USART_SR_PE))
      set_error(sdp, sr);
    b = u->DR;
 8002c9e:	6869      	ldr	r1, [r5, #4]
    if (sr & USART_SR_RXNE)
 8002ca0:	d5e1      	bpl.n	8002c66 <Vector110+0x26>
      sdIncomingDataI(sdp, b);
 8002ca2:	b2c9      	uxtb	r1, r1
 8002ca4:	482a      	ldr	r0, [pc, #168]	; (8002d50 <Vector110+0x110>)
 8002ca6:	f7ff f86b 	bl	8001d80 <sdIncomingDataI>
    sr = u->SR;
 8002caa:	682c      	ldr	r4, [r5, #0]
 8002cac:	b2a4      	uxth	r4, r4
    osalSysUnlockFromISR();
  }

  /* Data available.*/
  osalSysLockFromISR();
  while (sr & (USART_SR_RXNE | USART_SR_ORE | USART_SR_NE | USART_SR_FE |
 8002cae:	f014 0f2f 	tst.w	r4, #47	; 0x2f
 8002cb2:	d1dd      	bne.n	8002c70 <Vector110+0x30>
 8002cb4:	2300      	movs	r3, #0
 8002cb6:	f383 8811 	msr	BASEPRI, r3
    sr = u->SR;
  }
  osalSysUnlockFromISR();

  /* Transmission buffer empty.*/
  if ((cr1 & USART_CR1_TXEIE) && (sr & USART_SR_TXE)) {
 8002cba:	0639      	lsls	r1, r7, #24
 8002cbc:	d501      	bpl.n	8002cc2 <Vector110+0x82>
 8002cbe:	0622      	lsls	r2, r4, #24
 8002cc0:	d426      	bmi.n	8002d10 <Vector110+0xd0>
      u->DR = b;
    osalSysUnlockFromISR();
  }

  /* Physical transmission end.*/
  if (sr & USART_SR_TC) {
 8002cc2:	0663      	lsls	r3, r4, #25
 8002cc4:	d511      	bpl.n	8002cea <Vector110+0xaa>
 8002cc6:	2320      	movs	r3, #32
 8002cc8:	f383 8811 	msr	BASEPRI, r3
static inline bool chOQIsEmptyI(output_queue_t *oqp) {

  chDbgCheckClassI();

  /*lint -save -e9007 [13.5] No side effects.*/
  return (bool)((oqp->q_wrptr == oqp->q_rdptr) && (oqp->q_counter != 0U));
 8002ccc:	6c72      	ldr	r2, [r6, #68]	; 0x44
 8002cce:	6cb3      	ldr	r3, [r6, #72]	; 0x48
 8002cd0:	481f      	ldr	r0, [pc, #124]	; (8002d50 <Vector110+0x110>)
 8002cd2:	429a      	cmp	r2, r3
 8002cd4:	d029      	beq.n	8002d2a <Vector110+0xea>
    osalSysLockFromISR();
    if (oqIsEmptyI(&sdp->oqueue))
      chnAddFlagsI(sdp, CHN_TRANSMISSION_END);
    u->CR1 = cr1 & ~USART_CR1_TCIE;
 8002cd6:	f64f 73bf 	movw	r3, #65471	; 0xffbf
    u->SR = ~USART_SR_TC;
 8002cda:	f06f 0240 	mvn.w	r2, #64	; 0x40
  /* Physical transmission end.*/
  if (sr & USART_SR_TC) {
    osalSysLockFromISR();
    if (oqIsEmptyI(&sdp->oqueue))
      chnAddFlagsI(sdp, CHN_TRANSMISSION_END);
    u->CR1 = cr1 & ~USART_CR1_TCIE;
 8002cde:	403b      	ands	r3, r7
 8002ce0:	60eb      	str	r3, [r5, #12]
 8002ce2:	2300      	movs	r3, #0
    u->SR = ~USART_SR_TC;
 8002ce4:	602a      	str	r2, [r5, #0]
 8002ce6:	f383 8811 	msr	BASEPRI, r3
  OSAL_IRQ_PROLOGUE();

  serve_interrupt(&SD4);

  OSAL_IRQ_EPILOGUE();
}
 8002cea:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}

  OSAL_IRQ_PROLOGUE();

  serve_interrupt(&SD4);

  OSAL_IRQ_EPILOGUE();
 8002cee:	f7fe bf4f 	b.w	8001b90 <_port_irq_epilogue>
 8002cf2:	2320      	movs	r3, #32
 8002cf4:	f383 8811 	msr	BASEPRI, r3
 8002cf8:	f44f 7100 	mov.w	r1, #512	; 0x200
 8002cfc:	1d30      	adds	r0, r6, #4
 8002cfe:	f7fe fd9f 	bl	8001840 <chEvtBroadcastFlagsI>

  /* Special case, LIN break detection.*/
  if (sr & USART_SR_LBD) {
    osalSysLockFromISR();
    chnAddFlagsI(sdp, SD_BREAK_DETECTED);
    u->SR = ~USART_SR_LBD;
 8002d02:	f46f 7380 	mvn.w	r3, #256	; 0x100
 8002d06:	602b      	str	r3, [r5, #0]
 8002d08:	2300      	movs	r3, #0
 8002d0a:	f383 8811 	msr	BASEPRI, r3
 8002d0e:	e7a0      	b.n	8002c52 <Vector110+0x12>
 8002d10:	2320      	movs	r3, #32
 8002d12:	f383 8811 	msr	BASEPRI, r3

  /* Transmission buffer empty.*/
  if ((cr1 & USART_CR1_TXEIE) && (sr & USART_SR_TXE)) {
    msg_t b;
    osalSysLockFromISR();
    b = oqGetI(&sdp->oqueue);
 8002d16:	4810      	ldr	r0, [pc, #64]	; (8002d58 <Vector110+0x118>)
 8002d18:	f7fe fe82 	bl	8001a20 <chOQGetI>
    if (b < Q_OK) {
 8002d1c:	2800      	cmp	r0, #0
 8002d1e:	db0c      	blt.n	8002d3a <Vector110+0xfa>
      chnAddFlagsI(sdp, CHN_OUTPUT_EMPTY);
      u->CR1 = (cr1 & ~USART_CR1_TXEIE) | USART_CR1_TCIE;
    }
    else
      u->DR = b;
 8002d20:	6068      	str	r0, [r5, #4]
 8002d22:	2300      	movs	r3, #0
 8002d24:	f383 8811 	msr	BASEPRI, r3
 8002d28:	e7cb      	b.n	8002cc2 <Vector110+0x82>
 8002d2a:	6b83      	ldr	r3, [r0, #56]	; 0x38
 8002d2c:	2b00      	cmp	r3, #0
 8002d2e:	d0d2      	beq.n	8002cd6 <Vector110+0x96>
 8002d30:	3004      	adds	r0, #4
 8002d32:	2110      	movs	r1, #16
 8002d34:	f7fe fd84 	bl	8001840 <chEvtBroadcastFlagsI>
 8002d38:	e7cd      	b.n	8002cd6 <Vector110+0x96>
 8002d3a:	4806      	ldr	r0, [pc, #24]	; (8002d54 <Vector110+0x114>)
 8002d3c:	2108      	movs	r1, #8
 8002d3e:	f7fe fd7f 	bl	8001840 <chEvtBroadcastFlagsI>
    msg_t b;
    osalSysLockFromISR();
    b = oqGetI(&sdp->oqueue);
    if (b < Q_OK) {
      chnAddFlagsI(sdp, CHN_OUTPUT_EMPTY);
      u->CR1 = (cr1 & ~USART_CR1_TXEIE) | USART_CR1_TCIE;
 8002d42:	f64f 733f 	movw	r3, #65343	; 0xff3f
 8002d46:	403b      	ands	r3, r7
 8002d48:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8002d4c:	60eb      	str	r3, [r5, #12]
 8002d4e:	e7e8      	b.n	8002d22 <Vector110+0xe2>
 8002d50:	20000b74 	.word	0x20000b74
 8002d54:	20000b78 	.word	0x20000b78
 8002d58:	20000ba4 	.word	0x20000ba4
 8002d5c:	00000000 	.word	0x00000000

08002d60 <sd_lld_init>:
/**
 * @brief   Low level serial driver initialization.
 *
 * @notapi
 */
void sd_lld_init(void) {
 8002d60:	b510      	push	{r4, lr}
  sdObjectInit(&SD3, NULL, notify3);
  SD3.usart = USART3;
#endif

#if STM32_SERIAL_USE_UART4
  sdObjectInit(&SD4, NULL, notify4);
 8002d62:	4c05      	ldr	r4, [pc, #20]	; (8002d78 <sd_lld_init+0x18>)
 8002d64:	2100      	movs	r1, #0
 8002d66:	4620      	mov	r0, r4
 8002d68:	4a04      	ldr	r2, [pc, #16]	; (8002d7c <sd_lld_init+0x1c>)
 8002d6a:	f7fe ffd9 	bl	8001d20 <sdObjectInit>
  SD4.usart = UART4;
 8002d6e:	4b04      	ldr	r3, [pc, #16]	; (8002d80 <sd_lld_init+0x20>)
 8002d70:	f8c4 3154 	str.w	r3, [r4, #340]	; 0x154
 8002d74:	bd10      	pop	{r4, pc}
 8002d76:	bf00      	nop
 8002d78:	20000b74 	.word	0x20000b74
 8002d7c:	08002c31 	.word	0x08002c31
 8002d80:	40004c00 	.word	0x40004c00
	...

08002d90 <sd_lld_start>:
 *                      If this parameter is set to @p NULL then a default
 *                      configuration is used.
 *
 * @notapi
 */
void sd_lld_start(SerialDriver *sdp, const SerialConfig *config) {
 8002d90:	b538      	push	{r3, r4, r5, lr}

  if (config == NULL)
    config = &default_config;
 8002d92:	4c19      	ldr	r4, [pc, #100]	; (8002df8 <sd_lld_start+0x68>)

  if (sdp->state == SD_STOP) {
 8002d94:	7a03      	ldrb	r3, [r0, #8]
 * @notapi
 */
void sd_lld_start(SerialDriver *sdp, const SerialConfig *config) {

  if (config == NULL)
    config = &default_config;
 8002d96:	2900      	cmp	r1, #0
 8002d98:	bf18      	it	ne
 8002d9a:	460c      	movne	r4, r1

  if (sdp->state == SD_STOP) {
 8002d9c:	2b01      	cmp	r3, #1
 *                      If this parameter is set to @p NULL then a default
 *                      configuration is used.
 *
 * @notapi
 */
void sd_lld_start(SerialDriver *sdp, const SerialConfig *config) {
 8002d9e:	4605      	mov	r5, r0

  if (config == NULL)
    config = &default_config;

  if (sdp->state == SD_STOP) {
 8002da0:	d01c      	beq.n	8002ddc <sd_lld_start+0x4c>
#if STM32_HAS_USART6
  if ((sdp->usart == USART1) || (sdp->usart == USART6))
#else
  if (sdp->usart == USART1)
#endif
    u->BRR = STM32_PCLK2 / config->speed;
 8002da2:	6821      	ldr	r1, [r4, #0]
 8002da4:	4a15      	ldr	r2, [pc, #84]	; (8002dfc <sd_lld_start+0x6c>)
 *
 * @param[in] sdp       pointer to a @p SerialDriver object
 * @param[in] config    the architecture-dependent serial driver configuration
 */
static void usart_init(SerialDriver *sdp, const SerialConfig *config) {
  USART_TypeDef *u = sdp->usart;
 8002da6:	f8d5 3154 	ldr.w	r3, [r5, #340]	; 0x154
#if STM32_HAS_USART6
  if ((sdp->usart == USART1) || (sdp->usart == USART6))
#else
  if (sdp->usart == USART1)
#endif
    u->BRR = STM32_PCLK2 / config->speed;
 8002daa:	fbb2 f2f1 	udiv	r2, r2, r1
 8002dae:	609a      	str	r2, [r3, #8]

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
  u->CR3 = config->cr3 | USART_CR3_EIE;
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
                         USART_CR1_RXNEIE | USART_CR1_TE |
 8002db0:	88a2      	ldrh	r2, [r4, #4]
    u->BRR = STM32_PCLK2 / config->speed;
  else
    u->BRR = STM32_PCLK1 / config->speed;

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
 8002db2:	88e0      	ldrh	r0, [r4, #6]
  u->CR3 = config->cr3 | USART_CR3_EIE;
 8002db4:	8921      	ldrh	r1, [r4, #8]
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
                         USART_CR1_RXNEIE | USART_CR1_TE |
 8002db6:	f442 5204 	orr.w	r2, r2, #8448	; 0x2100
    u->BRR = STM32_PCLK2 / config->speed;
  else
    u->BRR = STM32_PCLK1 / config->speed;

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
 8002dba:	f040 0040 	orr.w	r0, r0, #64	; 0x40
  u->CR3 = config->cr3 | USART_CR3_EIE;
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
                         USART_CR1_RXNEIE | USART_CR1_TE |
 8002dbe:	f042 022c 	orr.w	r2, r2, #44	; 0x2c
  else
    u->BRR = STM32_PCLK1 / config->speed;

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
  u->CR3 = config->cr3 | USART_CR3_EIE;
 8002dc2:	f041 0101 	orr.w	r1, r1, #1
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
                         USART_CR1_RXNEIE | USART_CR1_TE |
 8002dc6:	b292      	uxth	r2, r2
    u->BRR = STM32_PCLK2 / config->speed;
  else
    u->BRR = STM32_PCLK1 / config->speed;

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
 8002dc8:	b280      	uxth	r0, r0
  u->CR3 = config->cr3 | USART_CR3_EIE;
 8002dca:	b289      	uxth	r1, r1
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
                         USART_CR1_RXNEIE | USART_CR1_TE |
                         USART_CR1_RE;
  u->SR = 0;
 8002dcc:	2400      	movs	r4, #0
    u->BRR = STM32_PCLK2 / config->speed;
  else
    u->BRR = STM32_PCLK1 / config->speed;

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
 8002dce:	6118      	str	r0, [r3, #16]
  u->CR3 = config->cr3 | USART_CR3_EIE;
 8002dd0:	6159      	str	r1, [r3, #20]
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
 8002dd2:	60da      	str	r2, [r3, #12]
                         USART_CR1_RXNEIE | USART_CR1_TE |
                         USART_CR1_RE;
  u->SR = 0;
 8002dd4:	601c      	str	r4, [r3, #0]
  (void)u->SR;  /* SR reset step 1.*/
 8002dd6:	681a      	ldr	r2, [r3, #0]
  (void)u->DR;  /* SR reset step 2.*/
 8002dd8:	685b      	ldr	r3, [r3, #4]
 8002dda:	bd38      	pop	{r3, r4, r5, pc}
      rccEnableUSART3(FALSE);
      nvicEnableVector(STM32_USART3_NUMBER, STM32_SERIAL_USART3_PRIORITY);
    }
#endif
#if STM32_SERIAL_USE_UART4
    if (&SD4 == sdp) {
 8002ddc:	4b08      	ldr	r3, [pc, #32]	; (8002e00 <sd_lld_start+0x70>)
 8002dde:	4298      	cmp	r0, r3
 8002de0:	d1df      	bne.n	8002da2 <sd_lld_start+0x12>
      rccEnableUART4(FALSE);
 8002de2:	4a08      	ldr	r2, [pc, #32]	; (8002e04 <sd_lld_start+0x74>)
      nvicEnableVector(STM32_UART4_NUMBER, STM32_SERIAL_UART4_PRIORITY);
 8002de4:	2034      	movs	r0, #52	; 0x34
      nvicEnableVector(STM32_USART3_NUMBER, STM32_SERIAL_USART3_PRIORITY);
    }
#endif
#if STM32_SERIAL_USE_UART4
    if (&SD4 == sdp) {
      rccEnableUART4(FALSE);
 8002de6:	69d3      	ldr	r3, [r2, #28]
      nvicEnableVector(STM32_UART4_NUMBER, STM32_SERIAL_UART4_PRIORITY);
 8002de8:	210c      	movs	r1, #12
      nvicEnableVector(STM32_USART3_NUMBER, STM32_SERIAL_USART3_PRIORITY);
    }
#endif
#if STM32_SERIAL_USE_UART4
    if (&SD4 == sdp) {
      rccEnableUART4(FALSE);
 8002dea:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
 8002dee:	61d3      	str	r3, [r2, #28]
      nvicEnableVector(STM32_UART4_NUMBER, STM32_SERIAL_UART4_PRIORITY);
 8002df0:	f7ff fad6 	bl	80023a0 <nvicEnableVector>
 8002df4:	e7d5      	b.n	8002da2 <sd_lld_start+0x12>
 8002df6:	bf00      	nop
 8002df8:	08004800 	.word	0x08004800
 8002dfc:	02255100 	.word	0x02255100
 8002e00:	20000b74 	.word	0x20000b74
 8002e04:	40021000 	.word	0x40021000
	...

08002e10 <usb_packet_write_from_buffer>:
 * @notapi
 */
static void usb_packet_write_from_buffer(usbep_t ep,
                                         const uint8_t *buf,
                                         size_t n) {
  stm32_usb_descriptor_t *udp = USB_GET_DESCRIPTOR(ep);
 8002e10:	4b14      	ldr	r3, [pc, #80]	; (8002e64 <usb_packet_write_from_buffer+0x54>)
 *
 * @notapi
 */
static void usb_packet_write_from_buffer(usbep_t ep,
                                         const uint8_t *buf,
                                         size_t n) {
 8002e12:	b410      	push	{r4}
  stm32_usb_descriptor_t *udp = USB_GET_DESCRIPTOR(ep);
 8002e14:	6d1c      	ldr	r4, [r3, #80]	; 0x50
 8002e16:	0100      	lsls	r0, r0, #4
 8002e18:	f104 4480 	add.w	r4, r4, #1073741824	; 0x40000000
 8002e1c:	f504 44c0 	add.w	r4, r4, #24576	; 0x6000
  stm32_usb_pma_t *pmap = USB_ADDR2PTR(udp->TXADDR0);
 8002e20:	5823      	ldr	r3, [r4, r0]
    buf += 16;
    pmap += 8;
  }
#endif /* STM32_USB_USE_FAST_COPY */

  while (i > 0) {
 8002e22:	2a00      	cmp	r2, #0
 */
static void usb_packet_write_from_buffer(usbep_t ep,
                                         const uint8_t *buf,
                                         size_t n) {
  stm32_usb_descriptor_t *udp = USB_GET_DESCRIPTOR(ep);
  stm32_usb_pma_t *pmap = USB_ADDR2PTR(udp->TXADDR0);
 8002e24:	f103 5300 	add.w	r3, r3, #536870912	; 0x20000000
 * @notapi
 */
static void usb_packet_write_from_buffer(usbep_t ep,
                                         const uint8_t *buf,
                                         size_t n) {
  stm32_usb_descriptor_t *udp = USB_GET_DESCRIPTOR(ep);
 8002e28:	4420      	add	r0, r4
  stm32_usb_pma_t *pmap = USB_ADDR2PTR(udp->TXADDR0);
 8002e2a:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
  if (EPR_EP_TYPE_IS_ISO(epr) && (epr & EPR_DTOG_TX))
    udp->TXCOUNT1 = (stm32_usb_pma_t)n;
  else
    udp->TXCOUNT0 = (stm32_usb_pma_t)n;
#else
  udp->TXCOUNT0 = (stm32_usb_pma_t)n;
 8002e2e:	6042      	str	r2, [r0, #4]
 */
static void usb_packet_write_from_buffer(usbep_t ep,
                                         const uint8_t *buf,
                                         size_t n) {
  stm32_usb_descriptor_t *udp = USB_GET_DESCRIPTOR(ep);
  stm32_usb_pma_t *pmap = USB_ADDR2PTR(udp->TXADDR0);
 8002e30:	ea4f 0343 	mov.w	r3, r3, lsl #1
    buf += 16;
    pmap += 8;
  }
#endif /* STM32_USB_USE_FAST_COPY */

  while (i > 0) {
 8002e34:	dd13      	ble.n	8002e5e <usb_packet_write_from_buffer+0x4e>
 8002e36:	1e54      	subs	r4, r2, #1
 8002e38:	0864      	lsrs	r4, r4, #1
 8002e3a:	3304      	adds	r3, #4
 8002e3c:	eb03 0484 	add.w	r4, r3, r4, lsl #2
 8002e40:	3102      	adds	r1, #2
 8002e42:	e000      	b.n	8002e46 <usb_packet_write_from_buffer+0x36>
 8002e44:	3304      	adds	r3, #4
    uint32_t w;

    w  = *buf++;
 8002e46:	f811 2c02 	ldrb.w	r2, [r1, #-2]
    w |= *buf++ << 8;
 8002e4a:	f811 0c01 	ldrb.w	r0, [r1, #-1]
    buf += 16;
    pmap += 8;
  }
#endif /* STM32_USB_USE_FAST_COPY */

  while (i > 0) {
 8002e4e:	42a3      	cmp	r3, r4
    uint32_t w;

    w  = *buf++;
    w |= *buf++ << 8;
 8002e50:	ea42 2200 	orr.w	r2, r2, r0, lsl #8
 8002e54:	f101 0102 	add.w	r1, r1, #2
    *pmap++ = (stm32_usb_pma_t)w;
 8002e58:	f843 2c04 	str.w	r2, [r3, #-4]
    buf += 16;
    pmap += 8;
  }
#endif /* STM32_USB_USE_FAST_COPY */

  while (i > 0) {
 8002e5c:	d1f2      	bne.n	8002e44 <usb_packet_write_from_buffer+0x34>
    w  = *buf++;
    w |= *buf++ << 8;
    *pmap++ = (stm32_usb_pma_t)w;
    i -= 2;
  }
}
 8002e5e:	f85d 4b04 	ldr.w	r4, [sp], #4
 8002e62:	4770      	bx	lr
 8002e64:	40005c00 	.word	0x40005c00
	...

08002e70 <Vector90>:
/**
 * @brief   USB low priority interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_USB1_LP_HANDLER) {
 8002e70:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  uint32_t istr;
  USBDriver *usbp = &USBD1;

  OSAL_IRQ_PROLOGUE();

  istr = STM32_USB->ISTR;
 8002e74:	4b93      	ldr	r3, [pc, #588]	; (80030c4 <Vector90+0x254>)
/**
 * @brief   USB low priority interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_USB1_LP_HANDLER) {
 8002e76:	b083      	sub	sp, #12
  uint32_t istr;
  USBDriver *usbp = &USBD1;

  OSAL_IRQ_PROLOGUE();

  istr = STM32_USB->ISTR;
 8002e78:	6c5d      	ldr	r5, [r3, #68]	; 0x44

  /* USB bus reset condition handling.*/
  if (istr & ISTR_RESET) {
 8002e7a:	056f      	lsls	r7, r5, #21
 8002e7c:	f100 8113 	bmi.w	80030a6 <Vector90+0x236>

    _usb_reset(usbp);
  }

  /* USB bus SUSPEND condition handling.*/
  if (istr & ISTR_SUSP) {
 8002e80:	052e      	lsls	r6, r5, #20
 8002e82:	f100 8104 	bmi.w	800308e <Vector90+0x21e>

    _usb_suspend(usbp);
  }

  /* USB bus WAKEUP condition handling.*/
  if (istr & ISTR_WKUP) {
 8002e86:	04ec      	lsls	r4, r5, #19
 8002e88:	d508      	bpl.n	8002e9c <Vector90+0x2c>
    uint32_t fnr = STM32_USB->FNR;
 8002e8a:	4b8e      	ldr	r3, [pc, #568]	; (80030c4 <Vector90+0x254>)
 8002e8c:	6c9a      	ldr	r2, [r3, #72]	; 0x48
    if (!(fnr & FNR_RXDP)) {
 8002e8e:	0410      	lsls	r0, r2, #16
 8002e90:	f140 8110 	bpl.w	80030b4 <Vector90+0x244>
      /* Just noise, going back in SUSPEND mode, reference manual 22.4.5,
         table 169.*/
      STM32_USB->CNTR |= CNTR_LP_MODE;
    }
#endif
    STM32_USB->ISTR = ~ISTR_WKUP;
 8002e94:	4b8b      	ldr	r3, [pc, #556]	; (80030c4 <Vector90+0x254>)
 8002e96:	f46f 5280 	mvn.w	r2, #4096	; 0x1000
 8002e9a:	645a      	str	r2, [r3, #68]	; 0x44
  }

  /* SOF handling.*/
  if (istr & ISTR_SOF) {
 8002e9c:	05a9      	lsls	r1, r5, #22
 8002e9e:	d50b      	bpl.n	8002eb8 <Vector90+0x48>
    _usb_isr_invoke_sof_cb(usbp);
 8002ea0:	f8df a224 	ldr.w	sl, [pc, #548]	; 80030c8 <Vector90+0x258>
 8002ea4:	f8da 3004 	ldr.w	r3, [sl, #4]
 8002ea8:	68db      	ldr	r3, [r3, #12]
 8002eaa:	b10b      	cbz	r3, 8002eb0 <Vector90+0x40>
 8002eac:	4650      	mov	r0, sl
 8002eae:	4798      	blx	r3
    STM32_USB->ISTR = ~ISTR_SOF;
 8002eb0:	4b84      	ldr	r3, [pc, #528]	; (80030c4 <Vector90+0x254>)
 8002eb2:	f46f 7200 	mvn.w	r2, #512	; 0x200
 8002eb6:	645a      	str	r2, [r3, #68]	; 0x44
  }

  /* Endpoint events handling.*/
  while (istr & ISTR_CTR) {
 8002eb8:	042a      	lsls	r2, r5, #16
 8002eba:	f140 80b7 	bpl.w	800302c <Vector90+0x1bc>
 8002ebe:	f8df a208 	ldr.w	sl, [pc, #520]	; 80030c8 <Vector90+0x258>
    usb_serve_endpoints(usbp, istr & ISTR_EP_ID_MASK);
 8002ec2:	f005 050f 	and.w	r5, r5, #15
 8002ec6:	00ac      	lsls	r4, r5, #2
 8002ec8:	f104 4480 	add.w	r4, r4, #1073741824	; 0x40000000
 8002ecc:	f504 44b8 	add.w	r4, r4, #23552	; 0x5c00
 *
 * @notapi
 */
static void usb_serve_endpoints(USBDriver *usbp, uint32_t ep) {
  size_t n;
  uint32_t epr = STM32_USB->EPR[ep];
 8002ed0:	f8d4 8000 	ldr.w	r8, [r4]
  const USBEndpointConfig *epcp = usbp->epc[ep];
 8002ed4:	1cae      	adds	r6, r5, #2
 8002ed6:	eb0a 0386 	add.w	r3, sl, r6, lsl #2

  if (epr & EPR_CTR_TX) {
 8002eda:	f018 0f80 	tst.w	r8, #128	; 0x80
 * @notapi
 */
static void usb_serve_endpoints(USBDriver *usbp, uint32_t ep) {
  size_t n;
  uint32_t epr = STM32_USB->EPR[ep];
  const USBEndpointConfig *epcp = usbp->epc[ep];
 8002ede:	685f      	ldr	r7, [r3, #4]

  if (epr & EPR_CTR_TX) {
 8002ee0:	d02f      	beq.n	8002f42 <Vector90+0xd2>
    /* IN endpoint, transmission.*/
    USBInEndpointState *isp = epcp->in_state;
 8002ee2:	f8d7 e014 	ldr.w	lr, [r7, #20]

    EPR_CLEAR_CTR_TX(ep);
 8002ee6:	6823      	ldr	r3, [r4, #0]

    isp->txcnt += isp->txlast;
 8002ee8:	f8de 0004 	ldr.w	r0, [lr, #4]
 8002eec:	f8de 100c 	ldr.w	r1, [lr, #12]

  if (epr & EPR_CTR_TX) {
    /* IN endpoint, transmission.*/
    USBInEndpointState *isp = epcp->in_state;

    EPR_CLEAR_CTR_TX(ep);
 8002ef0:	f423 4378 	bic.w	r3, r3, #63488	; 0xf800

    isp->txcnt += isp->txlast;
    n = isp->txsize - isp->txcnt;
 8002ef4:	f8de 2000 	ldr.w	r2, [lr]

  if (epr & EPR_CTR_TX) {
    /* IN endpoint, transmission.*/
    USBInEndpointState *isp = epcp->in_state;

    EPR_CLEAR_CTR_TX(ep);
 8002ef8:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0

    isp->txcnt += isp->txlast;
 8002efc:	4408      	add	r0, r1

  if (epr & EPR_CTR_TX) {
    /* IN endpoint, transmission.*/
    USBInEndpointState *isp = epcp->in_state;

    EPR_CLEAR_CTR_TX(ep);
 8002efe:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8002f02:	6023      	str	r3, [r4, #0]

    isp->txcnt += isp->txlast;
 8002f04:	f8ce 0004 	str.w	r0, [lr, #4]
    n = isp->txsize - isp->txcnt;
    if (n > 0) {
 8002f08:	1a10      	subs	r0, r2, r0
 8002f0a:	f000 80a6 	beq.w	800305a <Vector90+0x1ea>
      /* Transfer not completed, there are more packets to send.*/
      if (n > epcp->in_maxsize)
 8002f0e:	8a3a      	ldrh	r2, [r7, #16]
        n = epcp->in_maxsize;

      /* Writes the packet from the defined buffer.*/
      isp->txbuf += isp->txlast;
 8002f10:	f8de 3008 	ldr.w	r3, [lr, #8]
 8002f14:	4282      	cmp	r2, r0
 8002f16:	bf28      	it	cs
 8002f18:	4602      	movcs	r2, r0
 8002f1a:	4419      	add	r1, r3
      isp->txlast = n;
 8002f1c:	f8ce 200c 	str.w	r2, [lr, #12]
      /* Transfer not completed, there are more packets to send.*/
      if (n > epcp->in_maxsize)
        n = epcp->in_maxsize;

      /* Writes the packet from the defined buffer.*/
      isp->txbuf += isp->txlast;
 8002f20:	f8ce 1008 	str.w	r1, [lr, #8]
      isp->txlast = n;
      usb_packet_write_from_buffer(ep, isp->txbuf, n);
 8002f24:	4628      	mov	r0, r5
 8002f26:	f7ff ff73 	bl	8002e10 <usb_packet_write_from_buffer>

      /* Starting IN operation.*/
      EPR_SET_STAT_TX(ep, EPR_STAT_TX_VALID);
 8002f2a:	6823      	ldr	r3, [r4, #0]
 8002f2c:	f423 43f0 	bic.w	r3, r3, #30720	; 0x7800
 8002f30:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8002f34:	f083 0330 	eor.w	r3, r3, #48	; 0x30
 8002f38:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8002f3c:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8002f40:	6023      	str	r3, [r4, #0]
    else {
      /* Transfer completed, invokes the callback.*/
      _usb_isr_invoke_in_cb(usbp, ep);
    }
  }
  if (epr & EPR_CTR_RX) {
 8002f42:	f418 4f00 	tst.w	r8, #32768	; 0x8000
 8002f46:	d06c      	beq.n	8003022 <Vector90+0x1b2>
    /* OUT endpoint, receive.*/

    EPR_CLEAR_CTR_RX(ep);
 8002f48:	6823      	ldr	r3, [r4, #0]

    if (epr & EPR_SETUP) {
 8002f4a:	f418 6f00 	tst.w	r8, #2048	; 0x800
    }
  }
  if (epr & EPR_CTR_RX) {
    /* OUT endpoint, receive.*/

    EPR_CLEAR_CTR_RX(ep);
 8002f4e:	f423 4378 	bic.w	r3, r3, #63488	; 0xf800
 8002f52:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 8002f56:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8002f5a:	6023      	str	r3, [r4, #0]

    if (epr & EPR_SETUP) {
 8002f5c:	f040 808f 	bne.w	800307e <Vector90+0x20e>
 *
 * @notapi
 */
static size_t usb_packet_read_to_buffer(usbep_t ep, uint8_t *buf) {
  size_t i, n;
  stm32_usb_descriptor_t *udp = USB_GET_DESCRIPTOR(ep);
 8002f60:	4b58      	ldr	r3, [pc, #352]	; (80030c4 <Vector90+0x254>)
      /* Setup packets handling, setup packets are handled using a
         specific callback.*/
      _usb_isr_invoke_setup_cb(usbp, ep);
    }
    else {
      USBOutEndpointState *osp = epcp->out_state;
 8002f62:	f8d7 e018 	ldr.w	lr, [r7, #24]
 *
 * @notapi
 */
static size_t usb_packet_read_to_buffer(usbep_t ep, uint8_t *buf) {
  size_t i, n;
  stm32_usb_descriptor_t *udp = USB_GET_DESCRIPTOR(ep);
 8002f66:	6d1b      	ldr	r3, [r3, #80]	; 0x50
    }
    else {
      USBOutEndpointState *osp = epcp->out_state;

      /* Reads the packet into the defined buffer.*/
      n = usb_packet_read_to_buffer(ep, osp->rxbuf);
 8002f68:	f8de b008 	ldr.w	fp, [lr, #8]
 8002f6c:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 8002f70:	f503 43c0 	add.w	r3, r3, #24576	; 0x6000
 *
 * @notapi
 */
static size_t usb_packet_read_to_buffer(usbep_t ep, uint8_t *buf) {
  size_t i, n;
  stm32_usb_descriptor_t *udp = USB_GET_DESCRIPTOR(ep);
 8002f74:	eb03 1305 	add.w	r3, r3, r5, lsl #4
  stm32_usb_pma_t *pmap = USB_ADDR2PTR(udp->RXADDR0);
 8002f78:	689a      	ldr	r2, [r3, #8]
  if (EPR_EP_TYPE_IS_ISO(epr) && !(epr & EPR_DTOG_RX))
    n = (size_t)udp->RXCOUNT1 & RXCOUNT_COUNT_MASK;
  else
    n = (size_t)udp->RXCOUNT0 & RXCOUNT_COUNT_MASK;
#else
  n = (size_t)udp->RXCOUNT0 & RXCOUNT_COUNT_MASK;
 8002f7a:	68db      	ldr	r3, [r3, #12]
 * @notapi
 */
static size_t usb_packet_read_to_buffer(usbep_t ep, uint8_t *buf) {
  size_t i, n;
  stm32_usb_descriptor_t *udp = USB_GET_DESCRIPTOR(ep);
  stm32_usb_pma_t *pmap = USB_ADDR2PTR(udp->RXADDR0);
 8002f7c:	f102 5900 	add.w	r9, r2, #536870912	; 0x20000000
  if (EPR_EP_TYPE_IS_ISO(epr) && !(epr & EPR_DTOG_RX))
    n = (size_t)udp->RXCOUNT1 & RXCOUNT_COUNT_MASK;
  else
    n = (size_t)udp->RXCOUNT0 & RXCOUNT_COUNT_MASK;
#else
  n = (size_t)udp->RXCOUNT0 & RXCOUNT_COUNT_MASK;
 8002f80:	f3c3 0c09 	ubfx	ip, r3, #0, #10
 * @notapi
 */
static size_t usb_packet_read_to_buffer(usbep_t ep, uint8_t *buf) {
  size_t i, n;
  stm32_usb_descriptor_t *udp = USB_GET_DESCRIPTOR(ep);
  stm32_usb_pma_t *pmap = USB_ADDR2PTR(udp->RXADDR0);
 8002f84:	f509 5940 	add.w	r9, r9, #12288	; 0x3000
    buf += 16;
    pmap += 8;
  }
#endif /* STM32_USB_USE_FAST_COPY */

  while (i >= 2) {
 8002f88:	f1bc 0f01 	cmp.w	ip, #1
  if (EPR_EP_TYPE_IS_ISO(epr) && !(epr & EPR_DTOG_RX))
    n = (size_t)udp->RXCOUNT1 & RXCOUNT_COUNT_MASK;
  else
    n = (size_t)udp->RXCOUNT0 & RXCOUNT_COUNT_MASK;
#else
  n = (size_t)udp->RXCOUNT0 & RXCOUNT_COUNT_MASK;
 8002f8c:	9301      	str	r3, [sp, #4]
 * @notapi
 */
static size_t usb_packet_read_to_buffer(usbep_t ep, uint8_t *buf) {
  size_t i, n;
  stm32_usb_descriptor_t *udp = USB_GET_DESCRIPTOR(ep);
  stm32_usb_pma_t *pmap = USB_ADDR2PTR(udp->RXADDR0);
 8002f8e:	ea4f 0949 	mov.w	r9, r9, lsl #1
    buf += 16;
    pmap += 8;
  }
#endif /* STM32_USB_USE_FAST_COPY */

  while (i >= 2) {
 8002f92:	4662      	mov	r2, ip
 8002f94:	d91a      	bls.n	8002fcc <Vector90+0x15c>
 8002f96:	4648      	mov	r0, r9
 8002f98:	f10b 0302 	add.w	r3, fp, #2
    uint32_t w = *pmap++;
 8002f9c:	f850 1b04 	ldr.w	r1, [r0], #4
    *buf++ = (uint8_t)w;
    *buf++ = (uint8_t)(w >> 8);
    i -= 2;
 8002fa0:	3a02      	subs	r2, #2
#endif /* STM32_USB_USE_FAST_COPY */

  while (i >= 2) {
    uint32_t w = *pmap++;
    *buf++ = (uint8_t)w;
    *buf++ = (uint8_t)(w >> 8);
 8002fa2:	ea4f 2811 	mov.w	r8, r1, lsr #8
    buf += 16;
    pmap += 8;
  }
#endif /* STM32_USB_USE_FAST_COPY */

  while (i >= 2) {
 8002fa6:	2a01      	cmp	r2, #1
    uint32_t w = *pmap++;
    *buf++ = (uint8_t)w;
 8002fa8:	f803 1c02 	strb.w	r1, [r3, #-2]
    *buf++ = (uint8_t)(w >> 8);
 8002fac:	f803 8c01 	strb.w	r8, [r3, #-1]
 8002fb0:	f103 0302 	add.w	r3, r3, #2
    buf += 16;
    pmap += 8;
  }
#endif /* STM32_USB_USE_FAST_COPY */

  while (i >= 2) {
 8002fb4:	d8f2      	bhi.n	8002f9c <Vector90+0x12c>
 8002fb6:	f1ac 0302 	sub.w	r3, ip, #2
 8002fba:	085b      	lsrs	r3, r3, #1
 8002fbc:	9a01      	ldr	r2, [sp, #4]
 8002fbe:	3301      	adds	r3, #1
 8002fc0:	f002 0201 	and.w	r2, r2, #1
 8002fc4:	eb09 0983 	add.w	r9, r9, r3, lsl #2
 8002fc8:	eb0b 0b43 	add.w	fp, fp, r3, lsl #1
    *buf++ = (uint8_t)w;
    *buf++ = (uint8_t)(w >> 8);
    i -= 2;
  }

  if (i >= 1) {
 8002fcc:	b11a      	cbz	r2, 8002fd6 <Vector90+0x166>
    *buf = (uint8_t)*pmap;
 8002fce:	f8d9 3000 	ldr.w	r3, [r9]
 8002fd2:	f88b 3000 	strb.w	r3, [fp]
      osp->rxbuf += n;

      /* Transaction data updated.*/
      osp->rxcnt  += n;
      osp->rxsize -= n;
      osp->rxpkts -= 1;
 8002fd6:	f8be 000c 	ldrh.w	r0, [lr, #12]

      /* The transaction is completed if the specified number of packets
         has been received or the current packet is a short packet.*/
      if ((n < epcp->out_maxsize) || (osp->rxpkts == 0)) {
 8002fda:	8a7f      	ldrh	r7, [r7, #18]
    else {
      USBOutEndpointState *osp = epcp->out_state;

      /* Reads the packet into the defined buffer.*/
      n = usb_packet_read_to_buffer(ep, osp->rxbuf);
      osp->rxbuf += n;
 8002fdc:	f8de 1008 	ldr.w	r1, [lr, #8]

      /* Transaction data updated.*/
      osp->rxcnt  += n;
 8002fe0:	f8de 2004 	ldr.w	r2, [lr, #4]
      osp->rxsize -= n;
 8002fe4:	f8de 3000 	ldr.w	r3, [lr]
      osp->rxpkts -= 1;
 8002fe8:	3801      	subs	r0, #1
 8002fea:	b280      	uxth	r0, r0
    else {
      USBOutEndpointState *osp = epcp->out_state;

      /* Reads the packet into the defined buffer.*/
      n = usb_packet_read_to_buffer(ep, osp->rxbuf);
      osp->rxbuf += n;
 8002fec:	4461      	add	r1, ip

      /* Transaction data updated.*/
      osp->rxcnt  += n;
 8002fee:	4462      	add	r2, ip
      osp->rxsize -= n;
 8002ff0:	ebcc 0303 	rsb	r3, ip, r3
      osp->rxpkts -= 1;

      /* The transaction is completed if the specified number of packets
         has been received or the current packet is a short packet.*/
      if ((n < epcp->out_maxsize) || (osp->rxpkts == 0)) {
 8002ff4:	4567      	cmp	r7, ip
      osp->rxbuf += n;

      /* Transaction data updated.*/
      osp->rxcnt  += n;
      osp->rxsize -= n;
      osp->rxpkts -= 1;
 8002ff6:	f8ae 000c 	strh.w	r0, [lr, #12]
    else {
      USBOutEndpointState *osp = epcp->out_state;

      /* Reads the packet into the defined buffer.*/
      n = usb_packet_read_to_buffer(ep, osp->rxbuf);
      osp->rxbuf += n;
 8002ffa:	f8ce 1008 	str.w	r1, [lr, #8]

      /* Transaction data updated.*/
      osp->rxcnt  += n;
 8002ffe:	f8ce 2004 	str.w	r2, [lr, #4]
      osp->rxsize -= n;
 8003002:	f8ce 3000 	str.w	r3, [lr]
      osp->rxpkts -= 1;

      /* The transaction is completed if the specified number of packets
         has been received or the current packet is a short packet.*/
      if ((n < epcp->out_maxsize) || (osp->rxpkts == 0)) {
 8003006:	d816      	bhi.n	8003036 <Vector90+0x1c6>
 8003008:	b1a8      	cbz	r0, 8003036 <Vector90+0x1c6>
        /* Transfer complete, invokes the callback.*/
        _usb_isr_invoke_out_cb(usbp, ep);
      }
      else {
        /* Transfer not complete, there are more packets to receive.*/
        EPR_SET_STAT_RX(ep, EPR_STAT_RX_VALID);
 800300a:	6823      	ldr	r3, [r4, #0]
 800300c:	f423 4390 	bic.w	r3, r3, #18432	; 0x4800
 8003010:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8003014:	f483 5340 	eor.w	r3, r3, #12288	; 0x3000
 8003018:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 800301c:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8003020:	6023      	str	r3, [r4, #0]
  }

  /* Endpoint events handling.*/
  while (istr & ISTR_CTR) {
    usb_serve_endpoints(usbp, istr & ISTR_EP_ID_MASK);
    istr = STM32_USB->ISTR;
 8003022:	4b28      	ldr	r3, [pc, #160]	; (80030c4 <Vector90+0x254>)
 8003024:	6c5d      	ldr	r5, [r3, #68]	; 0x44
    _usb_isr_invoke_sof_cb(usbp);
    STM32_USB->ISTR = ~ISTR_SOF;
  }

  /* Endpoint events handling.*/
  while (istr & ISTR_CTR) {
 8003026:	042b      	lsls	r3, r5, #16
 8003028:	f53f af4b 	bmi.w	8002ec2 <Vector90+0x52>
    usb_serve_endpoints(usbp, istr & ISTR_EP_ID_MASK);
    istr = STM32_USB->ISTR;
  }

  OSAL_IRQ_EPILOGUE();
}
 800302c:	b003      	add	sp, #12
 800302e:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  while (istr & ISTR_CTR) {
    usb_serve_endpoints(usbp, istr & ISTR_EP_ID_MASK);
    istr = STM32_USB->ISTR;
  }

  OSAL_IRQ_EPILOGUE();
 8003032:	f7fe bdad 	b.w	8001b90 <_port_irq_epilogue>

      /* The transaction is completed if the specified number of packets
         has been received or the current packet is a short packet.*/
      if ((n < epcp->out_maxsize) || (osp->rxpkts == 0)) {
        /* Transfer complete, invokes the callback.*/
        _usb_isr_invoke_out_cb(usbp, ep);
 8003036:	eb0a 0686 	add.w	r6, sl, r6, lsl #2
 800303a:	6872      	ldr	r2, [r6, #4]
 800303c:	f8ba 300a 	ldrh.w	r3, [sl, #10]
 8003040:	2101      	movs	r1, #1
 8003042:	40a9      	lsls	r1, r5
 8003044:	68d2      	ldr	r2, [r2, #12]
 8003046:	ea23 0301 	bic.w	r3, r3, r1
 800304a:	f8aa 300a 	strh.w	r3, [sl, #10]
 800304e:	2a00      	cmp	r2, #0
 8003050:	d0e7      	beq.n	8003022 <Vector90+0x1b2>
 8003052:	4629      	mov	r1, r5
 8003054:	481c      	ldr	r0, [pc, #112]	; (80030c8 <Vector90+0x258>)
 8003056:	4790      	blx	r2
 8003058:	e7e3      	b.n	8003022 <Vector90+0x1b2>
      /* Starting IN operation.*/
      EPR_SET_STAT_TX(ep, EPR_STAT_TX_VALID);
    }
    else {
      /* Transfer completed, invokes the callback.*/
      _usb_isr_invoke_in_cb(usbp, ep);
 800305a:	4b1b      	ldr	r3, [pc, #108]	; (80030c8 <Vector90+0x258>)
 800305c:	f8d7 c008 	ldr.w	ip, [r7, #8]
 8003060:	891a      	ldrh	r2, [r3, #8]
 8003062:	2301      	movs	r3, #1
 8003064:	40ab      	lsls	r3, r5
 8003066:	ea22 0303 	bic.w	r3, r2, r3
 800306a:	4a17      	ldr	r2, [pc, #92]	; (80030c8 <Vector90+0x258>)
 800306c:	8113      	strh	r3, [r2, #8]
 800306e:	f1bc 0f00 	cmp.w	ip, #0
 8003072:	f43f af66 	beq.w	8002f42 <Vector90+0xd2>
 8003076:	4610      	mov	r0, r2
 8003078:	4629      	mov	r1, r5
 800307a:	47e0      	blx	ip
 800307c:	e761      	b.n	8002f42 <Vector90+0xd2>
    EPR_CLEAR_CTR_RX(ep);

    if (epr & EPR_SETUP) {
      /* Setup packets handling, setup packets are handled using a
         specific callback.*/
      _usb_isr_invoke_setup_cb(usbp, ep);
 800307e:	eb0a 0686 	add.w	r6, sl, r6, lsl #2
 8003082:	6873      	ldr	r3, [r6, #4]
 8003084:	4629      	mov	r1, r5
 8003086:	685b      	ldr	r3, [r3, #4]
 8003088:	480f      	ldr	r0, [pc, #60]	; (80030c8 <Vector90+0x258>)
 800308a:	4798      	blx	r3
 800308c:	e7c9      	b.n	8003022 <Vector90+0x1b2>
    _usb_reset(usbp);
  }

  /* USB bus SUSPEND condition handling.*/
  if (istr & ISTR_SUSP) {
    STM32_USB->CNTR |= CNTR_FSUSP;
 800308e:	4b0d      	ldr	r3, [pc, #52]	; (80030c4 <Vector90+0x254>)
#if STM32_USB_LOW_POWER_ON_SUSPEND
    STM32_USB->CNTR |= CNTR_LP_MODE;
#endif
    STM32_USB->ISTR = ~ISTR_SUSP;
 8003090:	f46f 6100 	mvn.w	r1, #2048	; 0x800
    _usb_reset(usbp);
  }

  /* USB bus SUSPEND condition handling.*/
  if (istr & ISTR_SUSP) {
    STM32_USB->CNTR |= CNTR_FSUSP;
 8003094:	6c1a      	ldr	r2, [r3, #64]	; 0x40
#if STM32_USB_LOW_POWER_ON_SUSPEND
    STM32_USB->CNTR |= CNTR_LP_MODE;
#endif
    STM32_USB->ISTR = ~ISTR_SUSP;

    _usb_suspend(usbp);
 8003096:	480c      	ldr	r0, [pc, #48]	; (80030c8 <Vector90+0x258>)
    _usb_reset(usbp);
  }

  /* USB bus SUSPEND condition handling.*/
  if (istr & ISTR_SUSP) {
    STM32_USB->CNTR |= CNTR_FSUSP;
 8003098:	f042 0208 	orr.w	r2, r2, #8
 800309c:	641a      	str	r2, [r3, #64]	; 0x40
#if STM32_USB_LOW_POWER_ON_SUSPEND
    STM32_USB->CNTR |= CNTR_LP_MODE;
#endif
    STM32_USB->ISTR = ~ISTR_SUSP;
 800309e:	6459      	str	r1, [r3, #68]	; 0x44

    _usb_suspend(usbp);
 80030a0:	f7fe ff3e 	bl	8001f20 <_usb_suspend>
 80030a4:	e6ef      	b.n	8002e86 <Vector90+0x16>

  istr = STM32_USB->ISTR;

  /* USB bus reset condition handling.*/
  if (istr & ISTR_RESET) {
    STM32_USB->ISTR = ~ISTR_RESET;
 80030a6:	f46f 6280 	mvn.w	r2, #1024	; 0x400
 80030aa:	645a      	str	r2, [r3, #68]	; 0x44

    _usb_reset(usbp);
 80030ac:	4806      	ldr	r0, [pc, #24]	; (80030c8 <Vector90+0x258>)
 80030ae:	f7fe ff0f 	bl	8001ed0 <_usb_reset>
 80030b2:	e6e5      	b.n	8002e80 <Vector90+0x10>

  /* USB bus WAKEUP condition handling.*/
  if (istr & ISTR_WKUP) {
    uint32_t fnr = STM32_USB->FNR;
    if (!(fnr & FNR_RXDP)) {
      STM32_USB->CNTR &= ~CNTR_FSUSP;
 80030b4:	6c1a      	ldr	r2, [r3, #64]	; 0x40

      _usb_wakeup(usbp);
 80030b6:	4804      	ldr	r0, [pc, #16]	; (80030c8 <Vector90+0x258>)

  /* USB bus WAKEUP condition handling.*/
  if (istr & ISTR_WKUP) {
    uint32_t fnr = STM32_USB->FNR;
    if (!(fnr & FNR_RXDP)) {
      STM32_USB->CNTR &= ~CNTR_FSUSP;
 80030b8:	f022 0208 	bic.w	r2, r2, #8
 80030bc:	641a      	str	r2, [r3, #64]	; 0x40

      _usb_wakeup(usbp);
 80030be:	f7fe ff3f 	bl	8001f40 <_usb_wakeup>
 80030c2:	e6e7      	b.n	8002e94 <Vector90+0x24>
 80030c4:	40005c00 	.word	0x40005c00
 80030c8:	20000ccc 	.word	0x20000ccc
 80030cc:	00000000 	.word	0x00000000

080030d0 <usb_lld_init>:
 * @notapi
 */
void usb_lld_init(void) {

  /* Driver initialization.*/
  usbObjectInit(&USBD1);
 80030d0:	4801      	ldr	r0, [pc, #4]	; (80030d8 <usb_lld_init+0x8>)
 80030d2:	f7fe be9d 	b.w	8001e10 <usbObjectInit>
 80030d6:	bf00      	nop
 80030d8:	20000ccc 	.word	0x20000ccc
 80030dc:	00000000 	.word	0x00000000

080030e0 <usb_lld_set_address>:
 *
 * @notapi
 */
void usb_lld_set_address(USBDriver *usbp) {

  STM32_USB->DADDR = (uint32_t)(usbp->address) | DADDR_EF;
 80030e0:	f890 307e 	ldrb.w	r3, [r0, #126]	; 0x7e
 80030e4:	4a02      	ldr	r2, [pc, #8]	; (80030f0 <usb_lld_set_address+0x10>)
 80030e6:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 80030ea:	64d3      	str	r3, [r2, #76]	; 0x4c
 80030ec:	4770      	bx	lr
 80030ee:	bf00      	nop
 80030f0:	40005c00 	.word	0x40005c00
	...

08003100 <usb_lld_init_endpoint>:
 * @notapi
 */
void usb_lld_init_endpoint(USBDriver *usbp, usbep_t ep) {
  uint16_t epr;
  stm32_usb_descriptor_t *dp;
  const USBEndpointConfig *epcp = usbp->epc[ep];
 8003100:	eb00 0381 	add.w	r3, r0, r1, lsl #2
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_init_endpoint(USBDriver *usbp, usbep_t ep) {
 8003104:	b5f0      	push	{r4, r5, r6, r7, lr}
  uint16_t epr;
  stm32_usb_descriptor_t *dp;
  const USBEndpointConfig *epcp = usbp->epc[ep];
 8003106:	68de      	ldr	r6, [r3, #12]

  /* Setting the endpoint type. Note that isochronous endpoints cannot be
     bidirectional because it uses double buffering and both transmit and
     receive descriptor fields are used for either direction.*/
  switch (epcp->ep_mode & USB_EP_MODE_TYPE) {
 8003108:	6833      	ldr	r3, [r6, #0]
 800310a:	f013 0303 	ands.w	r3, r3, #3
 800310e:	d057      	beq.n	80031c0 <usb_lld_init_endpoint+0xc0>
 8003110:	2b02      	cmp	r3, #2
 8003112:	d961      	bls.n	80031d8 <usb_lld_init_endpoint+0xd8>
 8003114:	2b03      	cmp	r3, #3
 8003116:	d153      	bne.n	80031c0 <usb_lld_init_endpoint+0xc0>
#endif
  case USB_EP_MODE_TYPE_BULK:
    epr = EPR_EP_TYPE_BULK;
    break;
  case USB_EP_MODE_TYPE_INTR:
    epr = EPR_EP_TYPE_INTERRUPT;
 8003118:	f44f 64c0 	mov.w	r4, #1536	; 0x600
    break;
  default:
    epr = EPR_EP_TYPE_CONTROL;
  }

  dp = USB_GET_DESCRIPTOR(ep);
 800311c:	4b2f      	ldr	r3, [pc, #188]	; (80031dc <usb_lld_init_endpoint+0xdc>)

  /* IN endpoint handling.*/
  if (epcp->in_state != NULL) {
 800311e:	6972      	ldr	r2, [r6, #20]
    break;
  default:
    epr = EPR_EP_TYPE_CONTROL;
  }

  dp = USB_GET_DESCRIPTOR(ep);
 8003120:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8003122:	010f      	lsls	r7, r1, #4
 8003124:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 8003128:	f503 43c0 	add.w	r3, r3, #24576	; 0x6000
 800312c:	19dd      	adds	r5, r3, r7

  /* IN endpoint handling.*/
  if (epcp->in_state != NULL) {
 800312e:	b182      	cbz	r2, 8003152 <usb_lld_init_endpoint+0x52>
    dp->TXCOUNT0 = 0;
    dp->TXADDR0  = usb_pm_alloc(usbp, epcp->in_maxsize);
 8003130:	8a32      	ldrh	r2, [r6, #16]

  dp = USB_GET_DESCRIPTOR(ep);

  /* IN endpoint handling.*/
  if (epcp->in_state != NULL) {
    dp->TXCOUNT0 = 0;
 8003132:	f04f 0e00 	mov.w	lr, #0
 8003136:	f8c5 e004 	str.w	lr, [r5, #4]
 * @param[in] size      size of the packet buffer to allocate
 */
static uint32_t usb_pm_alloc(USBDriver *usbp, size_t size) {
  uint32_t next;

  next = usbp->pmnext;
 800313a:	f8d0 e084 	ldr.w	lr, [r0, #132]	; 0x84
  usbp->pmnext += (size + 1) & ~1;
 800313e:	3201      	adds	r2, #1
 8003140:	f022 0201 	bic.w	r2, r2, #1
 8003144:	4472      	add	r2, lr
 8003146:	f8c0 2084 	str.w	r2, [r0, #132]	; 0x84
    }
    else {
      epr |= EPR_STAT_TX_NAK;
    }
#else
    epr |= EPR_STAT_TX_NAK;
 800314a:	f044 0420 	orr.w	r4, r4, #32
  dp = USB_GET_DESCRIPTOR(ep);

  /* IN endpoint handling.*/
  if (epcp->in_state != NULL) {
    dp->TXCOUNT0 = 0;
    dp->TXADDR0  = usb_pm_alloc(usbp, epcp->in_maxsize);
 800314e:	f843 e007 	str.w	lr, [r3, r7]
    epr |= EPR_STAT_TX_NAK;
#endif
  }

  /* OUT endpoint handling.*/
  if (epcp->out_state != NULL) {
 8003152:	69b3      	ldr	r3, [r6, #24]
 8003154:	b1cb      	cbz	r3, 800318a <usb_lld_init_endpoint+0x8a>
    uint16_t nblocks;

    /* Endpoint size and address initialization.*/
    if (epcp->out_maxsize > 62)
 8003156:	8a72      	ldrh	r2, [r6, #18]
 8003158:	2a3e      	cmp	r2, #62	; 0x3e
      nblocks = (((((epcp->out_maxsize - 1) | 0x1f) + 1) / 32) << 10) |
 800315a:	f102 33ff 	add.w	r3, r2, #4294967295
  /* OUT endpoint handling.*/
  if (epcp->out_state != NULL) {
    uint16_t nblocks;

    /* Endpoint size and address initialization.*/
    if (epcp->out_maxsize > 62)
 800315e:	d932      	bls.n	80031c6 <usb_lld_init_endpoint+0xc6>
      nblocks = (((((epcp->out_maxsize - 1) | 0x1f) + 1) / 32) << 10) |
 8003160:	f043 031f 	orr.w	r3, r3, #31
 8003164:	3301      	adds	r3, #1
 8003166:	115b      	asrs	r3, r3, #5
 8003168:	ea6f 63c3 	mvn.w	r3, r3, lsl #27
 800316c:	ea6f 4353 	mvn.w	r3, r3, lsr #17
 8003170:	b29b      	uxth	r3, r3
                0x8000;
    else
      nblocks = ((((epcp->out_maxsize - 1) | 1) + 1) / 2) << 10;
    dp->RXCOUNT0 = nblocks;
 8003172:	60eb      	str	r3, [r5, #12]
 * @param[in] size      size of the packet buffer to allocate
 */
static uint32_t usb_pm_alloc(USBDriver *usbp, size_t size) {
  uint32_t next;

  next = usbp->pmnext;
 8003174:	f8d0 3084 	ldr.w	r3, [r0, #132]	; 0x84
  usbp->pmnext += (size + 1) & ~1;
 8003178:	3201      	adds	r2, #1
 800317a:	f022 0201 	bic.w	r2, r2, #1
 800317e:	441a      	add	r2, r3
 8003180:	f8c0 2084 	str.w	r2, [r0, #132]	; 0x84
    }
    else {
      epr |= EPR_STAT_RX_NAK;
    }
#else
    epr |= EPR_STAT_RX_NAK;
 8003184:	f444 5400 	orr.w	r4, r4, #8192	; 0x2000
      nblocks = (((((epcp->out_maxsize - 1) | 0x1f) + 1) / 32) << 10) |
                0x8000;
    else
      nblocks = ((((epcp->out_maxsize - 1) | 1) + 1) / 2) << 10;
    dp->RXCOUNT0 = nblocks;
    dp->RXADDR0  = usb_pm_alloc(usbp, epcp->out_maxsize);
 8003188:	60ab      	str	r3, [r5, #8]
#endif
  }

  /* EPxR register setup.*/
  EPR_SET(ep, epr | ep);
  EPR_TOGGLE(ep, epr);
 800318a:	f647 0270 	movw	r2, #30832	; 0x7870
    epr |= EPR_STAT_RX_NAK;
#endif
  }

  /* EPxR register setup.*/
  EPR_SET(ep, epr | ep);
 800318e:	ea44 0301 	orr.w	r3, r4, r1
 8003192:	f423 4378 	bic.w	r3, r3, #63488	; 0xf800
 8003196:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 800319a:	0089      	lsls	r1, r1, #2
 800319c:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 80031a0:	f101 4180 	add.w	r1, r1, #1073741824	; 0x40000000
 80031a4:	f501 41b8 	add.w	r1, r1, #23552	; 0x5c00
 80031a8:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 80031ac:	600b      	str	r3, [r1, #0]
  EPR_TOGGLE(ep, epr);
 80031ae:	680b      	ldr	r3, [r1, #0]
 80031b0:	4022      	ands	r2, r4
 80031b2:	4053      	eors	r3, r2
 80031b4:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 80031b8:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 80031bc:	600b      	str	r3, [r1, #0]
 80031be:	bdf0      	pop	{r4, r5, r6, r7, pc}
    break;
  case USB_EP_MODE_TYPE_INTR:
    epr = EPR_EP_TYPE_INTERRUPT;
    break;
  default:
    epr = EPR_EP_TYPE_CONTROL;
 80031c0:	f44f 7400 	mov.w	r4, #512	; 0x200
 80031c4:	e7aa      	b.n	800311c <usb_lld_init_endpoint+0x1c>
    /* Endpoint size and address initialization.*/
    if (epcp->out_maxsize > 62)
      nblocks = (((((epcp->out_maxsize - 1) | 0x1f) + 1) / 32) << 10) |
                0x8000;
    else
      nblocks = ((((epcp->out_maxsize - 1) | 1) + 1) / 2) << 10;
 80031c6:	f043 0301 	orr.w	r3, r3, #1
 80031ca:	3301      	adds	r3, #1
 80031cc:	eb03 73d3 	add.w	r3, r3, r3, lsr #31
 80031d0:	025b      	lsls	r3, r3, #9
 80031d2:	f403 437c 	and.w	r3, r3, #64512	; 0xfc00
 80031d6:	e7cc      	b.n	8003172 <usb_lld_init_endpoint+0x72>
    break;
#else
    osalDbgAssert(false, "isochronous support disabled");
#endif
  case USB_EP_MODE_TYPE_BULK:
    epr = EPR_EP_TYPE_BULK;
 80031d8:	2400      	movs	r4, #0
 80031da:	e79f      	b.n	800311c <usb_lld_init_endpoint+0x1c>
 80031dc:	40005c00 	.word	0x40005c00

080031e0 <usb_lld_reset>:
  STM32_USB->DADDR  = DADDR_EF;
  cntr              = /*CNTR_ESOFM | */ CNTR_RESETM  | CNTR_SUSPM |
                      CNTR_WKUPM | /*CNTR_ERRM | CNTR_PMAOVRM |*/ CNTR_CTRM;
  /* The SOF interrupt is only enabled if a callback is defined for
     this service because it is an high rate source.*/
  if (usbp->config->sof_cb != NULL)
 80031e0:	6841      	ldr	r1, [r0, #4]
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
void usb_lld_reset(USBDriver *usbp) {
 80031e2:	b5f0      	push	{r4, r5, r6, r7, lr}
  STM32_USB->DADDR  = DADDR_EF;
  cntr              = /*CNTR_ESOFM | */ CNTR_RESETM  | CNTR_SUSPM |
                      CNTR_WKUPM | /*CNTR_ERRM | CNTR_PMAOVRM |*/ CNTR_CTRM;
  /* The SOF interrupt is only enabled if a callback is defined for
     this service because it is an high rate source.*/
  if (usbp->config->sof_cb != NULL)
 80031e4:	68c9      	ldr	r1, [r1, #12]
 */
void usb_lld_reset(USBDriver *usbp) {
  uint32_t cntr;

  /* Post reset initialization.*/
  STM32_USB->BTABLE = BTABLE_ADDR;
 80031e6:	4b0d      	ldr	r3, [pc, #52]	; (800321c <usb_lld_reset+0x3c>)
  STM32_USB->DADDR  = DADDR_EF;
  cntr              = /*CNTR_ESOFM | */ CNTR_RESETM  | CNTR_SUSPM |
                      CNTR_WKUPM | /*CNTR_ERRM | CNTR_PMAOVRM |*/ CNTR_CTRM;
  /* The SOF interrupt is only enabled if a callback is defined for
     this service because it is an high rate source.*/
  if (usbp->config->sof_cb != NULL)
 80031e8:	2900      	cmp	r1, #0

  /* Resets the packet memory allocator.*/
  usb_pm_reset(usbp);

  /* EP0 initialization.*/
  usbp->epc[0] = &ep0config;
 80031ea:	4d0d      	ldr	r5, [pc, #52]	; (8003220 <usb_lld_reset+0x40>)
 */
void usb_lld_reset(USBDriver *usbp) {
  uint32_t cntr;

  /* Post reset initialization.*/
  STM32_USB->BTABLE = BTABLE_ADDR;
 80031ec:	f04f 0400 	mov.w	r4, #0
  cntr              = /*CNTR_ESOFM | */ CNTR_RESETM  | CNTR_SUSPM |
                      CNTR_WKUPM | /*CNTR_ERRM | CNTR_PMAOVRM |*/ CNTR_CTRM;
  /* The SOF interrupt is only enabled if a callback is defined for
     this service because it is an high rate source.*/
  if (usbp->config->sof_cb != NULL)
    cntr |= CNTR_SOFM;
 80031f0:	bf0c      	ite	eq
 80031f2:	f44f 471c 	moveq.w	r7, #39936	; 0x9c00
 80031f6:	f44f 471e 	movne.w	r7, #40448	; 0x9e00
  uint32_t cntr;

  /* Post reset initialization.*/
  STM32_USB->BTABLE = BTABLE_ADDR;
  STM32_USB->ISTR   = 0;
  STM32_USB->DADDR  = DADDR_EF;
 80031fa:	f04f 0e80 	mov.w	lr, #128	; 0x80
 */
static void usb_pm_reset(USBDriver *usbp) {

  /* The first 64 bytes are reserved for the descriptors table. The effective
     available RAM for endpoint buffers is just 448 bytes.*/
  usbp->pmnext = 64;
 80031fe:	2640      	movs	r6, #64	; 0x40
 */
void usb_lld_reset(USBDriver *usbp) {
  uint32_t cntr;

  /* Post reset initialization.*/
  STM32_USB->BTABLE = BTABLE_ADDR;
 8003200:	651c      	str	r4, [r3, #80]	; 0x50
  /* Resets the packet memory allocator.*/
  usb_pm_reset(usbp);

  /* EP0 initialization.*/
  usbp->epc[0] = &ep0config;
  usb_lld_init_endpoint(usbp, 0);
 8003202:	4621      	mov	r1, r4
void usb_lld_reset(USBDriver *usbp) {
  uint32_t cntr;

  /* Post reset initialization.*/
  STM32_USB->BTABLE = BTABLE_ADDR;
  STM32_USB->ISTR   = 0;
 8003204:	645c      	str	r4, [r3, #68]	; 0x44
  STM32_USB->DADDR  = DADDR_EF;
 8003206:	f8c3 e04c 	str.w	lr, [r3, #76]	; 0x4c
                      CNTR_WKUPM | /*CNTR_ERRM | CNTR_PMAOVRM |*/ CNTR_CTRM;
  /* The SOF interrupt is only enabled if a callback is defined for
     this service because it is an high rate source.*/
  if (usbp->config->sof_cb != NULL)
    cntr |= CNTR_SOFM;
  STM32_USB->CNTR = cntr;
 800320a:	641f      	str	r7, [r3, #64]	; 0x40
 */
static void usb_pm_reset(USBDriver *usbp) {

  /* The first 64 bytes are reserved for the descriptors table. The effective
     available RAM for endpoint buffers is just 448 bytes.*/
  usbp->pmnext = 64;
 800320c:	f8c0 6084 	str.w	r6, [r0, #132]	; 0x84

  /* Resets the packet memory allocator.*/
  usb_pm_reset(usbp);

  /* EP0 initialization.*/
  usbp->epc[0] = &ep0config;
 8003210:	60c5      	str	r5, [r0, #12]
  usb_lld_init_endpoint(usbp, 0);
}
 8003212:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
  /* Resets the packet memory allocator.*/
  usb_pm_reset(usbp);

  /* EP0 initialization.*/
  usbp->epc[0] = &ep0config;
  usb_lld_init_endpoint(usbp, 0);
 8003216:	f7ff bf73 	b.w	8003100 <usb_lld_init_endpoint>
 800321a:	bf00      	nop
 800321c:	40005c00 	.word	0x40005c00
 8003220:	08004810 	.word	0x08004810
	...

08003230 <usb_lld_disable_endpoints>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
void usb_lld_disable_endpoints(USBDriver *usbp) {
 8003230:	b410      	push	{r4}
  /* Resets the packet memory allocator.*/
  usb_pm_reset(usbp);

  /* Disabling all endpoints.*/
  for (i = 1; i <= USB_ENDOPOINTS_NUMBER; i++) {
    EPR_TOGGLE(i, 0);
 8003232:	f248 0480 	movw	r4, #32896	; 0x8080
 */
static void usb_pm_reset(USBDriver *usbp) {

  /* The first 64 bytes are reserved for the descriptors table. The effective
     available RAM for endpoint buffers is just 448 bytes.*/
  usbp->pmnext = 64;
 8003236:	2340      	movs	r3, #64	; 0x40
 8003238:	f8c0 3084 	str.w	r3, [r0, #132]	; 0x84

  /* Resets the packet memory allocator.*/
  usb_pm_reset(usbp);

  /* Disabling all endpoints.*/
  for (i = 1; i <= USB_ENDOPOINTS_NUMBER; i++) {
 800323c:	2101      	movs	r1, #1
 800323e:	008b      	lsls	r3, r1, #2
 8003240:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 8003244:	f503 43b8 	add.w	r3, r3, #23552	; 0x5c00
    EPR_TOGGLE(i, 0);
 8003248:	681a      	ldr	r2, [r3, #0]

  /* Resets the packet memory allocator.*/
  usb_pm_reset(usbp);

  /* Disabling all endpoints.*/
  for (i = 1; i <= USB_ENDOPOINTS_NUMBER; i++) {
 800324a:	3101      	adds	r1, #1
    EPR_TOGGLE(i, 0);
 800324c:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 8003250:	f042 0280 	orr.w	r2, r2, #128	; 0x80

  /* Resets the packet memory allocator.*/
  usb_pm_reset(usbp);

  /* Disabling all endpoints.*/
  for (i = 1; i <= USB_ENDOPOINTS_NUMBER; i++) {
 8003254:	2908      	cmp	r1, #8
    EPR_TOGGLE(i, 0);
 8003256:	601a      	str	r2, [r3, #0]
    EPR_SET(i, 0);
 8003258:	601c      	str	r4, [r3, #0]

  /* Resets the packet memory allocator.*/
  usb_pm_reset(usbp);

  /* Disabling all endpoints.*/
  for (i = 1; i <= USB_ENDOPOINTS_NUMBER; i++) {
 800325a:	d1f0      	bne.n	800323e <usb_lld_disable_endpoints+0xe>
    EPR_TOGGLE(i, 0);
    EPR_SET(i, 0);
  }
}
 800325c:	f85d 4b04 	ldr.w	r4, [sp], #4
 8003260:	4770      	bx	lr
 8003262:	bf00      	nop
	...

08003270 <usb_lld_get_status_out>:
 * @notapi
 */
usbepstatus_t usb_lld_get_status_out(USBDriver *usbp, usbep_t ep) {

  (void)usbp;
  switch (STM32_USB->EPR[ep] & EPR_STAT_RX_MASK) {
 8003270:	4b05      	ldr	r3, [pc, #20]	; (8003288 <usb_lld_get_status_out+0x18>)
 8003272:	f853 0021 	ldr.w	r0, [r3, r1, lsl #2]
 8003276:	f410 5040 	ands.w	r0, r0, #12288	; 0x3000
 800327a:	d004      	beq.n	8003286 <usb_lld_get_status_out+0x16>
 800327c:	f5b0 5f80 	cmp.w	r0, #4096	; 0x1000
  case EPR_STAT_RX_DIS:
    return EP_STATUS_DISABLED;
  case EPR_STAT_RX_STALL:
    return EP_STATUS_STALLED;
  default:
    return EP_STATUS_ACTIVE;
 8003280:	bf0c      	ite	eq
 8003282:	2001      	moveq	r0, #1
 8003284:	2002      	movne	r0, #2
  }
}
 8003286:	4770      	bx	lr
 8003288:	40005c00 	.word	0x40005c00
 800328c:	00000000 	.word	0x00000000

08003290 <usb_lld_get_status_in>:
 * @notapi
 */
usbepstatus_t usb_lld_get_status_in(USBDriver *usbp, usbep_t ep) {

  (void)usbp;
  switch (STM32_USB->EPR[ep] & EPR_STAT_TX_MASK) {
 8003290:	4b05      	ldr	r3, [pc, #20]	; (80032a8 <usb_lld_get_status_in+0x18>)
 8003292:	f853 0021 	ldr.w	r0, [r3, r1, lsl #2]
 8003296:	f010 0030 	ands.w	r0, r0, #48	; 0x30
 800329a:	d003      	beq.n	80032a4 <usb_lld_get_status_in+0x14>
 800329c:	2810      	cmp	r0, #16
  case EPR_STAT_TX_DIS:
    return EP_STATUS_DISABLED;
  case EPR_STAT_TX_STALL:
    return EP_STATUS_STALLED;
  default:
    return EP_STATUS_ACTIVE;
 800329e:	bf0c      	ite	eq
 80032a0:	2001      	moveq	r0, #1
 80032a2:	2002      	movne	r0, #2
  }
}
 80032a4:	4770      	bx	lr
 80032a6:	bf00      	nop
 80032a8:	40005c00 	.word	0x40005c00
 80032ac:	00000000 	.word	0x00000000

080032b0 <usb_lld_read_setup>:
  stm32_usb_pma_t *pmap;
  stm32_usb_descriptor_t *udp;
  uint32_t n;

  (void)usbp;
  udp = USB_GET_DESCRIPTOR(ep);
 80032b0:	4b0b      	ldr	r3, [pc, #44]	; (80032e0 <usb_lld_read_setup+0x30>)
 80032b2:	f102 0008 	add.w	r0, r2, #8
 80032b6:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 80032b8:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 80032bc:	f503 43c0 	add.w	r3, r3, #24576	; 0x6000
 80032c0:	eb03 1101 	add.w	r1, r3, r1, lsl #4
  pmap = USB_ADDR2PTR(udp->RXADDR0);
 80032c4:	688b      	ldr	r3, [r1, #8]
 80032c6:	f103 5300 	add.w	r3, r3, #536870912	; 0x20000000
 80032ca:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 80032ce:	005b      	lsls	r3, r3, #1
  for (n = 0; n < 4; n++) {
    *(uint16_t *)buf = (uint16_t)*pmap++;
 80032d0:	f853 1b04 	ldr.w	r1, [r3], #4
 80032d4:	f822 1b02 	strh.w	r1, [r2], #2
  uint32_t n;

  (void)usbp;
  udp = USB_GET_DESCRIPTOR(ep);
  pmap = USB_ADDR2PTR(udp->RXADDR0);
  for (n = 0; n < 4; n++) {
 80032d8:	4282      	cmp	r2, r0
 80032da:	d1f9      	bne.n	80032d0 <usb_lld_read_setup+0x20>
    *(uint16_t *)buf = (uint16_t)*pmap++;
    buf += 2;
  }
}
 80032dc:	4770      	bx	lr
 80032de:	bf00      	nop
 80032e0:	40005c00 	.word	0x40005c00
	...

080032f0 <usb_lld_start_out>:
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_start_out(USBDriver *usbp, usbep_t ep) {
  USBOutEndpointState *osp = usbp->epc[ep]->out_state;
 80032f0:	eb00 0081 	add.w	r0, r0, r1, lsl #2
 80032f4:	68c0      	ldr	r0, [r0, #12]
 80032f6:	6982      	ldr	r2, [r0, #24]

  /* Transfer initialization.*/
  if (osp->rxsize == 0)         /* Special case for zero sized packets.*/
 80032f8:	6813      	ldr	r3, [r2, #0]
 80032fa:	b1bb      	cbz	r3, 800332c <usb_lld_start_out+0x3c>
    osp->rxpkts = 1;
  else
    osp->rxpkts = (uint16_t)((osp->rxsize + usbp->epc[ep]->out_maxsize - 1) /
 80032fc:	8a40      	ldrh	r0, [r0, #18]
 80032fe:	3b01      	subs	r3, #1
 8003300:	4403      	add	r3, r0
 8003302:	fbb3 f3f0 	udiv	r3, r3, r0
 8003306:	8193      	strh	r3, [r2, #12]
 8003308:	0089      	lsls	r1, r1, #2
 800330a:	f101 4180 	add.w	r1, r1, #1073741824	; 0x40000000
 800330e:	f501 41b8 	add.w	r1, r1, #23552	; 0x5c00
                             usbp->epc[ep]->out_maxsize);

  EPR_SET_STAT_RX(ep, EPR_STAT_RX_VALID);
 8003312:	680b      	ldr	r3, [r1, #0]
 8003314:	f423 4390 	bic.w	r3, r3, #18432	; 0x4800
 8003318:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 800331c:	f483 5340 	eor.w	r3, r3, #12288	; 0x3000
 8003320:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8003324:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8003328:	600b      	str	r3, [r1, #0]
 800332a:	4770      	bx	lr
void usb_lld_start_out(USBDriver *usbp, usbep_t ep) {
  USBOutEndpointState *osp = usbp->epc[ep]->out_state;

  /* Transfer initialization.*/
  if (osp->rxsize == 0)         /* Special case for zero sized packets.*/
    osp->rxpkts = 1;
 800332c:	2301      	movs	r3, #1
 800332e:	8193      	strh	r3, [r2, #12]
 8003330:	e7ea      	b.n	8003308 <usb_lld_start_out+0x18>
 8003332:	bf00      	nop
	...

08003340 <usb_lld_start_in>:
 *
 * @notapi
 */
void usb_lld_start_in(USBDriver *usbp, usbep_t ep) {
  size_t n;
  USBInEndpointState *isp = usbp->epc[ep]->in_state;
 8003340:	eb00 0081 	add.w	r0, r0, r1, lsl #2
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_start_in(USBDriver *usbp, usbep_t ep) {
 8003344:	b538      	push	{r3, r4, r5, lr}
  size_t n;
  USBInEndpointState *isp = usbp->epc[ep]->in_state;
 8003346:	68c3      	ldr	r3, [r0, #12]
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_start_in(USBDriver *usbp, usbep_t ep) {
 8003348:	460c      	mov	r4, r1
  size_t n;
  USBInEndpointState *isp = usbp->epc[ep]->in_state;
 800334a:	695d      	ldr	r5, [r3, #20]

  /* Transfer initialization.*/
  n = isp->txsize;
  if (n > (size_t)usbp->epc[ep]->in_maxsize)
 800334c:	8a1a      	ldrh	r2, [r3, #16]
void usb_lld_start_in(USBDriver *usbp, usbep_t ep) {
  size_t n;
  USBInEndpointState *isp = usbp->epc[ep]->in_state;

  /* Transfer initialization.*/
  n = isp->txsize;
 800334e:	682b      	ldr	r3, [r5, #0]
  if (n > (size_t)usbp->epc[ep]->in_maxsize)
    n = (size_t)usbp->epc[ep]->in_maxsize;

  isp->txlast = n;
  usb_packet_write_from_buffer(ep, isp->txbuf, n);
 8003350:	4608      	mov	r0, r1
 8003352:	429a      	cmp	r2, r3
 8003354:	bf28      	it	cs
 8003356:	461a      	movcs	r2, r3
 8003358:	68a9      	ldr	r1, [r5, #8]
  /* Transfer initialization.*/
  n = isp->txsize;
  if (n > (size_t)usbp->epc[ep]->in_maxsize)
    n = (size_t)usbp->epc[ep]->in_maxsize;

  isp->txlast = n;
 800335a:	60ea      	str	r2, [r5, #12]
  usb_packet_write_from_buffer(ep, isp->txbuf, n);
 800335c:	f7ff fd58 	bl	8002e10 <usb_packet_write_from_buffer>
 8003360:	00a1      	lsls	r1, r4, #2
 8003362:	f101 4180 	add.w	r1, r1, #1073741824	; 0x40000000
 8003366:	f501 41b8 	add.w	r1, r1, #23552	; 0x5c00

  EPR_SET_STAT_TX(ep, EPR_STAT_TX_VALID);
 800336a:	680b      	ldr	r3, [r1, #0]
 800336c:	f423 43f0 	bic.w	r3, r3, #30720	; 0x7800
 8003370:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8003374:	f083 0330 	eor.w	r3, r3, #48	; 0x30
 8003378:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 800337c:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8003380:	600b      	str	r3, [r1, #0]
 8003382:	bd38      	pop	{r3, r4, r5, pc}
	...

08003390 <usb_lld_stall_out>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_stall_out(USBDriver *usbp, usbep_t ep) {
 8003390:	0089      	lsls	r1, r1, #2
 8003392:	f101 4180 	add.w	r1, r1, #1073741824	; 0x40000000
 8003396:	f501 41b8 	add.w	r1, r1, #23552	; 0x5c00

  (void)usbp;

  EPR_SET_STAT_RX(ep, EPR_STAT_RX_STALL);
 800339a:	680b      	ldr	r3, [r1, #0]
 800339c:	f423 4390 	bic.w	r3, r3, #18432	; 0x4800
 80033a0:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 80033a4:	f483 5380 	eor.w	r3, r3, #4096	; 0x1000
 80033a8:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 80033ac:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 80033b0:	600b      	str	r3, [r1, #0]
 80033b2:	4770      	bx	lr
	...

080033c0 <usb_lld_stall_in>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_stall_in(USBDriver *usbp, usbep_t ep) {
 80033c0:	0089      	lsls	r1, r1, #2
 80033c2:	f101 4180 	add.w	r1, r1, #1073741824	; 0x40000000
 80033c6:	f501 41b8 	add.w	r1, r1, #23552	; 0x5c00

  (void)usbp;

  EPR_SET_STAT_TX(ep, EPR_STAT_TX_STALL);
 80033ca:	680b      	ldr	r3, [r1, #0]
 80033cc:	f423 43f0 	bic.w	r3, r3, #30720	; 0x7800
 80033d0:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 80033d4:	f083 0310 	eor.w	r3, r3, #16
 80033d8:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 80033dc:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 80033e0:	600b      	str	r3, [r1, #0]
 80033e2:	4770      	bx	lr
	...

080033f0 <usb_lld_clear_out>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_clear_out(USBDriver *usbp, usbep_t ep) {
 80033f0:	0089      	lsls	r1, r1, #2
 80033f2:	f101 4180 	add.w	r1, r1, #1073741824	; 0x40000000
 80033f6:	f501 41b8 	add.w	r1, r1, #23552	; 0x5c00

  (void)usbp;

  /* Makes sure to not put to NAK an endpoint that is already
     transferring.*/
  if ((STM32_USB->EPR[ep] & EPR_STAT_RX_MASK) != EPR_STAT_RX_VALID)
 80033fa:	680b      	ldr	r3, [r1, #0]
 80033fc:	f403 5340 	and.w	r3, r3, #12288	; 0x3000
 8003400:	f5b3 5f40 	cmp.w	r3, #12288	; 0x3000
 8003404:	d009      	beq.n	800341a <usb_lld_clear_out+0x2a>
    EPR_SET_STAT_TX(ep, EPR_STAT_RX_NAK);
 8003406:	680b      	ldr	r3, [r1, #0]
 8003408:	f423 43f0 	bic.w	r3, r3, #30720	; 0x7800
 800340c:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8003410:	f443 4320 	orr.w	r3, r3, #40960	; 0xa000
 8003414:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8003418:	600b      	str	r3, [r1, #0]
 800341a:	4770      	bx	lr
 800341c:	0000      	movs	r0, r0
	...

08003420 <usb_lld_clear_in>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_clear_in(USBDriver *usbp, usbep_t ep) {
 8003420:	0089      	lsls	r1, r1, #2
 8003422:	f101 4180 	add.w	r1, r1, #1073741824	; 0x40000000
 8003426:	f501 41b8 	add.w	r1, r1, #23552	; 0x5c00

  (void)usbp;

  /* Makes sure to not put to NAK an endpoint that is already
     transferring.*/
  if ((STM32_USB->EPR[ep] & EPR_STAT_TX_MASK) != EPR_STAT_TX_VALID)
 800342a:	680b      	ldr	r3, [r1, #0]
 800342c:	f003 0330 	and.w	r3, r3, #48	; 0x30
 8003430:	2b30      	cmp	r3, #48	; 0x30
 8003432:	d00b      	beq.n	800344c <usb_lld_clear_in+0x2c>
    EPR_SET_STAT_TX(ep, EPR_STAT_TX_NAK);
 8003434:	680b      	ldr	r3, [r1, #0]
 8003436:	f423 43f0 	bic.w	r3, r3, #30720	; 0x7800
 800343a:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 800343e:	f083 0320 	eor.w	r3, r3, #32
 8003442:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8003446:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800344a:	600b      	str	r3, [r1, #0]
 800344c:	4770      	bx	lr
 800344e:	bf00      	nop

08003450 <__early_init>:
 * Early initialization code.
 * This initialization must be performed just after stack setup and before
 * any other initialization.
 */
void __early_init(void) {
  stm32_clock_init();
 8003450:	f7ff b826 	b.w	80024a0 <stm32_clock_init>
	...

08003460 <boardInit>:
 */
void boardInit(void) {
  /*
   *   JTAG-DP Disabled and SW-DP Enabled.
   */
   AFIO->MAPR |= AFIO_MAPR_TIM3_REMAP_NOREMAP | AFIO_MAPR_SWJ_CFG_JTAGDISABLE;
 8003460:	4a02      	ldr	r2, [pc, #8]	; (800346c <boardInit+0xc>)
 8003462:	6853      	ldr	r3, [r2, #4]
 8003464:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
 8003468:	6053      	str	r3, [r2, #4]
 800346a:	4770      	bx	lr
 800346c:	40010000 	.word	0x40010000

08003470 <pwmOutputSettingsUpdate>:
}

/**
 *
 */
void pwmOutputSettingsUpdate(const PPWMOutputStruct pNewSettings) {
 8003470:	4602      	mov	r2, r0
  memcpy((void *)&g_pwmOutput, (void *)pNewSettings, sizeof(g_pwmOutput));
 8003472:	4b03      	ldr	r3, [pc, #12]	; (8003480 <pwmOutputSettingsUpdate+0x10>)
 8003474:	6851      	ldr	r1, [r2, #4]
 8003476:	6800      	ldr	r0, [r0, #0]
 8003478:	6892      	ldr	r2, [r2, #8]
 800347a:	c307      	stmia	r3!, {r0, r1, r2}
 800347c:	4770      	bx	lr
 800347e:	bf00      	nop
 8003480:	20000800 	.word	0x20000800
	...

08003490 <mixedInputSettingsUpdate>:
}
//
///**
// *
// */
void mixedInputSettingsUpdate(const PMixedInputStruct pNewSettings) {
 8003490:	4770      	bx	lr
 8003492:	bf00      	nop
	...

080034a0 <long_to_string_with_divisor>:
#define FLOAT_PRECISION 9

static char *long_to_string_with_divisor(char *p,
                                         long num,
                                         unsigned radix,
                                         long divisor) {
 80034a0:	b4f0      	push	{r4, r5, r6, r7}
    ll = num;
  } else {
    ll = divisor;
  }

  q = p + MAX_FILLER;
 80034a2:	f100 070b 	add.w	r7, r0, #11
  int i;
  char *q;
  long l, ll;

  l = num;
  if (divisor == 0) {
 80034a6:	2b00      	cmp	r3, #0
 80034a8:	bf08      	it	eq
 80034aa:	460b      	moveq	r3, r1
    ll = num;
  } else {
    ll = divisor;
  }

  q = p + MAX_FILLER;
 80034ac:	463d      	mov	r5, r7
  do {
    i = (int)(l % radix);
 80034ae:	fbb1 f6f2 	udiv	r6, r1, r2
    i += '0';
    if (i > '9')
      i += 'A' - '0' - 10;
    *--q = i;
    l /= radix;
  } while ((ll /= radix) != 0);
 80034b2:	fbb3 f3f2 	udiv	r3, r3, r2
    ll = divisor;
  }

  q = p + MAX_FILLER;
  do {
    i = (int)(l % radix);
 80034b6:	fb02 1116 	mls	r1, r2, r6, r1
    i += '0';
 80034ba:	f101 0430 	add.w	r4, r1, #48	; 0x30
    if (i > '9')
 80034be:	2c39      	cmp	r4, #57	; 0x39
      i += 'A' - '0' - 10;
 80034c0:	bfc8      	it	gt
 80034c2:	f101 0437 	addgt.w	r4, r1, #55	; 0x37
    *--q = i;
 80034c6:	b2e4      	uxtb	r4, r4
 80034c8:	f805 4d01 	strb.w	r4, [r5, #-1]!
    l /= radix;
 80034cc:	4631      	mov	r1, r6
  } while ((ll /= radix) != 0);
 80034ce:	2b00      	cmp	r3, #0
 80034d0:	d1ed      	bne.n	80034ae <long_to_string_with_divisor+0xe>

  i = (int)(p + MAX_FILLER - q);
 80034d2:	1b7b      	subs	r3, r7, r5
 80034d4:	4403      	add	r3, r0
 80034d6:	e001      	b.n	80034dc <long_to_string_with_divisor+0x3c>
 80034d8:	f815 4f01 	ldrb.w	r4, [r5, #1]!
  do
    *p++ = *q++;
 80034dc:	f800 4b01 	strb.w	r4, [r0], #1
  while (--i);
 80034e0:	4298      	cmp	r0, r3
 80034e2:	d1f9      	bne.n	80034d8 <long_to_string_with_divisor+0x38>

  return p;
}
 80034e4:	bcf0      	pop	{r4, r5, r6, r7}
 80034e6:	4770      	bx	lr
	...

080034f0 <chvprintf>:
 * @return              The number of bytes that would have been
 *                      written to @p chp if no stream error occurs
 *
 * @api
 */
int chvprintf(BaseSequentialStream *chp, const char *fmt, va_list ap) {
 80034f0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80034f4:	4681      	mov	r9, r0
 80034f6:	460d      	mov	r5, r1
 80034f8:	4616      	mov	r6, r2
 80034fa:	4682      	mov	sl, r0
 80034fc:	b08d      	sub	sp, #52	; 0x34
  char *p, *s, c, filler;
  int i, precision, width;
  int n = 0;
 80034fe:	2300      	movs	r3, #0
 8003500:	9301      	str	r3, [sp, #4]
#else
  char tmpbuf[MAX_FILLER + 1];
#endif

  while (true) {
    c = *fmt++;
 8003502:	7829      	ldrb	r1, [r5, #0]
 8003504:	1c6b      	adds	r3, r5, #1
    if (c == 0)
 8003506:	b171      	cbz	r1, 8003526 <chvprintf+0x36>
      return n;
    if (c != '%') {
 8003508:	2925      	cmp	r1, #37	; 0x25
 800350a:	d010      	beq.n	800352e <chvprintf+0x3e>
#else
  char tmpbuf[MAX_FILLER + 1];
#endif

  while (true) {
    c = *fmt++;
 800350c:	461d      	mov	r5, r3
    if (c == 0)
      return n;
    if (c != '%') {
      streamPut(chp, (uint8_t)c);
      n++;
 800350e:	9c01      	ldr	r4, [sp, #4]
  while (true) {
    c = *fmt++;
    if (c == 0)
      return n;
    if (c != '%') {
      streamPut(chp, (uint8_t)c);
 8003510:	f8da 2000 	ldr.w	r2, [sl]
 8003514:	4650      	mov	r0, sl
 8003516:	6892      	ldr	r2, [r2, #8]
      n++;
 8003518:	3401      	adds	r4, #1
 800351a:	9401      	str	r4, [sp, #4]
  while (true) {
    c = *fmt++;
    if (c == 0)
      return n;
    if (c != '%') {
      streamPut(chp, (uint8_t)c);
 800351c:	4790      	blx	r2
#else
  char tmpbuf[MAX_FILLER + 1];
#endif

  while (true) {
    c = *fmt++;
 800351e:	7829      	ldrb	r1, [r5, #0]
 8003520:	1c6b      	adds	r3, r5, #1
    if (c == 0)
 8003522:	2900      	cmp	r1, #0
 8003524:	d1f0      	bne.n	8003508 <chvprintf+0x18>
      streamPut(chp, (uint8_t)filler);
      n++;
      width--;
    }
  }
}
 8003526:	9801      	ldr	r0, [sp, #4]
 8003528:	b00d      	add	sp, #52	; 0x34
 800352a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      continue;
    }
    p = tmpbuf;
    s = tmpbuf;
    left_align = FALSE;
    if (*fmt == '-') {
 800352e:	786a      	ldrb	r2, [r5, #1]
    filler = ' ';
    if (*fmt == '0') {
      fmt++;
      filler = '0';
    }
    width = 0;
 8003530:	2700      	movs	r7, #0
      continue;
    }
    p = tmpbuf;
    s = tmpbuf;
    left_align = FALSE;
    if (*fmt == '-') {
 8003532:	2a2d      	cmp	r2, #45	; 0x2d
 8003534:	bf03      	ittte	eq
 8003536:	78aa      	ldrbeq	r2, [r5, #2]
      fmt++;
 8003538:	1cab      	addeq	r3, r5, #2
      left_align = TRUE;
 800353a:	f04f 0901 	moveq.w	r9, #1
      n++;
      continue;
    }
    p = tmpbuf;
    s = tmpbuf;
    left_align = FALSE;
 800353e:	f04f 0900 	movne.w	r9, #0
    if (*fmt == '-') {
      fmt++;
      left_align = TRUE;
    }
    filler = ' ';
    if (*fmt == '0') {
 8003542:	2a30      	cmp	r2, #48	; 0x30
 8003544:	bf03      	ittte	eq
 8003546:	785a      	ldrbeq	r2, [r3, #1]
      fmt++;
 8003548:	3301      	addeq	r3, #1
      filler = '0';
 800354a:	f04f 0830 	moveq.w	r8, #48	; 0x30
    left_align = FALSE;
    if (*fmt == '-') {
      fmt++;
      left_align = TRUE;
    }
    filler = ' ';
 800354e:	f04f 0820 	movne.w	r8, #32
 8003552:	1c59      	adds	r1, r3, #1
 8003554:	e005      	b.n	8003562 <chvprintf+0x72>
    while (TRUE) {
      c = *fmt++;
      if (c >= '0' && c <= '9')
        c -= '0';
      else if (c == '*')
        c = va_arg(ap, int);
 8003556:	7833      	ldrb	r3, [r6, #0]
 8003558:	3604      	adds	r6, #4
 800355a:	782a      	ldrb	r2, [r5, #0]
      else
        break;
      width = width * 10 + c;
 800355c:	eb03 0740 	add.w	r7, r3, r0, lsl #1
 8003560:	3101      	adds	r1, #1
      filler = '0';
    }
    width = 0;
    while (TRUE) {
      c = *fmt++;
      if (c >= '0' && c <= '9')
 8003562:	f1a2 0330 	sub.w	r3, r2, #48	; 0x30
 8003566:	b2db      	uxtb	r3, r3
 8003568:	2b09      	cmp	r3, #9
      fmt++;
      filler = '0';
    }
    width = 0;
    while (TRUE) {
      c = *fmt++;
 800356a:	460d      	mov	r5, r1
        c -= '0';
      else if (c == '*')
        c = va_arg(ap, int);
      else
        break;
      width = width * 10 + c;
 800356c:	eb07 0087 	add.w	r0, r7, r7, lsl #2
      filler = '0';
    }
    width = 0;
    while (TRUE) {
      c = *fmt++;
      if (c >= '0' && c <= '9')
 8003570:	d9f3      	bls.n	800355a <chvprintf+0x6a>
        c -= '0';
      else if (c == '*')
 8003572:	2a2a      	cmp	r2, #42	; 0x2a
 8003574:	d0ef      	beq.n	8003556 <chvprintf+0x66>
      else
        break;
      width = width * 10 + c;
    }
    precision = 0;
    if (c == '.') {
 8003576:	2a2e      	cmp	r2, #46	; 0x2e
 8003578:	f04f 0b00 	mov.w	fp, #0
 800357c:	d043      	beq.n	8003606 <chvprintf+0x116>
        precision *= 10;
        precision += c;
      }
    }
    /* Long modifier.*/
    if (c == 'l' || c == 'L') {
 800357e:	f002 03df 	and.w	r3, r2, #223	; 0xdf
 8003582:	2b4c      	cmp	r3, #76	; 0x4c
 8003584:	d04e      	beq.n	8003624 <chvprintf+0x134>
    }
    else
      is_long = (c >= 'A') && (c <= 'Z');

    /* Command decoding.*/
    switch (c) {
 8003586:	f1a2 0144 	sub.w	r1, r2, #68	; 0x44
 800358a:	2934      	cmp	r1, #52	; 0x34
 800358c:	f200 8174 	bhi.w	8003878 <chvprintf+0x388>
 8003590:	e8df f011 	tbh	[pc, r1, lsl #1]
 8003594:	01720158 	.word	0x01720158
 8003598:	01720172 	.word	0x01720172
 800359c:	01580172 	.word	0x01580172
 80035a0:	01720172 	.word	0x01720172
 80035a4:	01720172 	.word	0x01720172
 80035a8:	012b0172 	.word	0x012b0172
 80035ac:	01720172 	.word	0x01720172
 80035b0:	01720172 	.word	0x01720172
 80035b4:	015f0172 	.word	0x015f0172
 80035b8:	01720172 	.word	0x01720172
 80035bc:	0172016f 	.word	0x0172016f
 80035c0:	01720172 	.word	0x01720172
 80035c4:	01720172 	.word	0x01720172
 80035c8:	01720172 	.word	0x01720172
 80035cc:	01720172 	.word	0x01720172
 80035d0:	01610172 	.word	0x01610172
 80035d4:	01720158 	.word	0x01720158
 80035d8:	017200d5 	.word	0x017200d5
 80035dc:	01580172 	.word	0x01580172
 80035e0:	01720172 	.word	0x01720172
 80035e4:	01720172 	.word	0x01720172
 80035e8:	012b0172 	.word	0x012b0172
 80035ec:	01720172 	.word	0x01720172
 80035f0:	00890172 	.word	0x00890172
 80035f4:	015f0172 	.word	0x015f0172
 80035f8:	01720172 	.word	0x01720172
 80035fc:	016f      	.short	0x016f
      while (TRUE) {
        c = *fmt++;
        if (c >= '0' && c <= '9')
          c -= '0';
        else if (c == '*')
          c = va_arg(ap, int);
 80035fe:	7833      	ldrb	r3, [r6, #0]
 8003600:	3604      	adds	r6, #4
        else
          break;
        precision *= 10;
        precision += c;
 8003602:	eb03 0b41 	add.w	fp, r3, r1, lsl #1
      width = width * 10 + c;
    }
    precision = 0;
    if (c == '.') {
      while (TRUE) {
        c = *fmt++;
 8003606:	f815 2b01 	ldrb.w	r2, [r5], #1
          c -= '0';
        else if (c == '*')
          c = va_arg(ap, int);
        else
          break;
        precision *= 10;
 800360a:	eb0b 018b 	add.w	r1, fp, fp, lsl #2
    }
    precision = 0;
    if (c == '.') {
      while (TRUE) {
        c = *fmt++;
        if (c >= '0' && c <= '9')
 800360e:	f1a2 0330 	sub.w	r3, r2, #48	; 0x30
 8003612:	b2db      	uxtb	r3, r3
 8003614:	2b09      	cmp	r3, #9
 8003616:	d9f4      	bls.n	8003602 <chvprintf+0x112>
          c -= '0';
        else if (c == '*')
 8003618:	2a2a      	cmp	r2, #42	; 0x2a
 800361a:	d0f0      	beq.n	80035fe <chvprintf+0x10e>
        precision *= 10;
        precision += c;
      }
    }
    /* Long modifier.*/
    if (c == 'l' || c == 'L') {
 800361c:	f002 03df 	and.w	r3, r2, #223	; 0xdf
 8003620:	2b4c      	cmp	r3, #76	; 0x4c
 8003622:	d1b0      	bne.n	8003586 <chvprintf+0x96>
      is_long = TRUE;
      if (*fmt)
 8003624:	782b      	ldrb	r3, [r5, #0]
 8003626:	2b00      	cmp	r3, #0
 8003628:	f000 8126 	beq.w	8003878 <chvprintf+0x388>
    }
    else
      is_long = (c >= 'A') && (c <= 'Z');

    /* Command decoding.*/
    switch (c) {
 800362c:	f1a3 0244 	sub.w	r2, r3, #68	; 0x44
    }
    /* Long modifier.*/
    if (c == 'l' || c == 'L') {
      is_long = TRUE;
      if (*fmt)
        c = *fmt++;
 8003630:	3501      	adds	r5, #1
    }
    else
      is_long = (c >= 'A') && (c <= 'Z');

    /* Command decoding.*/
    switch (c) {
 8003632:	2a34      	cmp	r2, #52	; 0x34
 8003634:	f200 811f 	bhi.w	8003876 <chvprintf+0x386>
 8003638:	e8df f012 	tbh	[pc, r2, lsl #1]
 800363c:	011d0104 	.word	0x011d0104
 8003640:	011d011d 	.word	0x011d011d
 8003644:	0104011d 	.word	0x0104011d
 8003648:	011d011d 	.word	0x011d011d
 800364c:	011d011d 	.word	0x011d011d
 8003650:	00d7011d 	.word	0x00d7011d
 8003654:	011d011d 	.word	0x011d011d
 8003658:	011d011d 	.word	0x011d011d
 800365c:	010b011d 	.word	0x010b011d
 8003660:	011d011d 	.word	0x011d011d
 8003664:	011d011b 	.word	0x011d011b
 8003668:	011d011d 	.word	0x011d011d
 800366c:	011d011d 	.word	0x011d011d
 8003670:	011d011d 	.word	0x011d011d
 8003674:	011d011d 	.word	0x011d011d
 8003678:	010d011d 	.word	0x010d011d
 800367c:	011d0104 	.word	0x011d0104
 8003680:	011d0081 	.word	0x011d0081
 8003684:	0104011d 	.word	0x0104011d
 8003688:	011d011d 	.word	0x011d011d
 800368c:	011d011d 	.word	0x011d011d
 8003690:	00d7011d 	.word	0x00d7011d
 8003694:	011d011d 	.word	0x011d011d
 8003698:	0035011d 	.word	0x0035011d
 800369c:	010b011d 	.word	0x010b011d
 80036a0:	011d011d 	.word	0x011d011d
 80036a4:	011b      	.short	0x011b
      filler = ' ';
      *p++ = va_arg(ap, int);
      break;
    case 's':
      filler = ' ';
      if ((s = va_arg(ap, char *)) == 0)
 80036a6:	6834      	ldr	r4, [r6, #0]
        s = "(null)";
 80036a8:	4b93      	ldr	r3, [pc, #588]	; (80038f8 <chvprintf+0x408>)
      filler = ' ';
      *p++ = va_arg(ap, int);
      break;
    case 's':
      filler = ' ';
      if ((s = va_arg(ap, char *)) == 0)
 80036aa:	3604      	adds	r6, #4
        s = "(null)";
 80036ac:	2c00      	cmp	r4, #0
 80036ae:	bf08      	it	eq
 80036b0:	461c      	moveq	r4, r3
      if (precision == 0)
        precision = 32767;
      for (p = s; *p && (--precision >= 0); p++)
 80036b2:	7823      	ldrb	r3, [r4, #0]
      break;
    case 's':
      filler = ' ';
      if ((s = va_arg(ap, char *)) == 0)
        s = "(null)";
      if (precision == 0)
 80036b4:	f1bb 0f00 	cmp.w	fp, #0
 80036b8:	f000 80fc 	beq.w	80038b4 <chvprintf+0x3c4>
        precision = 32767;
      for (p = s; *p && (--precision >= 0); p++)
 80036bc:	2b00      	cmp	r3, #0
 80036be:	f000 80fe 	beq.w	80038be <chvprintf+0x3ce>
 80036c2:	f10b 3bff 	add.w	fp, fp, #4294967295
 80036c6:	4620      	mov	r0, r4
 80036c8:	e002      	b.n	80036d0 <chvprintf+0x1e0>
 80036ca:	f1bb 0b01 	subs.w	fp, fp, #1
 80036ce:	d403      	bmi.n	80036d8 <chvprintf+0x1e8>
 80036d0:	f810 3f01 	ldrb.w	r3, [r0, #1]!
 80036d4:	2b00      	cmp	r3, #0
 80036d6:	d1f8      	bne.n	80036ca <chvprintf+0x1da>
 80036d8:	1b00      	subs	r0, r0, r4
    default:
      *p++ = c;
      break;
    }
    i = (int)(p - s);
    if ((width -= i) < 0)
 80036da:	1a3f      	subs	r7, r7, r0
 80036dc:	f100 3bff 	add.w	fp, r0, #4294967295
    case 'c':
      filler = ' ';
      *p++ = va_arg(ap, int);
      break;
    case 's':
      filler = ' ';
 80036e0:	f04f 0820 	mov.w	r8, #32
 80036e4:	ea27 77e7 	bic.w	r7, r7, r7, asr #31
      break;
    }
    i = (int)(p - s);
    if ((width -= i) < 0)
      width = 0;
    if (left_align == FALSE)
 80036e8:	f1b9 0f00 	cmp.w	r9, #0
 80036ec:	f000 8090 	beq.w	8003810 <chvprintf+0x320>
      do {
        streamPut(chp, (uint8_t)filler);
        n++;
      } while (++width != 0);
    }
    while (--i >= 0) {
 80036f0:	f1bb 0f00 	cmp.w	fp, #0
 80036f4:	db13      	blt.n	800371e <chvprintf+0x22e>
 80036f6:	46d9      	mov	r9, fp
      streamPut(chp, (uint8_t)*s++);
 80036f8:	f8da 3000 	ldr.w	r3, [sl]
      do {
        streamPut(chp, (uint8_t)filler);
        n++;
      } while (++width != 0);
    }
    while (--i >= 0) {
 80036fc:	f109 39ff 	add.w	r9, r9, #4294967295
      streamPut(chp, (uint8_t)*s++);
 8003700:	689b      	ldr	r3, [r3, #8]
 8003702:	4650      	mov	r0, sl
 8003704:	f814 1b01 	ldrb.w	r1, [r4], #1
 8003708:	4798      	blx	r3
      do {
        streamPut(chp, (uint8_t)filler);
        n++;
      } while (++width != 0);
    }
    while (--i >= 0) {
 800370a:	f1b9 3fff 	cmp.w	r9, #4294967295
 800370e:	d1f3      	bne.n	80036f8 <chvprintf+0x208>
 8003710:	9b01      	ldr	r3, [sp, #4]
 8003712:	3301      	adds	r3, #1
 8003714:	f1bb 0f00 	cmp.w	fp, #0
 8003718:	bfa8      	it	ge
 800371a:	445b      	addge	r3, fp
 800371c:	9301      	str	r3, [sp, #4]
      streamPut(chp, (uint8_t)*s++);
      n++;
    }

    while (width) {
 800371e:	2f00      	cmp	r7, #0
 8003720:	f43f aeef 	beq.w	8003502 <chvprintf+0x12>
 8003724:	463c      	mov	r4, r7
      streamPut(chp, (uint8_t)filler);
 8003726:	f8da 3000 	ldr.w	r3, [sl]
 800372a:	4650      	mov	r0, sl
 800372c:	689b      	ldr	r3, [r3, #8]
 800372e:	4641      	mov	r1, r8
 8003730:	4798      	blx	r3
    while (--i >= 0) {
      streamPut(chp, (uint8_t)*s++);
      n++;
    }

    while (width) {
 8003732:	3c01      	subs	r4, #1
 8003734:	d1f7      	bne.n	8003726 <chvprintf+0x236>
 8003736:	9b01      	ldr	r3, [sp, #4]
 8003738:	443b      	add	r3, r7
 800373a:	9301      	str	r3, [sp, #4]
 800373c:	e6e1      	b.n	8003502 <chvprintf+0x12>
      }
      p = ch_ltoa(p, l, 10);
      break;
#if CHPRINTF_USE_FLOAT
    case 'f':
      f = (float) va_arg(ap, double);
 800373e:	3607      	adds	r6, #7
 8003740:	f026 0607 	bic.w	r6, r6, #7
 8003744:	e9d6 0100 	ldrd	r0, r1, [r6]
 8003748:	f7fd f982 	bl	8000a50 <__aeabi_d2f>
      if (f < 0) {
 800374c:	2100      	movs	r1, #0
      }
      p = ch_ltoa(p, l, 10);
      break;
#if CHPRINTF_USE_FLOAT
    case 'f':
      f = (float) va_arg(ap, double);
 800374e:	3608      	adds	r6, #8
 8003750:	4604      	mov	r4, r0
      if (f < 0) {
 8003752:	f7fd fc7b 	bl	800104c <__aeabi_fcmplt>
 8003756:	2800      	cmp	r0, #0
 8003758:	f040 80c2 	bne.w	80038e0 <chvprintf+0x3f0>
    if (c != '%') {
      streamPut(chp, (uint8_t)c);
      n++;
      continue;
    }
    p = tmpbuf;
 800375c:	ab06      	add	r3, sp, #24
};

static char *ftoa(char *p, double num, unsigned long precision) {
  long l;

  if ((precision == 0) || (precision > FLOAT_PRECISION))
 800375e:	f10b 3bff 	add.w	fp, fp, #4294967295
 8003762:	f1bb 0f08 	cmp.w	fp, #8
    precision = FLOAT_PRECISION;
  precision = pow10[precision - 1];
 8003766:	4a65      	ldr	r2, [pc, #404]	; (80038fc <chvprintf+0x40c>)
 8003768:	bf28      	it	cs
 800376a:	f04f 0b08 	movcs.w	fp, #8
 800376e:	9302      	str	r3, [sp, #8]
 8003770:	f852 302b 	ldr.w	r3, [r2, fp, lsl #2]

  l = (long)num;
 8003774:	4620      	mov	r0, r4
static char *ftoa(char *p, double num, unsigned long precision) {
  long l;

  if ((precision == 0) || (precision > FLOAT_PRECISION))
    precision = FLOAT_PRECISION;
  precision = pow10[precision - 1];
 8003776:	9304      	str	r3, [sp, #16]

  l = (long)num;
 8003778:	f7fd fc92 	bl	80010a0 <__aeabi_f2iz>
 800377c:	4683      	mov	fp, r0
  p = long_to_string_with_divisor(p, l, 10, 0);
 800377e:	9b02      	ldr	r3, [sp, #8]
 8003780:	220a      	movs	r2, #10
 8003782:	4618      	mov	r0, r3
 8003784:	4659      	mov	r1, fp
 8003786:	2300      	movs	r3, #0
 8003788:	f7ff fe8a 	bl	80034a0 <long_to_string_with_divisor>
  *p++ = '.';
 800378c:	4684      	mov	ip, r0
 800378e:	232e      	movs	r3, #46	; 0x2e
 8003790:	f80c 3b01 	strb.w	r3, [ip], #1
      f = (float) va_arg(ap, double);
      if (f < 0) {
        *p++ = '-';
        f = -f;
      }
      p = ftoa(p, f, precision);
 8003794:	4620      	mov	r0, r4
    precision = FLOAT_PRECISION;
  precision = pow10[precision - 1];

  l = (long)num;
  p = long_to_string_with_divisor(p, l, 10, 0);
  *p++ = '.';
 8003796:	f8cd c014 	str.w	ip, [sp, #20]
 800379a:	f8cd c008 	str.w	ip, [sp, #8]
      f = (float) va_arg(ap, double);
      if (f < 0) {
        *p++ = '-';
        f = -f;
      }
      p = ftoa(p, f, precision);
 800379e:	f7fc fec3 	bl	8000528 <__aeabi_f2d>
 80037a2:	e9cd 0102 	strd	r0, r1, [sp, #8]
  precision = pow10[precision - 1];

  l = (long)num;
  p = long_to_string_with_divisor(p, l, 10, 0);
  *p++ = '.';
  l = (long)((num - l) * precision);
 80037a6:	4658      	mov	r0, fp
 80037a8:	f7fc feac 	bl	8000504 <__aeabi_i2d>
 80037ac:	4602      	mov	r2, r0
 80037ae:	460b      	mov	r3, r1
 80037b0:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 80037b4:	f7fc fd58 	bl	8000268 <__aeabi_dsub>
 80037b8:	9c04      	ldr	r4, [sp, #16]
 80037ba:	e9cd 0102 	strd	r0, r1, [sp, #8]
 80037be:	4620      	mov	r0, r4
 80037c0:	f7fc fe90 	bl	80004e4 <__aeabi_ui2d>
 80037c4:	4602      	mov	r2, r0
 80037c6:	460b      	mov	r3, r1
 80037c8:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 80037cc:	f7fc ff00 	bl	80005d0 <__aeabi_dmul>
 80037d0:	f7fd f916 	bl	8000a00 <__aeabi_d2iz>
  return long_to_string_with_divisor(p, l, 10, precision / 10);
 80037d4:	4622      	mov	r2, r4
 80037d6:	4b4a      	ldr	r3, [pc, #296]	; (8003900 <chvprintf+0x410>)
 80037d8:	f8dd c014 	ldr.w	ip, [sp, #20]
 80037dc:	fba3 2302 	umull	r2, r3, r3, r2
  precision = pow10[precision - 1];

  l = (long)num;
  p = long_to_string_with_divisor(p, l, 10, 0);
  *p++ = '.';
  l = (long)((num - l) * precision);
 80037e0:	4601      	mov	r1, r0
  return long_to_string_with_divisor(p, l, 10, precision / 10);
 80037e2:	08db      	lsrs	r3, r3, #3
 80037e4:	4660      	mov	r0, ip
 80037e6:	220a      	movs	r2, #10
 80037e8:	e004      	b.n	80037f4 <chvprintf+0x304>
 80037ea:	2208      	movs	r2, #8
      c = 8;
unsigned_common:
      if (is_long)
        l = va_arg(ap, unsigned long);
      else
        l = va_arg(ap, unsigned int);
 80037ec:	6831      	ldr	r1, [r6, #0]
  return p;
}

static char *ch_ltoa(char *p, long num, unsigned radix) {

  return long_to_string_with_divisor(p, num, radix, 0);
 80037ee:	a806      	add	r0, sp, #24
      c = 8;
unsigned_common:
      if (is_long)
        l = va_arg(ap, unsigned long);
      else
        l = va_arg(ap, unsigned int);
 80037f0:	3604      	adds	r6, #4
  return p;
}

static char *ch_ltoa(char *p, long num, unsigned radix) {

  return long_to_string_with_divisor(p, num, radix, 0);
 80037f2:	2300      	movs	r3, #0
 80037f4:	f7ff fe54 	bl	80034a0 <long_to_string_with_divisor>
 80037f8:	ab06      	add	r3, sp, #24
      streamPut(chp, (uint8_t)c);
      n++;
      continue;
    }
    p = tmpbuf;
    s = tmpbuf;
 80037fa:	461c      	mov	r4, r3
 80037fc:	1ac0      	subs	r0, r0, r3
 80037fe:	f100 3bff 	add.w	fp, r0, #4294967295
    default:
      *p++ = c;
      break;
    }
    i = (int)(p - s);
    if ((width -= i) < 0)
 8003802:	1a3f      	subs	r7, r7, r0
 8003804:	ea27 77e7 	bic.w	r7, r7, r7, asr #31
      width = 0;
    if (left_align == FALSE)
 8003808:	f1b9 0f00 	cmp.w	r9, #0
 800380c:	f47f af70 	bne.w	80036f0 <chvprintf+0x200>
      width = -width;
 8003810:	f1c7 0900 	rsb	r9, r7, #0
    if (width < 0) {
 8003814:	f1b9 0f00 	cmp.w	r9, #0
 8003818:	d037      	beq.n	800388a <chvprintf+0x39a>
      if (*s == '-' && filler == '0') {
 800381a:	7821      	ldrb	r1, [r4, #0]
 800381c:	292d      	cmp	r1, #45	; 0x2d
 800381e:	d03a      	beq.n	8003896 <chvprintf+0x3a6>
        streamPut(chp, (uint8_t)*s++);
        n++;
 8003820:	464f      	mov	r7, r9
        i--;
      }
      do {
        streamPut(chp, (uint8_t)filler);
 8003822:	f8da 3000 	ldr.w	r3, [sl]
 8003826:	4650      	mov	r0, sl
 8003828:	689b      	ldr	r3, [r3, #8]
 800382a:	4641      	mov	r1, r8
 800382c:	4798      	blx	r3
        n++;
      } while (++width != 0);
 800382e:	3701      	adds	r7, #1
 8003830:	d1f7      	bne.n	8003822 <chvprintf+0x332>
 8003832:	9b01      	ldr	r3, [sp, #4]
    }
    while (--i >= 0) {
 8003834:	f1bb 0f00 	cmp.w	fp, #0
 8003838:	ebc9 0303 	rsb	r3, r9, r3
 800383c:	9301      	str	r3, [sp, #4]
 800383e:	f6bf af5a 	bge.w	80036f6 <chvprintf+0x206>
 8003842:	e65e      	b.n	8003502 <chvprintf+0x12>
    case 'I':
    case 'i':
      if (is_long)
        l = va_arg(ap, long);
      else
        l = va_arg(ap, int);
 8003844:	6831      	ldr	r1, [r6, #0]
 8003846:	3604      	adds	r6, #4
      if (l < 0) {
 8003848:	2900      	cmp	r1, #0
 800384a:	db42      	blt.n	80038d2 <chvprintf+0x3e2>
    if (c != '%') {
      streamPut(chp, (uint8_t)c);
      n++;
      continue;
    }
    p = tmpbuf;
 800384c:	a806      	add	r0, sp, #24
  return p;
}

static char *ch_ltoa(char *p, long num, unsigned radix) {

  return long_to_string_with_divisor(p, num, radix, 0);
 800384e:	220a      	movs	r2, #10
 8003850:	e7cf      	b.n	80037f2 <chvprintf+0x302>
      c = 16;
      goto unsigned_common;
    case 'U':
    case 'u':
      c = 10;
      goto unsigned_common;
 8003852:	220a      	movs	r2, #10
 8003854:	e7ca      	b.n	80037ec <chvprintf+0x2fc>

    /* Command decoding.*/
    switch (c) {
    case 'c':
      filler = ' ';
      *p++ = va_arg(ap, int);
 8003856:	6833      	ldr	r3, [r6, #0]
 8003858:	aa06      	add	r2, sp, #24
 800385a:	f10d 0019 	add.w	r0, sp, #25
 800385e:	1a80      	subs	r0, r0, r2
 8003860:	f100 3bff 	add.w	fp, r0, #4294967295
 8003864:	f88d 3018 	strb.w	r3, [sp, #24]
 8003868:	3604      	adds	r6, #4
      is_long = (c >= 'A') && (c <= 'Z');

    /* Command decoding.*/
    switch (c) {
    case 'c':
      filler = ' ';
 800386a:	f04f 0820 	mov.w	r8, #32
      streamPut(chp, (uint8_t)c);
      n++;
      continue;
    }
    p = tmpbuf;
    s = tmpbuf;
 800386e:	4614      	mov	r4, r2
    /* Command decoding.*/
    switch (c) {
    case 'c':
      filler = ' ';
      *p++ = va_arg(ap, int);
      break;
 8003870:	e7c7      	b.n	8003802 <chvprintf+0x312>
    }
    else
      is_long = (c >= 'A') && (c <= 'Z');

    /* Command decoding.*/
    switch (c) {
 8003872:	2210      	movs	r2, #16
 8003874:	e7ba      	b.n	80037ec <chvprintf+0x2fc>
 8003876:	461a      	mov	r2, r3
      streamPut(chp, (uint8_t)c);
      n++;
      continue;
    }
    p = tmpbuf;
    s = tmpbuf;
 8003878:	ac06      	add	r4, sp, #24
 800387a:	f10d 0019 	add.w	r0, sp, #25
 800387e:	1b00      	subs	r0, r0, r4
      else
        l = va_arg(ap, unsigned int);
      p = ch_ltoa(p, l, c);
      break;
    default:
      *p++ = c;
 8003880:	f88d 2018 	strb.w	r2, [sp, #24]
 8003884:	f100 3bff 	add.w	fp, r0, #4294967295
      break;
 8003888:	e7bb      	b.n	8003802 <chvprintf+0x312>
      do {
        streamPut(chp, (uint8_t)filler);
        n++;
      } while (++width != 0);
    }
    while (--i >= 0) {
 800388a:	f1bb 0f00 	cmp.w	fp, #0
 800388e:	464f      	mov	r7, r9
 8003890:	f6bf af31 	bge.w	80036f6 <chvprintf+0x206>
 8003894:	e635      	b.n	8003502 <chvprintf+0x12>
    if ((width -= i) < 0)
      width = 0;
    if (left_align == FALSE)
      width = -width;
    if (width < 0) {
      if (*s == '-' && filler == '0') {
 8003896:	f1b8 0f30 	cmp.w	r8, #48	; 0x30
 800389a:	d1c1      	bne.n	8003820 <chvprintf+0x330>
        streamPut(chp, (uint8_t)*s++);
 800389c:	f8da 3000 	ldr.w	r3, [sl]
 80038a0:	4650      	mov	r0, sl
 80038a2:	689b      	ldr	r3, [r3, #8]
 80038a4:	4798      	blx	r3
        n++;
 80038a6:	9b01      	ldr	r3, [sp, #4]
      width = 0;
    if (left_align == FALSE)
      width = -width;
    if (width < 0) {
      if (*s == '-' && filler == '0') {
        streamPut(chp, (uint8_t)*s++);
 80038a8:	3401      	adds	r4, #1
        n++;
 80038aa:	3301      	adds	r3, #1
 80038ac:	9301      	str	r3, [sp, #4]
 80038ae:	f10b 3bff 	add.w	fp, fp, #4294967295
 80038b2:	e7b5      	b.n	8003820 <chvprintf+0x330>
      filler = ' ';
      if ((s = va_arg(ap, char *)) == 0)
        s = "(null)";
      if (precision == 0)
        precision = 32767;
      for (p = s; *p && (--precision >= 0); p++)
 80038b4:	f647 7bfe 	movw	fp, #32766	; 0x7ffe
 80038b8:	2b00      	cmp	r3, #0
 80038ba:	f47f af04 	bne.w	80036c6 <chvprintf+0x1d6>
 80038be:	ea27 77e7 	bic.w	r7, r7, r7, asr #31
      break;
    }
    i = (int)(p - s);
    if ((width -= i) < 0)
      width = 0;
    if (left_align == FALSE)
 80038c2:	f1b9 0f00 	cmp.w	r9, #0
 80038c6:	d113      	bne.n	80038f0 <chvprintf+0x400>
 80038c8:	f04f 3bff 	mov.w	fp, #4294967295
 80038cc:	f04f 0820 	mov.w	r8, #32
 80038d0:	e79e      	b.n	8003810 <chvprintf+0x320>
      if (is_long)
        l = va_arg(ap, long);
      else
        l = va_arg(ap, int);
      if (l < 0) {
        *p++ = '-';
 80038d2:	232d      	movs	r3, #45	; 0x2d
        l = -l;
 80038d4:	4249      	negs	r1, r1
      if (is_long)
        l = va_arg(ap, long);
      else
        l = va_arg(ap, int);
      if (l < 0) {
        *p++ = '-';
 80038d6:	f88d 3018 	strb.w	r3, [sp, #24]
 80038da:	f10d 0019 	add.w	r0, sp, #25
 80038de:	e7b6      	b.n	800384e <chvprintf+0x35e>
      break;
#if CHPRINTF_USE_FLOAT
    case 'f':
      f = (float) va_arg(ap, double);
      if (f < 0) {
        *p++ = '-';
 80038e0:	232d      	movs	r3, #45	; 0x2d
 80038e2:	f88d 3018 	strb.w	r3, [sp, #24]
        f = -f;
 80038e6:	f104 4400 	add.w	r4, r4, #2147483648	; 0x80000000
      break;
#if CHPRINTF_USE_FLOAT
    case 'f':
      f = (float) va_arg(ap, double);
      if (f < 0) {
        *p++ = '-';
 80038ea:	f10d 0319 	add.w	r3, sp, #25
 80038ee:	e736      	b.n	800375e <chvprintf+0x26e>
      break;
    }
    i = (int)(p - s);
    if ((width -= i) < 0)
      width = 0;
    if (left_align == FALSE)
 80038f0:	f04f 0820 	mov.w	r8, #32
 80038f4:	e713      	b.n	800371e <chvprintf+0x22e>
 80038f6:	bf00      	nop
 80038f8:	080048a0 	.word	0x080048a0
 80038fc:	080048b0 	.word	0x080048b0
 8003900:	cccccccd 	.word	0xcccccccd
	...

08003910 <chprintf>:
 * @param[in] chp       pointer to a @p BaseSequentialStream implementing object
 * @param[in] fmt       formatting string
 *
 * @api
 */
int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
 8003910:	b40e      	push	{r1, r2, r3}
 8003912:	b500      	push	{lr}
 8003914:	b082      	sub	sp, #8
 8003916:	ab03      	add	r3, sp, #12
 8003918:	f853 1b04 	ldr.w	r1, [r3], #4
  va_list ap;
  int formatted_bytes;

  va_start(ap, fmt);
  formatted_bytes = chvprintf(chp, fmt, ap);
 800391c:	461a      	mov	r2, r3
 */
int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
  va_list ap;
  int formatted_bytes;

  va_start(ap, fmt);
 800391e:	9301      	str	r3, [sp, #4]
  formatted_bytes = chvprintf(chp, fmt, ap);
 8003920:	f7ff fde6 	bl	80034f0 <chvprintf>
  va_end(ap);

  return formatted_bytes;
}
 8003924:	b002      	add	sp, #8
 8003926:	f85d eb04 	ldr.w	lr, [sp], #4
 800392a:	b003      	add	sp, #12
 800392c:	4770      	bx	lr
 800392e:	bf00      	nop

08003930 <flashUnlock.part.0>:
  /* Check if unlock is really needed */
  if (!(FLASH->CR & FLASH_CR_LOCK))
    return CH_SUCCESS;

  /* Write magic unlock sequence */
  FLASH->KEYR = 0x45670123;
 8003930:	4b05      	ldr	r3, [pc, #20]	; (8003948 <flashUnlock.part.0+0x18>)
 8003932:	4906      	ldr	r1, [pc, #24]	; (800394c <flashUnlock.part.0+0x1c>)
  FLASH->KEYR = 0xCDEF89AB;
 8003934:	4a06      	ldr	r2, [pc, #24]	; (8003950 <flashUnlock.part.0+0x20>)
  /* Check if unlock is really needed */
  if (!(FLASH->CR & FLASH_CR_LOCK))
    return CH_SUCCESS;

  /* Write magic unlock sequence */
  FLASH->KEYR = 0x45670123;
 8003936:	6059      	str	r1, [r3, #4]
  FLASH->KEYR = 0xCDEF89AB;
 8003938:	605a      	str	r2, [r3, #4]

  if (FLASH->CR & FLASH_CR_LOCK)
 800393a:	6918      	ldr	r0, [r3, #16]
 800393c:	f080 0080 	eor.w	r0, r0, #128	; 0x80
    return CH_FAILED;

  return CH_SUCCESS;
}
 8003940:	f3c0 10c0 	ubfx	r0, r0, #7, #1
 8003944:	4770      	bx	lr
 8003946:	bf00      	nop
 8003948:	40022000 	.word	0x40022000
 800394c:	45670123 	.word	0x45670123
 8003950:	cdef89ab 	.word	0xcdef89ab
	...

08003960 <flashPageErase>:


int flashPageErase(flashpage_t page){

  /* Only write on pages in the user area */
  if (!(FLASH_IS_ADDRESS_USERSPACE(FLASH_ADDRESS_OF_PAGE(page))))
 8003960:	4b22      	ldr	r3, [pc, #136]	; (80039ec <flashPageErase+0x8c>)
static void flashLock(void) {
  FLASH->CR |= FLASH_CR_LOCK;
}


int flashPageErase(flashpage_t page){
 8003962:	b570      	push	{r4, r5, r6, lr}

  /* Only write on pages in the user area */
  if (!(FLASH_IS_ADDRESS_USERSPACE(FLASH_ADDRESS_OF_PAGE(page))))
 8003964:	4403      	add	r3, r0
 8003966:	02de      	lsls	r6, r3, #11
 8003968:	f5b6 5fc0 	cmp.w	r6, #6144	; 0x1800
 800396c:	d23b      	bcs.n	80039e6 <flashPageErase+0x86>
 * @return  CH_SUCCESS  Unlock was successful.
 * @return CH_FAILED    Unlock failed.
 */
static bool_t flashUnlock(void){
  /* Check if unlock is really needed */
  if (!(FLASH->CR & FLASH_CR_LOCK))
 800396e:	4b20      	ldr	r3, [pc, #128]	; (80039f0 <flashPageErase+0x90>)
 8003970:	4604      	mov	r4, r0
 8003972:	691b      	ldr	r3, [r3, #16]
 8003974:	061a      	lsls	r2, r3, #24
 8003976:	d432      	bmi.n	80039de <flashPageErase+0x7e>
  /* Unlock flash for write access */
  if(flashUnlock() == CH_FAILED)
    return FLASH_RETURN_NO_PERMISSION;

  /* Wait for any busy flags. */
  flashWaitWhileBusy();
 8003978:	491d      	ldr	r1, [pc, #116]	; (80039f0 <flashPageErase+0x90>)
 800397a:	68cb      	ldr	r3, [r1, #12]
 800397c:	4a1c      	ldr	r2, [pc, #112]	; (80039f0 <flashPageErase+0x90>)
 800397e:	07db      	lsls	r3, r3, #31
 8003980:	d4fb      	bmi.n	800397a <flashPageErase+0x1a>
  FLASH->CR |= FLASH_CR_PER;
  FLASH->AR = FLASH_ADDRESS_OF_PAGE(page);
  FLASH->CR |= FLASH_CR_STRT;

  /* Wait until it's finished. */
  flashWaitWhileBusy();
 8003982:	4611      	mov	r1, r2

  /* Wait for any busy flags. */
  flashWaitWhileBusy();

  /* Start deletion of page. */
  FLASH->CR |= FLASH_CR_PER;
 8003984:	6913      	ldr	r3, [r2, #16]
  FLASH->AR = FLASH_ADDRESS_OF_PAGE(page);
 8003986:	f106 6500 	add.w	r5, r6, #134217728	; 0x8000000

  /* Wait for any busy flags. */
  flashWaitWhileBusy();

  /* Start deletion of page. */
  FLASH->CR |= FLASH_CR_PER;
 800398a:	f043 0302 	orr.w	r3, r3, #2
  FLASH->AR = FLASH_ADDRESS_OF_PAGE(page);
 800398e:	f505 357a 	add.w	r5, r5, #256000	; 0x3e800

  /* Wait for any busy flags. */
  flashWaitWhileBusy();

  /* Start deletion of page. */
  FLASH->CR |= FLASH_CR_PER;
 8003992:	6113      	str	r3, [r2, #16]
  FLASH->AR = FLASH_ADDRESS_OF_PAGE(page);
 8003994:	6155      	str	r5, [r2, #20]
  FLASH->CR |= FLASH_CR_STRT;
 8003996:	6913      	ldr	r3, [r2, #16]
 8003998:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800399c:	6113      	str	r3, [r2, #16]

  /* Wait until it's finished. */
  flashWaitWhileBusy();
 800399e:	68cb      	ldr	r3, [r1, #12]
 80039a0:	4a13      	ldr	r2, [pc, #76]	; (80039f0 <flashPageErase+0x90>)
 80039a2:	f013 0301 	ands.w	r3, r3, #1
 80039a6:	d1fa      	bne.n	800399e <flashPageErase+0x3e>

  /* Page erase flag does not clear automatically. */
  FLASH->CR &= !FLASH_CR_PER;
 80039a8:	6911      	ldr	r1, [r2, #16]
 80039aa:	6113      	str	r3, [r2, #16]

/**
 * @brief Lock the flash memory for write access.
 */
static void flashLock(void) {
  FLASH->CR |= FLASH_CR_LOCK;
 80039ac:	6913      	ldr	r3, [r2, #16]
  return FLASH_RETURN_SUCCESS;
}

bool_t flashPageCheckErased(flashpage_t page){
  uint32_t* const startAddress = (uint32_t*) FLASH_ADDRESS_OF_PAGE(page);
  uint32_t* const stopAddress = (uint32_t*) FLASH_ADDRESS_OF_PAGE(page+1);
 80039ae:	f104 2008 	add.w	r0, r4, #134219776	; 0x8000800

/**
 * @brief Lock the flash memory for write access.
 */
static void flashLock(void) {
  FLASH->CR |= FLASH_CR_LOCK;
 80039b2:	f043 0380 	orr.w	r3, r3, #128	; 0x80
  uint32_t* const stopAddress = (uint32_t*) FLASH_ADDRESS_OF_PAGE(page+1);

  uint32_t* addr;

  /* Cycle through the whole page and check for default set bits */
  for(addr = startAddress; addr < stopAddress; addr++){
 80039b6:	4285      	cmp	r5, r0

/**
 * @brief Lock the flash memory for write access.
 */
static void flashLock(void) {
  FLASH->CR |= FLASH_CR_LOCK;
 80039b8:	6113      	str	r3, [r2, #16]
  uint32_t* const stopAddress = (uint32_t*) FLASH_ADDRESS_OF_PAGE(page+1);

  uint32_t* addr;

  /* Cycle through the whole page and check for default set bits */
  for(addr = startAddress; addr < stopAddress; addr++){
 80039ba:	d20b      	bcs.n	80039d4 <flashPageErase+0x74>
    if (*addr != 0xffffffff)
 80039bc:	682b      	ldr	r3, [r5, #0]
 80039be:	3301      	adds	r3, #1
 80039c0:	d10a      	bne.n	80039d8 <flashPageErase+0x78>
 80039c2:	4b0c      	ldr	r3, [pc, #48]	; (80039f4 <flashPageErase+0x94>)
 80039c4:	4433      	add	r3, r6
 80039c6:	e003      	b.n	80039d0 <flashPageErase+0x70>
 80039c8:	f853 2b04 	ldr.w	r2, [r3], #4
 80039cc:	3201      	adds	r2, #1
 80039ce:	d103      	bne.n	80039d8 <flashPageErase+0x78>
  uint32_t* const stopAddress = (uint32_t*) FLASH_ADDRESS_OF_PAGE(page+1);

  uint32_t* addr;

  /* Cycle through the whole page and check for default set bits */
  for(addr = startAddress; addr < stopAddress; addr++){
 80039d0:	4298      	cmp	r0, r3
 80039d2:	d8f9      	bhi.n	80039c8 <flashPageErase+0x68>
  /* Check deleted page for errors */
  if(flashPageCheckErased(page) == FALSE)
    return FLASH_RETURN_BADFLASH;  /* Page is not empty despite the erase cycle! */

  /* Successfully deleted page */
  return FLASH_RETURN_SUCCESS;
 80039d4:	2001      	movs	r0, #1
 80039d6:	bd70      	pop	{r4, r5, r6, pc}
  /* Lock flash again */
  flashLock();

  /* Check deleted page for errors */
  if(flashPageCheckErased(page) == FALSE)
    return FLASH_RETURN_BADFLASH;  /* Page is not empty despite the erase cycle! */
 80039d8:	f06f 000a 	mvn.w	r0, #10

  /* Successfully deleted page */
  return FLASH_RETURN_SUCCESS;
}
 80039dc:	bd70      	pop	{r4, r5, r6, pc}
 80039de:	f7ff ffa7 	bl	8003930 <flashUnlock.part.0>
  /* Only write on pages in the user area */
  if (!(FLASH_IS_ADDRESS_USERSPACE(FLASH_ADDRESS_OF_PAGE(page))))
    return FLASH_RETURN_NO_PERMISSION;

  /* Unlock flash for write access */
  if(flashUnlock() == CH_FAILED)
 80039e2:	2800      	cmp	r0, #0
 80039e4:	d1c8      	bne.n	8003978 <flashPageErase+0x18>

int flashPageErase(flashpage_t page){

  /* Only write on pages in the user area */
  if (!(FLASH_IS_ADDRESS_USERSPACE(FLASH_ADDRESS_OF_PAGE(page))))
    return FLASH_RETURN_NO_PERMISSION;
 80039e6:	f04f 30ff 	mov.w	r0, #4294967295
 80039ea:	bd70      	pop	{r4, r5, r6, pc}
 80039ec:	001fff83 	.word	0x001fff83
 80039f0:	40022000 	.word	0x40022000
 80039f4:	0803e804 	.word	0x0803e804
	...

08003a00 <flashWrite>:

	return err;

}
int flashWrite(flashaddr_t src_address, const char* buffer, size_t size)
{
 8003a00:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 * @return  CH_SUCCESS  Unlock was successful.
 * @return CH_FAILED    Unlock failed.
 */
static bool_t flashUnlock(void){
  /* Check if unlock is really needed */
  if (!(FLASH->CR & FLASH_CR_LOCK))
 8003a04:	4b43      	ldr	r3, [pc, #268]	; (8003b14 <flashWrite+0x114>)

	return err;

}
int flashWrite(flashaddr_t src_address, const char* buffer, size_t size)
{
 8003a06:	4614      	mov	r4, r2
 * @return  CH_SUCCESS  Unlock was successful.
 * @return CH_FAILED    Unlock failed.
 */
static bool_t flashUnlock(void){
  /* Check if unlock is really needed */
  if (!(FLASH->CR & FLASH_CR_LOCK))
 8003a08:	691b      	ldr	r3, [r3, #16]

	return err;

}
int flashWrite(flashaddr_t src_address, const char* buffer, size_t size)
{
 8003a0a:	b083      	sub	sp, #12
 * @return  CH_SUCCESS  Unlock was successful.
 * @return CH_FAILED    Unlock failed.
 */
static bool_t flashUnlock(void){
  /* Check if unlock is really needed */
  if (!(FLASH->CR & FLASH_CR_LOCK))
 8003a0c:	061a      	lsls	r2, r3, #24

	return err;

}
int flashWrite(flashaddr_t src_address, const char* buffer, size_t size)
{
 8003a0e:	4680      	mov	r8, r0
 8003a10:	460d      	mov	r5, r1
	volatile flashdata_t* address = src_address;
 8003a12:	4606      	mov	r6, r0
 * @return  CH_SUCCESS  Unlock was successful.
 * @return CH_FAILED    Unlock failed.
 */
static bool_t flashUnlock(void){
  /* Check if unlock is really needed */
  if (!(FLASH->CR & FLASH_CR_LOCK))
 8003a14:	d45f      	bmi.n	8003ad6 <flashWrite+0xd6>
    /* Unlock flash for write access */
    if(flashUnlock() == CH_FAILED)
        return FLASH_RETURN_NO_PERMISSION;

    /* Wait for any busy flags */
    flashWaitWhileBusy();
 8003a16:	4a3f      	ldr	r2, [pc, #252]	; (8003b14 <flashWrite+0x114>)
 8003a18:	68d3      	ldr	r3, [r2, #12]
 8003a1a:	4f3e      	ldr	r7, [pc, #248]	; (8003b14 <flashWrite+0x114>)
 8003a1c:	07db      	lsls	r3, r3, #31
 8003a1e:	d4fb      	bmi.n	8003a18 <flashWrite+0x18>

    /* Check if the flash address is correctly aligned */
    size_t alignOffset = (size_t)address % sizeof(flashdata_t);
    if (alignOffset != 0)
 8003a20:	f018 0f01 	tst.w	r8, #1
 8003a24:	d131      	bne.n	8003a8a <flashWrite+0x8a>


    /* Now, address is correctly aligned. One can copy data directly from
     * buffer's data to flash memory until the size of the data remaining to be
     * copied requires special treatment. */
    while (size >= sizeof(flashdata_t))
 8003a26:	2c01      	cmp	r4, #1
 8003a28:	d924      	bls.n	8003a74 <flashWrite+0x74>
}

static void flashWriteData(volatile flashdata_t* address, const flashdata_t data)
{
    /* Enter flash programming mode */
    FLASH->CR |= FLASH_CR_PG;
 8003a2a:	4a3a      	ldr	r2, [pc, #232]	; (8003b14 <flashWrite+0x114>)


    /* Now, address is correctly aligned. One can copy data directly from
     * buffer's data to flash memory until the size of the data remaining to be
     * copied requires special treatment. */
    while (size >= sizeof(flashdata_t))
 8003a2c:	4630      	mov	r0, r6

    /* Write the data */
    *address = data;

    /* Wait for completion */
    flashWaitWhileBusy();
 8003a2e:	4696      	mov	lr, r2


    /* Now, address is correctly aligned. One can copy data directly from
     * buffer's data to flash memory until the size of the data remaining to be
     * copied requires special treatment. */
    while (size >= sizeof(flashdata_t))
 8003a30:	4621      	mov	r1, r4
 8003a32:	1eaf      	subs	r7, r5, #2
}

static void flashWriteData(volatile flashdata_t* address, const flashdata_t data)
{
    /* Enter flash programming mode */
    FLASH->CR |= FLASH_CR_PG;
 8003a34:	6913      	ldr	r3, [r2, #16]
    /* Now, address is correctly aligned. One can copy data directly from
     * buffer's data to flash memory until the size of the data remaining to be
     * copied requires special treatment. */
    while (size >= sizeof(flashdata_t))
    {
        flashWriteData(address, *(const flashdata_t*)buffer);
 8003a36:	f837 cf02 	ldrh.w	ip, [r7, #2]!
}

static void flashWriteData(volatile flashdata_t* address, const flashdata_t data)
{
    /* Enter flash programming mode */
    FLASH->CR |= FLASH_CR_PG;
 8003a3a:	f043 0301 	orr.w	r3, r3, #1
 8003a3e:	6113      	str	r3, [r2, #16]

    /* Write the data */
    *address = data;
 8003a40:	f8a0 c000 	strh.w	ip, [r0]

    /* Wait for completion */
    flashWaitWhileBusy();
 8003a44:	68d3      	ldr	r3, [r2, #12]
 8003a46:	07db      	lsls	r3, r3, #31
 8003a48:	d4fc      	bmi.n	8003a44 <flashWrite+0x44>

    /* Exit flash programming mode */
    FLASH->CR &= ~FLASH_CR_PG;
 8003a4a:	f8de 3010 	ldr.w	r3, [lr, #16]
    while (size >= sizeof(flashdata_t))
    {
        flashWriteData(address, *(const flashdata_t*)buffer);
        address = (size_t)address + sizeof(flashdata_t);
        buffer += sizeof(flashdata_t);
        size -= sizeof(flashdata_t);
 8003a4e:	3902      	subs	r1, #2

    /* Wait for completion */
    flashWaitWhileBusy();

    /* Exit flash programming mode */
    FLASH->CR &= ~FLASH_CR_PG;
 8003a50:	f023 0301 	bic.w	r3, r3, #1


    /* Now, address is correctly aligned. One can copy data directly from
     * buffer's data to flash memory until the size of the data remaining to be
     * copied requires special treatment. */
    while (size >= sizeof(flashdata_t))
 8003a54:	2901      	cmp	r1, #1
 8003a56:	f100 0002 	add.w	r0, r0, #2

    /* Wait for completion */
    flashWaitWhileBusy();

    /* Exit flash programming mode */
    FLASH->CR &= ~FLASH_CR_PG;
 8003a5a:	f8ce 3010 	str.w	r3, [lr, #16]


    /* Now, address is correctly aligned. One can copy data directly from
     * buffer's data to flash memory until the size of the data remaining to be
     * copied requires special treatment. */
    while (size >= sizeof(flashdata_t))
 8003a5e:	d8e9      	bhi.n	8003a34 <flashWrite+0x34>
 8003a60:	1ea3      	subs	r3, r4, #2
 8003a62:	085b      	lsrs	r3, r3, #1
 8003a64:	3602      	adds	r6, #2
 8003a66:	1c5a      	adds	r2, r3, #1
 8003a68:	eb06 0643 	add.w	r6, r6, r3, lsl #1
 8003a6c:	eb05 0542 	add.w	r5, r5, r2, lsl #1
 8003a70:	f004 0401 	and.w	r4, r4, #1

    /* Now, address is correctly aligned, but the remaining data are to
     * small to fill a entier flashdata_t. Thus, one must read data already
     * in flash and update them with buffer's data before writing an entire
     * flashdata_t to flash memory. */
    if (size > 0)
 8003a74:	2c00      	cmp	r4, #0
 8003a76:	d135      	bne.n	8003ae4 <flashWrite+0xe4>

/**
 * @brief Lock the flash memory for write access.
 */
static void flashLock(void) {
  FLASH->CR |= FLASH_CR_LOCK;
 8003a78:	4a26      	ldr	r2, [pc, #152]	; (8003b14 <flashWrite+0x114>)
    }

    /* Lock flash again */
    flashLock();

    return FLASH_RETURN_SUCCESS;
 8003a7a:	2001      	movs	r0, #1

/**
 * @brief Lock the flash memory for write access.
 */
static void flashLock(void) {
  FLASH->CR |= FLASH_CR_LOCK;
 8003a7c:	6913      	ldr	r3, [r2, #16]
 8003a7e:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8003a82:	6113      	str	r3, [r2, #16]
    /* Lock flash again */
    flashLock();

    return FLASH_RETURN_SUCCESS;

}
 8003a84:	b003      	add	sp, #12
 8003a86:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        /* Read already present data */
        flashdata_t tmp = *(volatile flashdata_t*)alignedFlashAddress;

        /* Compute how much bytes one must update in the data read */
        size_t chunkSize = sizeof(flashdata_t) - alignOffset;
        if (chunkSize > size)
 8003a8a:	f114 0900 	adds.w	r9, r4, #0

        /* Align the flash address correctly */
        flashaddr_t alignedFlashAddress = address - alignOffset;

        /* Read already present data */
        flashdata_t tmp = *(volatile flashdata_t*)alignedFlashAddress;
 8003a8e:	f838 3c02 	ldrh.w	r3, [r8, #-2]

        /* Compute how much bytes one must update in the data read */
        size_t chunkSize = sizeof(flashdata_t) - alignOffset;
        if (chunkSize > size)
 8003a92:	bf18      	it	ne
 8003a94:	f04f 0901 	movne.w	r9, #1
            chunkSize = size; // this happens when both address and address + size are not aligned

        /* Update the read data with buffer's data */
        memcpy((char*)&tmp + alignOffset, buffer, chunkSize);
 8003a98:	464a      	mov	r2, r9
 8003a9a:	4629      	mov	r1, r5
 8003a9c:	f10d 0007 	add.w	r0, sp, #7

        /* Align the flash address correctly */
        flashaddr_t alignedFlashAddress = address - alignOffset;

        /* Read already present data */
        flashdata_t tmp = *(volatile flashdata_t*)alignedFlashAddress;
 8003aa0:	f8ad 3006 	strh.w	r3, [sp, #6]
        size_t chunkSize = sizeof(flashdata_t) - alignOffset;
        if (chunkSize > size)
            chunkSize = size; // this happens when both address and address + size are not aligned

        /* Update the read data with buffer's data */
        memcpy((char*)&tmp + alignOffset, buffer, chunkSize);
 8003aa4:	f7fd fb24 	bl	80010f0 <memcpy>

    /* Write the data */
    *address = data;

    /* Wait for completion */
    flashWaitWhileBusy();
 8003aa8:	4639      	mov	r1, r7
}

static void flashWriteData(volatile flashdata_t* address, const flashdata_t data)
{
    /* Enter flash programming mode */
    FLASH->CR |= FLASH_CR_PG;
 8003aaa:	693b      	ldr	r3, [r7, #16]

        /* Update the read data with buffer's data */
        memcpy((char*)&tmp + alignOffset, buffer, chunkSize);

        /* Write the new data in flash */
        flashWriteData(alignedFlashAddress, tmp);
 8003aac:	f8bd 2006 	ldrh.w	r2, [sp, #6]
}

static void flashWriteData(volatile flashdata_t* address, const flashdata_t data)
{
    /* Enter flash programming mode */
    FLASH->CR |= FLASH_CR_PG;
 8003ab0:	f043 0301 	orr.w	r3, r3, #1
 8003ab4:	613b      	str	r3, [r7, #16]

    /* Write the data */
    *address = data;
 8003ab6:	f828 2c02 	strh.w	r2, [r8, #-2]

    /* Wait for completion */
    flashWaitWhileBusy();
 8003aba:	68cb      	ldr	r3, [r1, #12]
 8003abc:	4a15      	ldr	r2, [pc, #84]	; (8003b14 <flashWrite+0x114>)
 8003abe:	07d8      	lsls	r0, r3, #31
 8003ac0:	d4fb      	bmi.n	8003aba <flashWrite+0xba>

    /* Exit flash programming mode */
    FLASH->CR &= ~FLASH_CR_PG;
 8003ac2:	6913      	ldr	r3, [r2, #16]

        /* Write the new data in flash */
        flashWriteData(alignedFlashAddress, tmp);

        /* Advance */
        address += chunkSize;
 8003ac4:	eb08 0649 	add.w	r6, r8, r9, lsl #1

    /* Wait for completion */
    flashWaitWhileBusy();

    /* Exit flash programming mode */
    FLASH->CR &= ~FLASH_CR_PG;
 8003ac8:	f023 0301 	bic.w	r3, r3, #1
        /* Write the new data in flash */
        flashWriteData(alignedFlashAddress, tmp);

        /* Advance */
        address += chunkSize;
        buffer += chunkSize;
 8003acc:	444d      	add	r5, r9
        size -= chunkSize;
 8003ace:	ebc9 0404 	rsb	r4, r9, r4

    /* Wait for completion */
    flashWaitWhileBusy();

    /* Exit flash programming mode */
    FLASH->CR &= ~FLASH_CR_PG;
 8003ad2:	6113      	str	r3, [r2, #16]
 8003ad4:	e7a7      	b.n	8003a26 <flashWrite+0x26>
 8003ad6:	f7ff ff2b 	bl	8003930 <flashUnlock.part.0>
int flashWrite(flashaddr_t src_address, const char* buffer, size_t size)
{
	volatile flashdata_t* address = src_address;

    /* Unlock flash for write access */
    if(flashUnlock() == CH_FAILED)
 8003ada:	2800      	cmp	r0, #0
 8003adc:	d19b      	bne.n	8003a16 <flashWrite+0x16>
        return FLASH_RETURN_NO_PERMISSION;
 8003ade:	f04f 30ff 	mov.w	r0, #4294967295
 8003ae2:	e7cf      	b.n	8003a84 <flashWrite+0x84>
}

static void flashWriteData(volatile flashdata_t* address, const flashdata_t data)
{
    /* Enter flash programming mode */
    FLASH->CR |= FLASH_CR_PG;
 8003ae4:	4b0b      	ldr	r3, [pc, #44]	; (8003b14 <flashWrite+0x114>)
     * small to fill a entier flashdata_t. Thus, one must read data already
     * in flash and update them with buffer's data before writing an entire
     * flashdata_t to flash memory. */
    if (size > 0)
    {
        flashdata_t tmp = *(volatile flashdata_t*)address;
 8003ae6:	8830      	ldrh	r0, [r6, #0]

    /* Write the data */
    *address = data;

    /* Wait for completion */
    flashWaitWhileBusy();
 8003ae8:	4619      	mov	r1, r3
     * in flash and update them with buffer's data before writing an entire
     * flashdata_t to flash memory. */
    if (size > 0)
    {
        flashdata_t tmp = *(volatile flashdata_t*)address;
        memcpy(&tmp, buffer, size);
 8003aea:	782a      	ldrb	r2, [r5, #0]
     * small to fill a entier flashdata_t. Thus, one must read data already
     * in flash and update them with buffer's data before writing an entire
     * flashdata_t to flash memory. */
    if (size > 0)
    {
        flashdata_t tmp = *(volatile flashdata_t*)address;
 8003aec:	f8ad 0006 	strh.w	r0, [sp, #6]
        memcpy(&tmp, buffer, size);
 8003af0:	f88d 2006 	strb.w	r2, [sp, #6]
}

static void flashWriteData(volatile flashdata_t* address, const flashdata_t data)
{
    /* Enter flash programming mode */
    FLASH->CR |= FLASH_CR_PG;
 8003af4:	691a      	ldr	r2, [r3, #16]
     * flashdata_t to flash memory. */
    if (size > 0)
    {
        flashdata_t tmp = *(volatile flashdata_t*)address;
        memcpy(&tmp, buffer, size);
        flashWriteData(address, tmp);
 8003af6:	f8bd 0006 	ldrh.w	r0, [sp, #6]
}

static void flashWriteData(volatile flashdata_t* address, const flashdata_t data)
{
    /* Enter flash programming mode */
    FLASH->CR |= FLASH_CR_PG;
 8003afa:	f042 0201 	orr.w	r2, r2, #1
 8003afe:	611a      	str	r2, [r3, #16]

    /* Write the data */
    *address = data;
 8003b00:	8030      	strh	r0, [r6, #0]

    /* Wait for completion */
    flashWaitWhileBusy();
 8003b02:	68cb      	ldr	r3, [r1, #12]
 8003b04:	4a03      	ldr	r2, [pc, #12]	; (8003b14 <flashWrite+0x114>)
 8003b06:	07db      	lsls	r3, r3, #31
 8003b08:	d4fb      	bmi.n	8003b02 <flashWrite+0x102>

    /* Exit flash programming mode */
    FLASH->CR &= ~FLASH_CR_PG;
 8003b0a:	6913      	ldr	r3, [r2, #16]
 8003b0c:	f023 0301 	bic.w	r3, r3, #1
 8003b10:	6113      	str	r3, [r2, #16]
 8003b12:	e7b1      	b.n	8003a78 <flashWrite+0x78>
 8003b14:	40022000 	.word	0x40022000
	...

08003b20 <pidUpdateStruct>:
}

/**
 * @brief
 */
static void pidUpdateStruct(void) {
 8003b20:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8003b24:	f8df a05c 	ldr.w	sl, [pc, #92]	; 8003b84 <pidUpdateStruct+0x64>
 8003b28:	f8df 905c 	ldr.w	r9, [pc, #92]	; 8003b88 <pidUpdateStruct+0x68>
 8003b2c:	4656      	mov	r6, sl
 8003b2e:	464d      	mov	r5, r9
 8003b30:	f8df 8058 	ldr.w	r8, [pc, #88]	; 8003b8c <pidUpdateStruct+0x6c>
  for (i = 0; i < 3; i++) {
    PID[i].P = (float)g_pidSettings[i].P*0.1f;
    PID[i].I = (float)g_pidSettings[i].I*0.01f;
    PID[i].D = (float)g_pidSettings[i].D*1.0f;
    if (!g_pidSettings[i].I) {
      g_motorOffset[i] = 0.0f;
 8003b34:	f04f 0b00 	mov.w	fp, #0
}

/**
 * @brief
 */
static void pidUpdateStruct(void) {
 8003b38:	2400      	movs	r4, #0
  uint8_t i;
  for (i = 0; i < 3; i++) {
    PID[i].P = (float)g_pidSettings[i].P*0.1f;
 8003b3a:	f81a 0004 	ldrb.w	r0, [sl, r4]
 8003b3e:	f7fd f88d 	bl	8000c5c <__aeabi_ui2f>
 8003b42:	490e      	ldr	r1, [pc, #56]	; (8003b7c <pidUpdateStruct+0x5c>)
 8003b44:	f7fd f8e4 	bl	8000d10 <__aeabi_fmul>
    PID[i].I = (float)g_pidSettings[i].I*0.01f;
 8003b48:	7877      	ldrb	r7, [r6, #1]
 * @brief
 */
static void pidUpdateStruct(void) {
  uint8_t i;
  for (i = 0; i < 3; i++) {
    PID[i].P = (float)g_pidSettings[i].P*0.1f;
 8003b4a:	f849 0034 	str.w	r0, [r9, r4, lsl #3]
    PID[i].I = (float)g_pidSettings[i].I*0.01f;
 8003b4e:	4638      	mov	r0, r7
 8003b50:	f7fd f884 	bl	8000c5c <__aeabi_ui2f>
 8003b54:	490a      	ldr	r1, [pc, #40]	; (8003b80 <pidUpdateStruct+0x60>)
 8003b56:	f7fd f8db 	bl	8000d10 <__aeabi_fmul>
 8003b5a:	6068      	str	r0, [r5, #4]
    PID[i].D = (float)g_pidSettings[i].D*1.0f;
 8003b5c:	78b0      	ldrb	r0, [r6, #2]
 8003b5e:	f7fd f87d 	bl	8000c5c <__aeabi_ui2f>
 8003b62:	3403      	adds	r4, #3
 8003b64:	60a8      	str	r0, [r5, #8]
 8003b66:	3603      	adds	r6, #3
 8003b68:	3518      	adds	r5, #24
    if (!g_pidSettings[i].I) {
 8003b6a:	b90f      	cbnz	r7, 8003b70 <pidUpdateStruct+0x50>
      g_motorOffset[i] = 0.0f;
 8003b6c:	f8c8 b000 	str.w	fp, [r8]
/**
 * @brief
 */
static void pidUpdateStruct(void) {
  uint8_t i;
  for (i = 0; i < 3; i++) {
 8003b70:	2c09      	cmp	r4, #9
 8003b72:	f108 0804 	add.w	r8, r8, #4
 8003b76:	d1e0      	bne.n	8003b3a <pidUpdateStruct+0x1a>
    PID[i].D = (float)g_pidSettings[i].D*1.0f;
    if (!g_pidSettings[i].I) {
      g_motorOffset[i] = 0.0f;
    }
  }
}
 8003b78:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8003b7c:	3dcccccd 	.word	0x3dcccccd
 8003b80:	3c23d70a 	.word	0x3c23d70a
 8003b84:	2000082c 	.word	0x2000082c
 8003b88:	20000d78 	.word	0x20000d78
 8003b8c:	20000dc0 	.word	0x20000dc0

08003b90 <pidSettingsUpdate>:
}

/**
 * @brief
 */
void pidSettingsUpdate(const PPIDSettings pNewSettings) {
 8003b90:	4602      	mov	r2, r0
  memcpy((void *)&g_pidSettings, (void *)pNewSettings, sizeof(g_pidSettings));
 8003b92:	4b04      	ldr	r3, [pc, #16]	; (8003ba4 <pidSettingsUpdate+0x14>)
 8003b94:	6851      	ldr	r1, [r2, #4]
 8003b96:	6800      	ldr	r0, [r0, #0]
 8003b98:	c303      	stmia	r3!, {r0, r1}
 8003b9a:	7a12      	ldrb	r2, [r2, #8]
 8003b9c:	701a      	strb	r2, [r3, #0]
  pidUpdateStruct();
 8003b9e:	f7ff bfbf 	b.w	8003b20 <pidUpdateStruct>
 8003ba2:	bf00      	nop
 8003ba4:	2000082c 	.word	0x2000082c
	...

08003bb0 <inputModeSettingsUpdate>:
}

/**
 * @brief
 */
void inputModeSettingsUpdate(const PInputModeStruct pNewSettings) {
 8003bb0:	b430      	push	{r4, r5}
 8003bb2:	4605      	mov	r5, r0
  memcpy((void *)&g_modeSettings, (void *)pNewSettings, sizeof(g_modeSettings));
 8003bb4:	4c05      	ldr	r4, [pc, #20]	; (8003bcc <inputModeSettingsUpdate+0x1c>)
 8003bb6:	6869      	ldr	r1, [r5, #4]
 8003bb8:	6800      	ldr	r0, [r0, #0]
 8003bba:	68aa      	ldr	r2, [r5, #8]
 8003bbc:	68eb      	ldr	r3, [r5, #12]
 8003bbe:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8003bc0:	6928      	ldr	r0, [r5, #16]
 8003bc2:	6969      	ldr	r1, [r5, #20]
 8003bc4:	c403      	stmia	r4!, {r0, r1}
}
 8003bc6:	bc30      	pop	{r4, r5}
 8003bc8:	4770      	bx	lr
 8003bca:	bf00      	nop
 8003bcc:	2000083c 	.word	0x2000083c

08003bd0 <cfSettingsUpdate>:

/**
 * @brief
 */
void cfSettingsUpdate(const uint16_t *pNewSettings) {
 8003bd0:	b538      	push	{r3, r4, r5, lr}
  memcpy((void *)&g_cfSettings, (void *)pNewSettings, sizeof(g_cfSettings));
 8003bd2:	4c0a      	ldr	r4, [pc, #40]	; (8003bfc <cfSettingsUpdate+0x2c>)
 8003bd4:	6800      	ldr	r0, [r0, #0]

/**
 * @brief
 */
static void cfUpdateSettings(void) {
  accel2Kp = g_cfSettings[0] * 0.1f;
 8003bd6:	4d0a      	ldr	r5, [pc, #40]	; (8003c00 <cfSettingsUpdate+0x30>)

/**
 * @brief
 */
void cfSettingsUpdate(const uint16_t *pNewSettings) {
  memcpy((void *)&g_cfSettings, (void *)pNewSettings, sizeof(g_cfSettings));
 8003bd8:	6020      	str	r0, [r4, #0]

/**
 * @brief
 */
static void cfUpdateSettings(void) {
  accel2Kp = g_cfSettings[0] * 0.1f;
 8003bda:	8820      	ldrh	r0, [r4, #0]
 8003bdc:	f7fd f842 	bl	8000c64 <__aeabi_i2f>
 8003be0:	4908      	ldr	r1, [pc, #32]	; (8003c04 <cfSettingsUpdate+0x34>)
 8003be2:	f7fd f895 	bl	8000d10 <__aeabi_fmul>
 8003be6:	6028      	str	r0, [r5, #0]
  accel2Ki = g_cfSettings[1] * 0.00001f;
 8003be8:	8860      	ldrh	r0, [r4, #2]
 8003bea:	f7fd f83b 	bl	8000c64 <__aeabi_i2f>
 8003bee:	4906      	ldr	r1, [pc, #24]	; (8003c08 <cfSettingsUpdate+0x38>)
 8003bf0:	f7fd f88e 	bl	8000d10 <__aeabi_fmul>
 8003bf4:	4b05      	ldr	r3, [pc, #20]	; (8003c0c <cfSettingsUpdate+0x3c>)
 8003bf6:	6018      	str	r0, [r3, #0]
 8003bf8:	bd38      	pop	{r3, r4, r5, pc}
 8003bfa:	bf00      	nop
 8003bfc:	20000828 	.word	0x20000828
 8003c00:	20000824 	.word	0x20000824
 8003c04:	3dcccccd 	.word	0x3dcccccd
 8003c08:	3727c5ac 	.word	0x3727c5ac
 8003c0c:	20000838 	.word	0x20000838

08003c10 <BlinkerThread_A>:

/**
 * Green LED blinker thread. Times are in milliseconds.
 */
static THD_WORKING_AREA(waBlinkerThread_A, 64);
static THD_FUNCTION(BlinkerThread_A,arg) {
 8003c10:	b510      	push	{r4, lr}
    } else {
      time = serusbcfg.usbp->state == USB_ACTIVE ? 250 : 500;
    }
#endif
    time = 1000;//ms
    palToggleLedGreen();
 8003c12:	4c05      	ldr	r4, [pc, #20]	; (8003c28 <BlinkerThread_A+0x18>)
 8003c14:	68e3      	ldr	r3, [r4, #12]
    //chnWriteTimeout(&SDU1, (uint8_t *)&constHexToSend, 1, TIME_INFINITE);
    //chnWriteTimeout(&SDU1, (uint8_t *)&constHexToSend, 1, TIME_IMMEDIATE);
    //chnWriteTimeout(&SDU1, (uint8_t *)"i\r\n", 3, TIME_IMMEDIATE);
    //chnWriteTimeout(&SD4, (uint8_t *)"i\r\n", 3, TIME_IMMEDIATE);
    
    chThdSleepMilliseconds(time);
 8003c16:	f44f 60fa 	mov.w	r0, #2000	; 0x7d0
    } else {
      time = serusbcfg.usbp->state == USB_ACTIVE ? 250 : 500;
    }
#endif
    time = 1000;//ms
    palToggleLedGreen();
 8003c1a:	f483 5380 	eor.w	r3, r3, #4096	; 0x1000
 8003c1e:	60e3      	str	r3, [r4, #12]
    //chnWriteTimeout(&SDU1, (uint8_t *)&constHexToSend, 1, TIME_INFINITE);
    //chnWriteTimeout(&SDU1, (uint8_t *)&constHexToSend, 1, TIME_IMMEDIATE);
    //chnWriteTimeout(&SDU1, (uint8_t *)"i\r\n", 3, TIME_IMMEDIATE);
    //chnWriteTimeout(&SD4, (uint8_t *)"i\r\n", 3, TIME_IMMEDIATE);
    
    chThdSleepMilliseconds(time);
 8003c20:	f7fd fd36 	bl	8001690 <chThdSleep>
  }
 8003c24:	e7f6      	b.n	8003c14 <BlinkerThread_A+0x4>
 8003c26:	bf00      	nop
 8003c28:	40010c00 	.word	0x40010c00
 8003c2c:	00000000 	.word	0x00000000

08003c30 <BlinkerThread_B>:

/**
 * Red LED blinker thread. Times are in milliseconds.
 */
static THD_WORKING_AREA(waBlinkerThread_B, 64);
static THD_FUNCTION(BlinkerThread_B,arg) {
 8003c30:	b570      	push	{r4, r5, r6, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8003c32:	4e0b      	ldr	r6, [pc, #44]	; (8003c60 <BlinkerThread_B+0x30>)
 *
 * @xclass
 */
static inline bool chThdShouldTerminateX(void) {

  return (bool)((chThdGetSelfX()->p_flags & CH_FLAG_TERMINATE) != (tmode_t)0);
 8003c34:	6933      	ldr	r3, [r6, #16]
 8003c36:	7c5b      	ldrb	r3, [r3, #17]
  (void)arg;
  systime_t time = 20;
  time = 2000; //ms
  while (!chThdShouldTerminateX()) {
 8003c38:	075a      	lsls	r2, r3, #29
 8003c3a:	d40c      	bmi.n	8003c56 <BlinkerThread_B+0x26>
    if (led_b) {
    	palToggleLedRed();

    }
    else {
    	palToggleLedRed();
 8003c3c:	4c09      	ldr	r4, [pc, #36]	; (8003c64 <BlinkerThread_B+0x34>)
 8003c3e:	68e3      	ldr	r3, [r4, #12]
    }
    chThdSleepMilliseconds(time);
 8003c40:	f44f 607a 	mov.w	r0, #4000	; 0xfa0
    if (led_b) {
    	palToggleLedRed();

    }
    else {
    	palToggleLedRed();
 8003c44:	f483 5300 	eor.w	r3, r3, #8192	; 0x2000
 8003c48:	60e3      	str	r3, [r4, #12]
    }
    chThdSleepMilliseconds(time);
 8003c4a:	f7fd fd21 	bl	8001690 <chThdSleep>
 8003c4e:	6933      	ldr	r3, [r6, #16]
 8003c50:	7c5b      	ldrb	r3, [r3, #17]
static THD_WORKING_AREA(waBlinkerThread_B, 64);
static THD_FUNCTION(BlinkerThread_B,arg) {
  (void)arg;
  systime_t time = 20;
  time = 2000; //ms
  while (!chThdShouldTerminateX()) {
 8003c52:	075b      	lsls	r3, r3, #29
 8003c54:	d5f3      	bpl.n	8003c3e <BlinkerThread_B+0xe>
    	palToggleLedRed();
    }
    chThdSleepMilliseconds(time);
  }
  /* This point may be reached if shut down is requested. */
  chThdExit(MSG_OK);
 8003c56:	2000      	movs	r0, #0
}
 8003c58:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    	palToggleLedRed();
    }
    chThdSleepMilliseconds(time);
  }
  /* This point may be reached if shut down is requested. */
  chThdExit(MSG_OK);
 8003c5c:	f7fd bd40 	b.w	80016e0 <chThdExit>
 8003c60:	200008f0 	.word	0x200008f0
 8003c64:	40010c00 	.word	0x40010c00
	...

08003c70 <main>:

/**
 * @brief   Application entry point.
 * @details
 */
int main(void) {
 8003c70:	b530      	push	{r4, r5, lr}

    shellInit();

#endif
  
    sdStart(&SD4, NULL);
 8003c72:	4c18      	ldr	r4, [pc, #96]	; (8003cd4 <main+0x64>)

/**
 * @brief   Application entry point.
 * @details
 */
int main(void) {
 8003c74:	b083      	sub	sp, #12
   * - HAL initialization, this also initializes the configured device drivers
   *   and performs the board-specific initializations.
   * - Kernel initialization, the main() function becomes a thread and the
   *   RTOS is active.
   */
  halInit();
 8003c76:	f7fd ffb3 	bl	8001be0 <halInit>
  osalInit();
  chSysInit();
 8003c7a:	f7fd fb01 	bl	8001280 <chSysInit>

    shellInit();

#endif
  
    sdStart(&SD4, NULL);
 8003c7e:	4620      	mov	r0, r4
 8003c80:	2100      	movs	r1, #0
 8003c82:	f7fe f86d 	bl	8001d60 <sdStart>

  /* Activates the USB driver and then the USB bus pull-up on D+.
   * Note, a delay is inserted in order to not have to disconnect the cable
   * after a reset.
   */
    rccEnableAHB(RCC_AHBENR_CRCEN,FALSE);
 8003c86:	4a14      	ldr	r2, [pc, #80]	; (8003cd8 <main+0x68>)
  }
#endif
  
  // na chwile to zakomentowuje, dopoki problem z USB
  // g_chnp = (BaseChannel *)&SDU1; //Default to USB for GUI
  chprintf((BaseSequentialStream *)&SD4, "wo1\n");
 8003c88:	4914      	ldr	r1, [pc, #80]	; (8003cdc <main+0x6c>)

  /* Activates the USB driver and then the USB bus pull-up on D+.
   * Note, a delay is inserted in order to not have to disconnect the cable
   * after a reset.
   */
    rccEnableAHB(RCC_AHBENR_CRCEN,FALSE);
 8003c8a:	6953      	ldr	r3, [r2, #20]
  }
#endif
  
  // na chwile to zakomentowuje, dopoki problem z USB
  // g_chnp = (BaseChannel *)&SDU1; //Default to USB for GUI
  chprintf((BaseSequentialStream *)&SD4, "wo1\n");
 8003c8c:	4620      	mov	r0, r4

  /* Activates the USB driver and then the USB bus pull-up on D+.
   * Note, a delay is inserted in order to not have to disconnect the cable
   * after a reset.
   */
    rccEnableAHB(RCC_AHBENR_CRCEN,FALSE);
 8003c8e:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8003c92:	6153      	str	r3, [r2, #20]
  }
#endif
  
  // na chwile to zakomentowuje, dopoki problem z USB
  // g_chnp = (BaseChannel *)&SDU1; //Default to USB for GUI
  chprintf((BaseSequentialStream *)&SD4, "wo1\n");
 8003c94:	f7ff fe3c 	bl	8003910 <chprintf>
  g_chnp = (BaseChannel *)&SD4; //Default to USB for GUI
 8003c98:	4b11      	ldr	r3, [pc, #68]	; (8003ce0 <main+0x70>)
  chprintf((BaseSequentialStream *)&SD4, "wo2\n");
 8003c9a:	4912      	ldr	r1, [pc, #72]	; (8003ce4 <main+0x74>)
  /* Creates the blinker threads. */
  // green led

  //pwmOutputStart();

  tpBlinker_A = chThdCreateStatic(waBlinkerThread_A, sizeof(waBlinkerThread_A),
 8003c9c:	2500      	movs	r5, #0
  
  // na chwile to zakomentowuje, dopoki problem z USB
  // g_chnp = (BaseChannel *)&SDU1; //Default to USB for GUI
  chprintf((BaseSequentialStream *)&SD4, "wo1\n");
  g_chnp = (BaseChannel *)&SD4; //Default to USB for GUI
  chprintf((BaseSequentialStream *)&SD4, "wo2\n");
 8003c9e:	4620      	mov	r0, r4
#endif
  
  // na chwile to zakomentowuje, dopoki problem z USB
  // g_chnp = (BaseChannel *)&SDU1; //Default to USB for GUI
  chprintf((BaseSequentialStream *)&SD4, "wo1\n");
  g_chnp = (BaseChannel *)&SD4; //Default to USB for GUI
 8003ca0:	601c      	str	r4, [r3, #0]
  chprintf((BaseSequentialStream *)&SD4, "wo2\n");
 8003ca2:	f7ff fe35 	bl	8003910 <chprintf>
  /* Creates the blinker threads. */
  // green led

  //pwmOutputStart();

  tpBlinker_A = chThdCreateStatic(waBlinkerThread_A, sizeof(waBlinkerThread_A),
 8003ca6:	f44f 7180 	mov.w	r1, #256	; 0x100
 8003caa:	2202      	movs	r2, #2
 8003cac:	4b0e      	ldr	r3, [pc, #56]	; (8003ce8 <main+0x78>)
 8003cae:	9500      	str	r5, [sp, #0]
 8003cb0:	480e      	ldr	r0, [pc, #56]	; (8003cec <main+0x7c>)
 8003cb2:	f7fd fcb5 	bl	8001620 <chThdCreateStatic>
    LOWPRIO, BlinkerThread_A, NULL);

  //palClearPad(GPIOB, GPIOB_LED_0);

  // red led
  tpBlinker_B = chThdCreateStatic(waBlinkerThread_B, sizeof(waBlinkerThread_B),
 8003cb6:	9500      	str	r5, [sp, #0]
 8003cb8:	480d      	ldr	r0, [pc, #52]	; (8003cf0 <main+0x80>)
 8003cba:	f44f 7180 	mov.w	r1, #256	; 0x100
 8003cbe:	2202      	movs	r2, #2
 8003cc0:	4b0c      	ldr	r3, [pc, #48]	; (8003cf4 <main+0x84>)
 8003cc2:	f7fd fcad 	bl	8001620 <chThdCreateStatic>
	  //chThdSleepMilliseconds(TELEMETRY_SLEEP_MS); //
	  //chThdSleepMilliseconds(70); //
	  //chThdSleepMilliseconds(140); //
	  // 0 - does not work
	  //chThdSleepMilliseconds(120);
	  chThdSleepMilliseconds(200); // the best so far
 8003cc6:	f44f 70c8 	mov.w	r0, #400	; 0x190
 8003cca:	f7fd fce1 	bl	8001690 <chThdSleep>
	  //chThdSleepMilliseconds(230); //
	  //chThdSleepMilliseconds(1790);
	  //chThdSleepMilliseconds(20); //
	  telemetryReadSerialData();
 8003cce:	f000 f89f 	bl	8003e10 <telemetryReadSerialData>
      chThdRelease(shelltp);    /* Recovers memory of the previous shell.   */
      shelltp = NULL;           /* Triggers spawning of a new shell.        */
    }
    //chThdSleepMilliseconds(6000);
#endif
  }
 8003cd2:	e7f8      	b.n	8003cc6 <main+0x56>
 8003cd4:	20000b74 	.word	0x20000b74
 8003cd8:	40021000 	.word	0x40021000
 8003cdc:	080048e0 	.word	0x080048e0
 8003ce0:	200010d8 	.word	0x200010d8
 8003ce4:	080048e8 	.word	0x080048e8
 8003ce8:	08003c11 	.word	0x08003c11
 8003cec:	20000ee0 	.word	0x20000ee0
 8003cf0:	20000de0 	.word	0x20000de0
 8003cf4:	08003c31 	.word	0x08003c31
	...

08003d00 <imuCalibrationSet>:

/**
 * @brief
 */
void imuCalibrationSet(uint8_t flags) {
  g_boardStatus |= flags & IMU_CALIBRATION_MASK;
 8003d00:	4a03      	ldr	r2, [pc, #12]	; (8003d10 <imuCalibrationSet+0x10>)
 8003d02:	f000 0078 	and.w	r0, r0, #120	; 0x78
 8003d06:	6813      	ldr	r3, [r2, #0]
 8003d08:	4303      	orrs	r3, r0
 8003d0a:	6013      	str	r3, [r2, #0]
 8003d0c:	4770      	bx	lr
 8003d0e:	bf00      	nop
 8003d10:	20000dd0 	.word	0x20000dd0
	...

08003d20 <sensorSettingsUpdate>:
}

/**
 * @brief
 */
void sensorSettingsUpdate(const uint8_t *pNewSettings) {
 8003d20:	b430      	push	{r4, r5}
  uint8_t i;
  memcpy((void *)g_sensorSettings, (void *)pNewSettings, sizeof(g_sensorSettings));
 8003d22:	4b0b      	ldr	r3, [pc, #44]	; (8003d50 <sensorSettingsUpdate+0x30>)
 8003d24:	8802      	ldrh	r2, [r0, #0]
 8003d26:	7884      	ldrb	r4, [r0, #2]
 8003d28:	801a      	strh	r2, [r3, #0]
  for (i = 0; i < 3; i++) {
    g_IMU1.axes_conf[i] = g_sensorSettings[i] & IMU1_CONF_MASK;
 8003d2a:	7818      	ldrb	r0, [r3, #0]
 8003d2c:	7859      	ldrb	r1, [r3, #1]
 8003d2e:	4a09      	ldr	r2, [pc, #36]	; (8003d54 <sensorSettingsUpdate+0x34>)
 8003d30:	f004 050f 	and.w	r5, r4, #15
 8003d34:	f000 000f 	and.w	r0, r0, #15
 8003d38:	f001 010f 	and.w	r1, r1, #15
/**
 * @brief
 */
void sensorSettingsUpdate(const uint8_t *pNewSettings) {
  uint8_t i;
  memcpy((void *)g_sensorSettings, (void *)pNewSettings, sizeof(g_sensorSettings));
 8003d3c:	709c      	strb	r4, [r3, #2]
  for (i = 0; i < 3; i++) {
    g_IMU1.axes_conf[i] = g_sensorSettings[i] & IMU1_CONF_MASK;
 8003d3e:	f882 506a 	strb.w	r5, [r2, #106]	; 0x6a
 8003d42:	f882 0068 	strb.w	r0, [r2, #104]	; 0x68
 8003d46:	f882 1069 	strb.w	r1, [r2, #105]	; 0x69
  }
}
 8003d4a:	bc30      	pop	{r4, r5}
 8003d4c:	4770      	bx	lr
 8003d4e:	bf00      	nop
 8003d50:	20000858 	.word	0x20000858
 8003d54:	20000fe4 	.word	0x20000fe4
	...

08003d60 <telemetryGetCRC32Checksum>:
 * @brief  Calculates CRC32 checksum of received data buffer.
 * @param  pMsg - pointer to telemetry message structure.
 * @return CRC32 checksum of received zero-padded data buffer.
 */
static uint32_t telemetryGetCRC32Checksum(const PMessage pMsg) {
  uint32_t crc_length = (pMsg->size - TELEMETRY_MSG_CRC_SIZE) / sizeof(uint32_t);
 8003d60:	7883      	ldrb	r3, [r0, #2]
 * @retval 32-bit CRC
 */
static inline uint32_t crcCRC32(const uint32_t pBuf[], uint32_t length) {
  uint32_t i;
  /* Resets CRC generator. */
  CRC->CR = CRC_CR_RESET;
 8003d62:	2101      	movs	r1, #1
 8003d64:	1f1a      	subs	r2, r3, #4
  if ((pMsg->size - TELEMETRY_MSG_CRC_SIZE) % sizeof(uint32_t)) {
 8003d66:	f013 0f03 	tst.w	r3, #3
 * @brief  Calculates CRC32 checksum of received data buffer.
 * @param  pMsg - pointer to telemetry message structure.
 * @return CRC32 checksum of received zero-padded data buffer.
 */
static uint32_t telemetryGetCRC32Checksum(const PMessage pMsg) {
  uint32_t crc_length = (pMsg->size - TELEMETRY_MSG_CRC_SIZE) / sizeof(uint32_t);
 8003d6a:	ea4f 0292 	mov.w	r2, r2, lsr #2
 8003d6e:	4b09      	ldr	r3, [pc, #36]	; (8003d94 <telemetryGetCRC32Checksum+0x34>)
  if ((pMsg->size - TELEMETRY_MSG_CRC_SIZE) % sizeof(uint32_t)) {
 8003d70:	d00c      	beq.n	8003d8c <telemetryGetCRC32Checksum+0x2c>
    crc_length++;
 8003d72:	440a      	add	r2, r1
 8003d74:	6099      	str	r1, [r3, #8]
  /* Calculates CRC32 checksum. */
  for(i = 0; i < length; i++) {
    CRC->DR = pBuf[i];
 8003d76:	4907      	ldr	r1, [pc, #28]	; (8003d94 <telemetryGetCRC32Checksum+0x34>)
 8003d78:	eb00 0282 	add.w	r2, r0, r2, lsl #2
 8003d7c:	f850 3b04 	ldr.w	r3, [r0], #4
static inline uint32_t crcCRC32(const uint32_t pBuf[], uint32_t length) {
  uint32_t i;
  /* Resets CRC generator. */
  CRC->CR = CRC_CR_RESET;
  /* Calculates CRC32 checksum. */
  for(i = 0; i < length; i++) {
 8003d80:	4290      	cmp	r0, r2
    CRC->DR = pBuf[i];
 8003d82:	600b      	str	r3, [r1, #0]
static inline uint32_t crcCRC32(const uint32_t pBuf[], uint32_t length) {
  uint32_t i;
  /* Resets CRC generator. */
  CRC->CR = CRC_CR_RESET;
  /* Calculates CRC32 checksum. */
  for(i = 0; i < length; i++) {
 8003d84:	d1fa      	bne.n	8003d7c <telemetryGetCRC32Checksum+0x1c>
    CRC->DR = pBuf[i];
  }
  return CRC->DR;
 8003d86:	4b03      	ldr	r3, [pc, #12]	; (8003d94 <telemetryGetCRC32Checksum+0x34>)
 8003d88:	6818      	ldr	r0, [r3, #0]
  }
  return crcCRC32((const uint32_t *)pMsg, crc_length);
}
 8003d8a:	4770      	bx	lr
 * @retval 32-bit CRC
 */
static inline uint32_t crcCRC32(const uint32_t pBuf[], uint32_t length) {
  uint32_t i;
  /* Resets CRC generator. */
  CRC->CR = CRC_CR_RESET;
 8003d8c:	6099      	str	r1, [r3, #8]
  /* Calculates CRC32 checksum. */
  for(i = 0; i < length; i++) {
 8003d8e:	2a00      	cmp	r2, #0
 8003d90:	d1f1      	bne.n	8003d76 <telemetryGetCRC32Checksum+0x16>
 8003d92:	e7f8      	b.n	8003d86 <telemetryGetCRC32Checksum+0x26>
 8003d94:	40023000 	.word	0x40023000
	...

08003da0 <telemetrySendSerialData>:
/**
 * @brief  Sends data to selected serial port.
 * @param  pMsg - pointer to telemetry message structure to be sent.
 * @return none.
 */
static void telemetrySendSerialData(const PMessage pMsg) {
 8003da0:	b570      	push	{r4, r5, r6, lr}
 8003da2:	4604      	mov	r4, r0
  /* Sends message header and actual data if any. */
  chnWrite(g_chnp, (const uint8_t *)pMsg, pMsg->size - TELEMETRY_MSG_CRC_SIZE);
 8003da4:	4d08      	ldr	r5, [pc, #32]	; (8003dc8 <telemetrySendSerialData+0x28>)
 8003da6:	7882      	ldrb	r2, [r0, #2]
 8003da8:	6828      	ldr	r0, [r5, #0]
 8003daa:	4621      	mov	r1, r4
 8003dac:	6803      	ldr	r3, [r0, #0]
 8003dae:	3a04      	subs	r2, #4
 8003db0:	681b      	ldr	r3, [r3, #0]
 8003db2:	4798      	blx	r3
  /* Sends cyclic redundancy checksum. */
  chnWrite(g_chnp, (const uint8_t *)&pMsg->crc, TELEMETRY_MSG_CRC_SIZE);
 8003db4:	6828      	ldr	r0, [r5, #0]
 8003db6:	f104 0184 	add.w	r1, r4, #132	; 0x84
 8003dba:	6803      	ldr	r3, [r0, #0]
 8003dbc:	2204      	movs	r2, #4
 8003dbe:	681b      	ldr	r3, [r3, #0]
  //chnWrite(g_chnp, "024501980", 9);  
}
 8003dc0:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
 */
static void telemetrySendSerialData(const PMessage pMsg) {
  /* Sends message header and actual data if any. */
  chnWrite(g_chnp, (const uint8_t *)pMsg, pMsg->size - TELEMETRY_MSG_CRC_SIZE);
  /* Sends cyclic redundancy checksum. */
  chnWrite(g_chnp, (const uint8_t *)&pMsg->crc, TELEMETRY_MSG_CRC_SIZE);
 8003dc4:	4718      	bx	r3
 8003dc6:	bf00      	nop
 8003dc8:	200010d8 	.word	0x200010d8
 8003dcc:	00000000 	.word	0x00000000

08003dd0 <telemetryNegativeResponse.constprop.1>:
/**
 * @brief  Prepares negative telemetry response.
 * @param  pMsg - pointer to telemetry message structure.
 * @return none.
 */
static void telemetryNegativeResponse(const PMessage pMsg) {
 8003dd0:	b510      	push	{r4, lr}
  memcpy((void *)pMsg->data, (void *)TELEMETRY_RESP_FAIL, sizeof(TELEMETRY_RESP_FAIL) - 1);
 8003dd2:	4a05      	ldr	r2, [pc, #20]	; (8003de8 <telemetryNegativeResponse.constprop.1+0x18>)
 8003dd4:	4c05      	ldr	r4, [pc, #20]	; (8003dec <telemetryNegativeResponse.constprop.1+0x1c>)
  pMsg->size = sizeof(TELEMETRY_RESP_FAIL) + TELEMETRY_MSG_SVC_SIZE - 1;
 8003dd6:	230c      	movs	r3, #12
  pMsg->crc  = telemetryGetCRC32Checksum(pMsg);
 8003dd8:	4620      	mov	r0, r4
 * @brief  Prepares negative telemetry response.
 * @param  pMsg - pointer to telemetry message structure.
 * @return none.
 */
static void telemetryNegativeResponse(const PMessage pMsg) {
  memcpy((void *)pMsg->data, (void *)TELEMETRY_RESP_FAIL, sizeof(TELEMETRY_RESP_FAIL) - 1);
 8003dda:	6062      	str	r2, [r4, #4]
  pMsg->size = sizeof(TELEMETRY_RESP_FAIL) + TELEMETRY_MSG_SVC_SIZE - 1;
 8003ddc:	70a3      	strb	r3, [r4, #2]
  pMsg->crc  = telemetryGetCRC32Checksum(pMsg);
 8003dde:	f7ff ffbf 	bl	8003d60 <telemetryGetCRC32Checksum>
 8003de2:	f8c4 0084 	str.w	r0, [r4, #132]	; 0x84
 8003de6:	bd10      	pop	{r4, pc}
 8003de8:	4c494146 	.word	0x4c494146
 8003dec:	2000085c 	.word	0x2000085c

08003df0 <telemetryPositiveResponse.constprop.2>:
/**
 * @brief  Prepares positive telemetry response.
 * @param  pMsg - pointer to telemetry message structure.
 * @return none.
 */
static void telemetryPositiveResponse(const PMessage pMsg) {
 8003df0:	b510      	push	{r4, lr}
  memcpy((void *)pMsg->data, (void *)TELEMETRY_RESP_OK, sizeof(TELEMETRY_RESP_OK) - 1);
 8003df2:	4a05      	ldr	r2, [pc, #20]	; (8003e08 <telemetryPositiveResponse.constprop.2+0x18>)
 8003df4:	4c05      	ldr	r4, [pc, #20]	; (8003e0c <telemetryPositiveResponse.constprop.2+0x1c>)
  pMsg->size = sizeof(TELEMETRY_RESP_OK) + TELEMETRY_MSG_SVC_SIZE - 1;
 8003df6:	230c      	movs	r3, #12
  pMsg->crc  = telemetryGetCRC32Checksum(pMsg);
 8003df8:	4620      	mov	r0, r4
 * @brief  Prepares positive telemetry response.
 * @param  pMsg - pointer to telemetry message structure.
 * @return none.
 */
static void telemetryPositiveResponse(const PMessage pMsg) {
  memcpy((void *)pMsg->data, (void *)TELEMETRY_RESP_OK, sizeof(TELEMETRY_RESP_OK) - 1);
 8003dfa:	6062      	str	r2, [r4, #4]
  pMsg->size = sizeof(TELEMETRY_RESP_OK) + TELEMETRY_MSG_SVC_SIZE - 1;
 8003dfc:	70a3      	strb	r3, [r4, #2]
  pMsg->crc  = telemetryGetCRC32Checksum(pMsg);
 8003dfe:	f7ff ffaf 	bl	8003d60 <telemetryGetCRC32Checksum>
 8003e02:	f8c4 0084 	str.w	r0, [r4, #132]	; 0x84
 8003e06:	bd10      	pop	{r4, pc}
 8003e08:	5f4b4f5f 	.word	0x5f4b4f5f
 8003e0c:	2000085c 	.word	0x2000085c

08003e10 <telemetryReadSerialData>:

/**
 * @brief  Process messages received from generic serial interface driver.
 * @return none.
 */
void telemetryReadSerialData(void) {
 8003e10:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	volatile int readSoFar = 0;
 8003e14:	2300      	movs	r3, #0

/**
 * @brief  Process messages received from generic serial interface driver.
 * @return none.
 */
void telemetryReadSerialData(void) {
 8003e16:	b085      	sub	sp, #20
	volatile int readSoFar = 0;
 8003e18:	9302      	str	r3, [sp, #8]
 8003e1a:	2220      	movs	r2, #32
 8003e1c:	f382 8811 	msr	BASEPRI, r2
  osalSysLock();
  /* The following function must be called from within a system lock zone. */
  size_t bytesAvailable = chIQGetFullI(&((SerialDriver *)g_chnp)->iqueue);
 8003e20:	4ab4      	ldr	r2, [pc, #720]	; (80040f4 <telemetryReadSerialData+0x2e4>)
 8003e22:	6812      	ldr	r2, [r2, #0]
 */
static inline size_t chIQGetFullI(input_queue_t *iqp) {

  chDbgCheckClassI();

  return (size_t)chQSpaceI(iqp);
 8003e24:	6957      	ldr	r7, [r2, #20]
 8003e26:	f383 8811 	msr	BASEPRI, r3
	volatile int read2 = chnRead(g_chnp, msgPos, bytesAvailable);
	readSoFar += read2;
  }
#endif

  bytesRequired = 1;
 8003e2a:	f8df 82ec 	ldr.w	r8, [pc, #748]	; 8004118 <telemetryReadSerialData+0x308>
 8003e2e:	2201      	movs	r2, #1
 8003e30:	f8c8 2000 	str.w	r2, [r8]
  
  while (bytesAvailable) {
 8003e34:	2f00      	cmp	r7, #0
 8003e36:	d074      	beq.n	8003f22 <telemetryReadSerialData+0x112>
 8003e38:	4caf      	ldr	r4, [pc, #700]	; (80040f8 <telemetryReadSerialData+0x2e8>)
 8003e3a:	4eb0      	ldr	r6, [pc, #704]	; (80040fc <telemetryReadSerialData+0x2ec>)
 8003e3c:	46a1      	mov	r9, r4
      bytesRequired -= bytesAvailable;
      break;
    }

    size_t curReadLen = msgPos - (uint8_t *)&msg;
    if (!IS_MSG_VALID()) {
 8003e3e:	4625      	mov	r5, r4
 8003e40:	6831      	ldr	r1, [r6, #0]
  bytesRequired = 1;
  
  while (bytesAvailable) {
    //chnWrite(g_chnp, "b" , 1);
    if (bytesAvailable >= bytesRequired) {
      if (bytesRequired > 0) {
 8003e42:	b9fa      	cbnz	r2, 8003e84 <telemetryReadSerialData+0x74>
      bytesRequired -= bytesAvailable;
      break;
    }

    size_t curReadLen = msgPos - (uint8_t *)&msg;
    if (!IS_MSG_VALID()) {
 8003e44:	7823      	ldrb	r3, [r4, #0]
      msgPos += bytesAvailable;
      bytesRequired -= bytesAvailable;
      break;
    }

    size_t curReadLen = msgPos - (uint8_t *)&msg;
 8003e46:	ebc9 0101 	rsb	r1, r9, r1
    if (!IS_MSG_VALID()) {
 8003e4a:	2bbd      	cmp	r3, #189	; 0xbd
 8003e4c:	d139      	bne.n	8003ec2 <telemetryReadSerialData+0xb2>
 8003e4e:	f895 a002 	ldrb.w	sl, [r5, #2]
 8003e52:	f1aa 0308 	sub.w	r3, sl, #8
 8003e56:	b2da      	uxtb	r2, r3
 8003e58:	2a78      	cmp	r2, #120	; 0x78
 8003e5a:	d832      	bhi.n	8003ec2 <telemetryReadSerialData+0xb2>
      telemetryReadSerialDataResync(curReadLen);
      //chnWrite(g_chnp, "test1 not valid" , 10);
    } else if (curReadLen == TELEMETRY_MSG_HDR_SIZE) {
 8003e5c:	2904      	cmp	r1, #4
 8003e5e:	f000 80b1 	beq.w	8003fc4 <telemetryReadSerialData+0x1b4>
      bytesRequired = msg.size - TELEMETRY_MSG_HDR_SIZE;
      //chnWrite(g_chnp, "test msg valid" , 10);
    } else if (bytesRequired == 0) {
 8003e62:	f8d8 b000 	ldr.w	fp, [r8]
 8003e66:	f1bb 0f00 	cmp.w	fp, #0
 8003e6a:	f000 8085 	beq.w	8003f78 <telemetryReadSerialData+0x168>
  }
#endif

  bytesRequired = 1;
  
  while (bytesAvailable) {
 8003e6e:	2f00      	cmp	r7, #0
 8003e70:	d057      	beq.n	8003f22 <telemetryReadSerialData+0x112>
    //chnWrite(g_chnp, "b" , 1);
    if (bytesAvailable >= bytesRequired) {
 8003e72:	f8d8 2000 	ldr.w	r2, [r8]
 8003e76:	f8df b2a0 	ldr.w	fp, [pc, #672]	; 8004118 <telemetryReadSerialData+0x308>
 8003e7a:	4297      	cmp	r7, r2
 8003e7c:	d36a      	bcc.n	8003f54 <telemetryReadSerialData+0x144>
 8003e7e:	6831      	ldr	r1, [r6, #0]
      if (bytesRequired > 0) {
 8003e80:	2a00      	cmp	r2, #0
 8003e82:	d0df      	beq.n	8003e44 <telemetryReadSerialData+0x34>
//        palTogglePad(GPIOA, GPIOA_LED_B);
        led_b = true;
        volatile int read = chnRead(g_chnp, msgPos, bytesRequired);
 8003e84:	4b9b      	ldr	r3, [pc, #620]	; (80040f4 <telemetryReadSerialData+0x2e4>)
  while (bytesAvailable) {
    //chnWrite(g_chnp, "b" , 1);
    if (bytesAvailable >= bytesRequired) {
      if (bytesRequired > 0) {
//        palTogglePad(GPIOA, GPIOA_LED_B);
        led_b = true;
 8003e86:	f04f 0e01 	mov.w	lr, #1
        volatile int read = chnRead(g_chnp, msgPos, bytesRequired);
 8003e8a:	6818      	ldr	r0, [r3, #0]
 8003e8c:	6803      	ldr	r3, [r0, #0]
 8003e8e:	f8d3 c004 	ldr.w	ip, [r3, #4]
  while (bytesAvailable) {
    //chnWrite(g_chnp, "b" , 1);
    if (bytesAvailable >= bytesRequired) {
      if (bytesRequired > 0) {
//        palTogglePad(GPIOA, GPIOA_LED_B);
        led_b = true;
 8003e92:	4b9b      	ldr	r3, [pc, #620]	; (8004100 <telemetryReadSerialData+0x2f0>)
 8003e94:	f883 e000 	strb.w	lr, [r3]
        volatile int read = chnRead(g_chnp, msgPos, bytesRequired);
 8003e98:	47e0      	blx	ip
 8003e9a:	9003      	str	r0, [sp, #12]
        readSoFar += read;
 8003e9c:	9803      	ldr	r0, [sp, #12]
 8003e9e:	9b02      	ldr	r3, [sp, #8]
        msgPos += bytesRequired;
 8003ea0:	f8d8 2000 	ldr.w	r2, [r8]
    if (bytesAvailable >= bytesRequired) {
      if (bytesRequired > 0) {
//        palTogglePad(GPIOA, GPIOA_LED_B);
        led_b = true;
        volatile int read = chnRead(g_chnp, msgPos, bytesRequired);
        readSoFar += read;
 8003ea4:	4403      	add	r3, r0
        msgPos += bytesRequired;
 8003ea6:	6831      	ldr	r1, [r6, #0]
    if (bytesAvailable >= bytesRequired) {
      if (bytesRequired > 0) {
//        palTogglePad(GPIOA, GPIOA_LED_B);
        led_b = true;
        volatile int read = chnRead(g_chnp, msgPos, bytesRequired);
        readSoFar += read;
 8003ea8:	9302      	str	r3, [sp, #8]
      bytesRequired -= bytesAvailable;
      break;
    }

    size_t curReadLen = msgPos - (uint8_t *)&msg;
    if (!IS_MSG_VALID()) {
 8003eaa:	7823      	ldrb	r3, [r4, #0]
      if (bytesRequired > 0) {
//        palTogglePad(GPIOA, GPIOA_LED_B);
        led_b = true;
        volatile int read = chnRead(g_chnp, msgPos, bytesRequired);
        readSoFar += read;
        msgPos += bytesRequired;
 8003eac:	4411      	add	r1, r2
        bytesAvailable -= bytesRequired;
        bytesRequired = 0;
 8003eae:	2000      	movs	r0, #0
      bytesRequired -= bytesAvailable;
      break;
    }

    size_t curReadLen = msgPos - (uint8_t *)&msg;
    if (!IS_MSG_VALID()) {
 8003eb0:	2bbd      	cmp	r3, #189	; 0xbd
      if (bytesRequired > 0) {
//        palTogglePad(GPIOA, GPIOA_LED_B);
        led_b = true;
        volatile int read = chnRead(g_chnp, msgPos, bytesRequired);
        readSoFar += read;
        msgPos += bytesRequired;
 8003eb2:	6031      	str	r1, [r6, #0]
        bytesAvailable -= bytesRequired;
 8003eb4:	eba7 0702 	sub.w	r7, r7, r2
        bytesRequired = 0;
 8003eb8:	f8c8 0000 	str.w	r0, [r8]
      msgPos += bytesAvailable;
      bytesRequired -= bytesAvailable;
      break;
    }

    size_t curReadLen = msgPos - (uint8_t *)&msg;
 8003ebc:	ebc9 0101 	rsb	r1, r9, r1
    if (!IS_MSG_VALID()) {
 8003ec0:	d0c5      	beq.n	8003e4e <telemetryReadSerialData+0x3e>
 *        (few) packet(s) may be dropped - still better than no comm...
 */
static void telemetryReadSerialDataResync(uint8_t len) {
  uint8_t i;

  while (len) {
 8003ec2:	f011 0bff 	ands.w	fp, r1, #255	; 0xff
 8003ec6:	d0d2      	beq.n	8003e6e <telemetryReadSerialData+0x5e>
    for (i = 1; i < len; i++) {
 8003ec8:	f1bb 0f01 	cmp.w	fp, #1
 8003ecc:	d037      	beq.n	8003f3e <telemetryReadSerialData+0x12e>
      if (((uint8_t *)&msg)[i] == TELEMETRY_MSG_SOF) {
 8003ece:	7863      	ldrb	r3, [r4, #1]
 8003ed0:	2bbd      	cmp	r3, #189	; 0xbd
 8003ed2:	d037      	beq.n	8003f44 <telemetryReadSerialData+0x134>
 8003ed4:	4b8b      	ldr	r3, [pc, #556]	; (8004104 <telemetryReadSerialData+0x2f4>)
 8003ed6:	f04f 0a01 	mov.w	sl, #1
 8003eda:	e003      	b.n	8003ee4 <telemetryReadSerialData+0xd4>
 8003edc:	f813 2f01 	ldrb.w	r2, [r3, #1]!
 8003ee0:	2abd      	cmp	r2, #189	; 0xbd
 8003ee2:	d021      	beq.n	8003f28 <telemetryReadSerialData+0x118>
 */
static void telemetryReadSerialDataResync(uint8_t len) {
  uint8_t i;

  while (len) {
    for (i = 1; i < len; i++) {
 8003ee4:	f10a 0a01 	add.w	sl, sl, #1
 8003ee8:	fa5f fa8a 	uxtb.w	sl, sl
 8003eec:	45da      	cmp	sl, fp
 8003eee:	d1f5      	bne.n	8003edc <telemetryReadSerialData+0xcc>
    }

    if (len - i > 0) {
      memmove(&msg, &((uint8_t *)&msg)[i], len - i);
    }
    len -= i;
 8003ef0:	ebca 0b0b 	rsb	fp, sl, fp
 8003ef4:	fa5f fb8b 	uxtb.w	fp, fp
    msgPos = (uint8_t *)&msg + len;
 8003ef8:	eb04 010b 	add.w	r1, r4, fp

    if (len < TELEMETRY_MSG_HDR_SIZE) {
 8003efc:	f1bb 0f03 	cmp.w	fp, #3

    if (len - i > 0) {
      memmove(&msg, &((uint8_t *)&msg)[i], len - i);
    }
    len -= i;
    msgPos = (uint8_t *)&msg + len;
 8003f00:	6031      	str	r1, [r6, #0]

    if (len < TELEMETRY_MSG_HDR_SIZE) {
 8003f02:	d922      	bls.n	8003f4a <telemetryReadSerialData+0x13a>
      /* ...wait for header to get completed */
      bytesRequired = TELEMETRY_MSG_HDR_SIZE - len;
      break;
    } else {
      if (IS_MSG_VALID()) {
 8003f04:	782b      	ldrb	r3, [r5, #0]
 8003f06:	2bbd      	cmp	r3, #189	; 0xbd
 8003f08:	d1de      	bne.n	8003ec8 <telemetryReadSerialData+0xb8>
 8003f0a:	78ab      	ldrb	r3, [r5, #2]
 8003f0c:	f1a3 0208 	sub.w	r2, r3, #8
 8003f10:	2a78      	cmp	r2, #120	; 0x78
 8003f12:	d8d9      	bhi.n	8003ec8 <telemetryReadSerialData+0xb8>
        if (msg.size <= len) {
 8003f14:	455b      	cmp	r3, fp
 8003f16:	d85a      	bhi.n	8003fce <telemetryReadSerialData+0x1be>
          /* This may throw away some data at the tail of buffer...*/
          bytesRequired = 0;
 8003f18:	2300      	movs	r3, #0
 8003f1a:	f8c8 3000 	str.w	r3, [r8]
  }
#endif

  bytesRequired = 1;
  
  while (bytesAvailable) {
 8003f1e:	2f00      	cmp	r7, #0
 8003f20:	d190      	bne.n	8003e44 <telemetryReadSerialData+0x34>
      /* Read another packet...*/
      bytesRequired = TELEMETRY_MSG_HDR_SIZE;
      msgPos = (uint8_t*)&msg;
    }
  }
}
 8003f22:	b005      	add	sp, #20
 8003f24:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8003f28:	4652      	mov	r2, sl
      if (((uint8_t *)&msg)[i] == TELEMETRY_MSG_SOF) {
        break;
      }
    }

    if (len - i > 0) {
 8003f2a:	ebc2 020b 	rsb	r2, r2, fp
 8003f2e:	2a00      	cmp	r2, #0
 8003f30:	ddde      	ble.n	8003ef0 <telemetryReadSerialData+0xe0>
      memmove(&msg, &((uint8_t *)&msg)[i], len - i);
 8003f32:	eb04 010a 	add.w	r1, r4, sl
 8003f36:	4870      	ldr	r0, [pc, #448]	; (80040f8 <telemetryReadSerialData+0x2e8>)
 8003f38:	f000 faca 	bl	80044d0 <memmove>
 8003f3c:	e7d8      	b.n	8003ef0 <telemetryReadSerialData+0xe0>
 */
static void telemetryReadSerialDataResync(uint8_t len) {
  uint8_t i;

  while (len) {
    for (i = 1; i < len; i++) {
 8003f3e:	46da      	mov	sl, fp
 8003f40:	465a      	mov	r2, fp
 8003f42:	e7f2      	b.n	8003f2a <telemetryReadSerialData+0x11a>
      if (((uint8_t *)&msg)[i] == TELEMETRY_MSG_SOF) {
 8003f44:	2201      	movs	r2, #1
 8003f46:	4692      	mov	sl, r2
 8003f48:	e7ef      	b.n	8003f2a <telemetryReadSerialData+0x11a>
    len -= i;
    msgPos = (uint8_t *)&msg + len;

    if (len < TELEMETRY_MSG_HDR_SIZE) {
      /* ...wait for header to get completed */
      bytesRequired = TELEMETRY_MSG_HDR_SIZE - len;
 8003f4a:	f1cb 0304 	rsb	r3, fp, #4
 8003f4e:	f8c8 3000 	str.w	r3, [r8]
 8003f52:	e78c      	b.n	8003e6e <telemetryReadSerialData+0x5e>
        msgPos += bytesRequired;
        bytesAvailable -= bytesRequired;
        bytesRequired = 0;
      }
    } else {
      chnRead(g_chnp, msgPos, bytesAvailable);
 8003f54:	4b67      	ldr	r3, [pc, #412]	; (80040f4 <telemetryReadSerialData+0x2e4>)
 8003f56:	463a      	mov	r2, r7
 8003f58:	6818      	ldr	r0, [r3, #0]
 8003f5a:	6831      	ldr	r1, [r6, #0]
 8003f5c:	6803      	ldr	r3, [r0, #0]
 8003f5e:	685b      	ldr	r3, [r3, #4]
 8003f60:	4798      	blx	r3
      msgPos += bytesAvailable;
 8003f62:	6832      	ldr	r2, [r6, #0]
      bytesRequired -= bytesAvailable;
 8003f64:	f8db 3000 	ldr.w	r3, [fp]
        bytesAvailable -= bytesRequired;
        bytesRequired = 0;
      }
    } else {
      chnRead(g_chnp, msgPos, bytesAvailable);
      msgPos += bytesAvailable;
 8003f68:	443a      	add	r2, r7
      bytesRequired -= bytesAvailable;
 8003f6a:	1bdb      	subs	r3, r3, r7
        bytesAvailable -= bytesRequired;
        bytesRequired = 0;
      }
    } else {
      chnRead(g_chnp, msgPos, bytesAvailable);
      msgPos += bytesAvailable;
 8003f6c:	6032      	str	r2, [r6, #0]
      bytesRequired -= bytesAvailable;
 8003f6e:	f8cb 3000 	str.w	r3, [fp]
      /* Read another packet...*/
      bytesRequired = TELEMETRY_MSG_HDR_SIZE;
      msgPos = (uint8_t*)&msg;
    }
  }
}
 8003f72:	b005      	add	sp, #20
 8003f74:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      //chnWrite(g_chnp, "test msg valid" , 10);
    } else if (bytesRequired == 0) {
    //chnWrite(g_chnp, "otrzyma 0" , 10);
      /* Whole packet is read, check and process it... */
      /* Move CRC */
      memmove(&msg.crc, (uint8_t *)&msg + msg.size - TELEMETRY_MSG_CRC_SIZE,
 8003f78:	f1aa 0104 	sub.w	r1, sl, #4
 8003f7c:	4429      	add	r1, r5
 8003f7e:	2204      	movs	r2, #4
 8003f80:	4861      	ldr	r0, [pc, #388]	; (8004108 <telemetryReadSerialData+0x2f8>)
 8003f82:	9301      	str	r3, [sp, #4]
 8003f84:	f000 faa4 	bl	80044d0 <memmove>
        TELEMETRY_MSG_CRC_SIZE);
      /* Zero-out unused data for crc32 calculation. */
      memset(&msg.data[msg.size - TELEMETRY_MSG_SVC_SIZE], 0,
 8003f88:	9b01      	ldr	r3, [sp, #4]
 8003f8a:	f1ca 0288 	rsb	r2, sl, #136	; 0x88
 8003f8e:	18e8      	adds	r0, r5, r3
 8003f90:	4659      	mov	r1, fp
 8003f92:	3004      	adds	r0, #4
 8003f94:	f000 fb04 	bl	80045a0 <memset>
        TELEMETRY_BUFFER_SIZE - msg.size + TELEMETRY_MSG_SVC_SIZE);

      if (msg.crc == telemetryGetCRC32Checksum(&msg)) {
 8003f98:	4857      	ldr	r0, [pc, #348]	; (80040f8 <telemetryReadSerialData+0x2e8>)
 8003f9a:	f8d5 a084 	ldr.w	sl, [r5, #132]	; 0x84
 8003f9e:	f7ff fedf 	bl	8003d60 <telemetryGetCRC32Checksum>
 8003fa2:	4582      	cmp	sl, r0
 8003fa4:	d018      	beq.n	8003fd8 <telemetryReadSerialData+0x1c8>
 //       for (i =0; i < 50; i++) {
 //         palTogglePad(GPIOA, GPIOA_LED_B);
 //         chThdSleepMilliseconds(10.5);
 //       }

          led_b = true;
 8003fa6:	4a56      	ldr	r2, [pc, #344]	; (8004100 <telemetryReadSerialData+0x2f0>)
 8003fa8:	2301      	movs	r3, #1
          chThdSleepMilliseconds(500);
 8003faa:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 //       for (i =0; i < 50; i++) {
 //         palTogglePad(GPIOA, GPIOA_LED_B);
 //         chThdSleepMilliseconds(10.5);
 //       }

          led_b = true;
 8003fae:	7013      	strb	r3, [r2, #0]
          chThdSleepMilliseconds(500);
 8003fb0:	f7fd fb6e 	bl	8001690 <chThdSleep>
          led_b = false;
 8003fb4:	4b52      	ldr	r3, [pc, #328]	; (8004100 <telemetryReadSerialData+0x2f0>)
 8003fb6:	f883 b000 	strb.w	fp, [r3]

      }

      /* Read another packet...*/
      bytesRequired = TELEMETRY_MSG_HDR_SIZE;
 8003fba:	2304      	movs	r3, #4
      msgPos = (uint8_t*)&msg;
 8003fbc:	6034      	str	r4, [r6, #0]
          led_b = false;

      }

      /* Read another packet...*/
      bytesRequired = TELEMETRY_MSG_HDR_SIZE;
 8003fbe:	f8c8 3000 	str.w	r3, [r8]
 8003fc2:	e754      	b.n	8003e6e <telemetryReadSerialData+0x5e>
    size_t curReadLen = msgPos - (uint8_t *)&msg;
    if (!IS_MSG_VALID()) {
      telemetryReadSerialDataResync(curReadLen);
      //chnWrite(g_chnp, "test1 not valid" , 10);
    } else if (curReadLen == TELEMETRY_MSG_HDR_SIZE) {
      bytesRequired = msg.size - TELEMETRY_MSG_HDR_SIZE;
 8003fc4:	f1aa 0304 	sub.w	r3, sl, #4
 8003fc8:	f8c8 3000 	str.w	r3, [r8]
 8003fcc:	e74f      	b.n	8003e6e <telemetryReadSerialData+0x5e>
      if (IS_MSG_VALID()) {
        if (msg.size <= len) {
          /* This may throw away some data at the tail of buffer...*/
          bytesRequired = 0;
        } else {
          bytesRequired = msg.size - len;
 8003fce:	ebcb 0303 	rsb	r3, fp, r3
 8003fd2:	f8c8 3000 	str.w	r3, [r8]
 8003fd6:	e74a      	b.n	8003e6e <telemetryReadSerialData+0x5e>
 * @return none.
 */
static void telemetryProcessCommand(const PMessage pMsg) {
  //chnWrite(g_chnp, "otrzymao" + pMsg->msg_id, 20);
    
  switch (pMsg->msg_id) {
 8003fd8:	786b      	ldrb	r3, [r5, #1]
 8003fda:	3b44      	subs	r3, #68	; 0x44
 8003fdc:	2b2f      	cmp	r3, #47	; 0x2f
 8003fde:	d831      	bhi.n	8004044 <telemetryReadSerialData+0x234>
 8003fe0:	e8df f013 	tbh	[pc, r3, lsl #1]
 8003fe4:	003001a4 	.word	0x003001a4
 8003fe8:	0030019a 	.word	0x0030019a
 8003fec:	01900030 	.word	0x01900030
 8003ff0:	00300030 	.word	0x00300030
 8003ff4:	01860030 	.word	0x01860030
 8003ff8:	017c0030 	.word	0x017c0030
 8003ffc:	00300030 	.word	0x00300030
 8004000:	01720030 	.word	0x01720030
 8004004:	00300030 	.word	0x00300030
 8004008:	00300030 	.word	0x00300030
 800400c:	0030016c 	.word	0x0030016c
 8004010:	0159015f 	.word	0x0159015f
 8004014:	01550030 	.word	0x01550030
 8004018:	00300030 	.word	0x00300030
 800401c:	01530030 	.word	0x01530030
 8004020:	01400148 	.word	0x01400148
 8004024:	011b0129 	.word	0x011b0129
 8004028:	010d010f 	.word	0x010d010f
 800402c:	00eb0100 	.word	0x00eb0100
 8004030:	00300030 	.word	0x00300030
 8004034:	00b400d3 	.word	0x00b400d3
 8004038:	009e0030 	.word	0x009e0030
 800403c:	00300063 	.word	0x00300063
 8004040:	003a004f 	.word	0x003a004f
  case 'X': /* Hard reset the board. */
    telemetryPositiveResponse(pMsg);
    g_runMain = FALSE;
    break;
  default: /* Unknown command. */
    telemetryNegativeResponse(pMsg);
 8004044:	f7ff fec4 	bl	8003dd0 <telemetryNegativeResponse.constprop.1>
  }
  pMsg->sof = TELEMETRY_MSG_SOF;
 8004048:	22bd      	movs	r2, #189	; 0xbd
  pMsg->res = 0;
 800404a:	2300      	movs	r3, #0
  telemetrySendSerialData(pMsg);
 800404c:	482a      	ldr	r0, [pc, #168]	; (80040f8 <telemetryReadSerialData+0x2e8>)
    g_runMain = FALSE;
    break;
  default: /* Unknown command. */
    telemetryNegativeResponse(pMsg);
  }
  pMsg->sof = TELEMETRY_MSG_SOF;
 800404e:	7022      	strb	r2, [r4, #0]
  pMsg->res = 0;
 8004050:	70e3      	strb	r3, [r4, #3]
  telemetrySendSerialData(pMsg);
 8004052:	f7ff fea5 	bl	8003da0 <telemetrySendSerialData>
 8004056:	e7b0      	b.n	8003fba <telemetryReadSerialData+0x1aa>
    pMsg->size = sizeof(g_IMU1.qIMU) + TELEMETRY_MSG_SVC_SIZE;
    pMsg->crc  = telemetryGetCRC32Checksum(pMsg);
    break;
  case 's': /* Outputs PID settings; */
    /* Clean data buffer for zero-padded crc32 checksum calculation. */
    memset((void *)pMsg->data, 0, TELEMETRY_BUFFER_SIZE);
 8004058:	2100      	movs	r1, #0
 800405a:	2280      	movs	r2, #128	; 0x80
 800405c:	482b      	ldr	r0, [pc, #172]	; (800410c <telemetryReadSerialData+0x2fc>)
 800405e:	f000 fa9f 	bl	80045a0 <memset>
    memcpy((void *)pMsg->data, (void *)g_pidSettings, sizeof(g_pidSettings));
 8004062:	4a2b      	ldr	r2, [pc, #172]	; (8004110 <telemetryReadSerialData+0x300>)
 8004064:	4b29      	ldr	r3, [pc, #164]	; (800410c <telemetryReadSerialData+0x2fc>)
 8004066:	6810      	ldr	r0, [r2, #0]
 8004068:	6851      	ldr	r1, [r2, #4]
 800406a:	7a12      	ldrb	r2, [r2, #8]
 800406c:	c303      	stmia	r3!, {r0, r1}
 800406e:	4618      	mov	r0, r3
    pMsg->size = sizeof(g_pidSettings) + TELEMETRY_MSG_SVC_SIZE;
 8004070:	2311      	movs	r3, #17
    pMsg->crc  = telemetryGetCRC32Checksum(pMsg);
    break;
  case 's': /* Outputs PID settings; */
    /* Clean data buffer for zero-padded crc32 checksum calculation. */
    memset((void *)pMsg->data, 0, TELEMETRY_BUFFER_SIZE);
    memcpy((void *)pMsg->data, (void *)g_pidSettings, sizeof(g_pidSettings));
 8004072:	f800 290c 	strb.w	r2, [r0], #-12
    pMsg->size = sizeof(g_pidSettings) + TELEMETRY_MSG_SVC_SIZE;
 8004076:	70a3      	strb	r3, [r4, #2]
    pMsg->crc  = telemetryGetCRC32Checksum(pMsg);
 8004078:	f7ff fe72 	bl	8003d60 <telemetryGetCRC32Checksum>
 800407c:	f8c4 0084 	str.w	r0, [r4, #132]	; 0x84
 8004080:	e7e2      	b.n	8004048 <telemetryReadSerialData+0x238>
    memcpy((void *)pMsg->data, (void *)g_mixedInput, sizeof(g_mixedInput));
    pMsg->size = sizeof(g_mixedInput) + TELEMETRY_MSG_SVC_SIZE;
    pMsg->crc  = telemetryGetCRC32Checksum(pMsg);
    break;
  case 'r': /* Outputs camera attitude data; */
    memcpy((void *)pMsg->data, (void *)g_IMU1.qIMU, sizeof(g_IMU1.qIMU));
 8004082:	4b24      	ldr	r3, [pc, #144]	; (8004114 <telemetryReadSerialData+0x304>)
 8004084:	f8df e084 	ldr.w	lr, [pc, #132]	; 800410c <telemetryReadSerialData+0x2fc>
 8004088:	6818      	ldr	r0, [r3, #0]
 800408a:	6859      	ldr	r1, [r3, #4]
 800408c:	689a      	ldr	r2, [r3, #8]
 800408e:	68db      	ldr	r3, [r3, #12]
    pMsg->size = sizeof(g_IMU1.qIMU) + TELEMETRY_MSG_SVC_SIZE;
 8004090:	f04f 0c18 	mov.w	ip, #24
    memcpy((void *)pMsg->data, (void *)g_mixedInput, sizeof(g_mixedInput));
    pMsg->size = sizeof(g_mixedInput) + TELEMETRY_MSG_SVC_SIZE;
    pMsg->crc  = telemetryGetCRC32Checksum(pMsg);
    break;
  case 'r': /* Outputs camera attitude data; */
    memcpy((void *)pMsg->data, (void *)g_IMU1.qIMU, sizeof(g_IMU1.qIMU));
 8004094:	e8ae 000f 	stmia.w	lr!, {r0, r1, r2, r3}
    pMsg->size = sizeof(g_IMU1.qIMU) + TELEMETRY_MSG_SVC_SIZE;
    pMsg->crc  = telemetryGetCRC32Checksum(pMsg);
 8004098:	f1ae 0014 	sub.w	r0, lr, #20
    pMsg->size = sizeof(g_mixedInput) + TELEMETRY_MSG_SVC_SIZE;
    pMsg->crc  = telemetryGetCRC32Checksum(pMsg);
    break;
  case 'r': /* Outputs camera attitude data; */
    memcpy((void *)pMsg->data, (void *)g_IMU1.qIMU, sizeof(g_IMU1.qIMU));
    pMsg->size = sizeof(g_IMU1.qIMU) + TELEMETRY_MSG_SVC_SIZE;
 800409c:	f884 c002 	strb.w	ip, [r4, #2]
    pMsg->crc  = telemetryGetCRC32Checksum(pMsg);
 80040a0:	f7ff fe5e 	bl	8003d60 <telemetryGetCRC32Checksum>
 80040a4:	f8c4 0084 	str.w	r0, [r4, #132]	; 0x84
 80040a8:	e7ce      	b.n	8004048 <telemetryReadSerialData+0x238>
    pMsg->size = sizeof(g_pwmOutput) + TELEMETRY_MSG_SVC_SIZE;
    pMsg->crc  = telemetryGetCRC32Checksum(pMsg);
    break;
  case 'p': /* Outputs mixed input settings. */
    /* Clean data buffer for zero-padded crc32 checksum calculation. */
    memset((void *)pMsg->data, 0, TELEMETRY_BUFFER_SIZE);
 80040aa:	2100      	movs	r1, #0
 80040ac:	2280      	movs	r2, #128	; 0x80
 80040ae:	4817      	ldr	r0, [pc, #92]	; (800410c <telemetryReadSerialData+0x2fc>)
 80040b0:	f000 fa76 	bl	80045a0 <memset>
    memcpy((void *)pMsg->data, (void *)g_mixedInput, sizeof(g_mixedInput));
 80040b4:	f8df c064 	ldr.w	ip, [pc, #100]	; 800411c <telemetryReadSerialData+0x30c>
 80040b8:	f8df e050 	ldr.w	lr, [pc, #80]	; 800410c <telemetryReadSerialData+0x2fc>
 80040bc:	f8dc 0000 	ldr.w	r0, [ip]
 80040c0:	f8dc 300c 	ldr.w	r3, [ip, #12]
 80040c4:	f8dc 1004 	ldr.w	r1, [ip, #4]
 80040c8:	f8dc 2008 	ldr.w	r2, [ip, #8]
 80040cc:	f89c a014 	ldrb.w	sl, [ip, #20]
 80040d0:	e8ae 000f 	stmia.w	lr!, {r0, r1, r2, r3}
 80040d4:	f8dc 0010 	ldr.w	r0, [ip, #16]
    pMsg->size = sizeof(g_mixedInput) + TELEMETRY_MSG_SVC_SIZE;
 80040d8:	231d      	movs	r3, #29
    pMsg->crc  = telemetryGetCRC32Checksum(pMsg);
    break;
  case 'p': /* Outputs mixed input settings. */
    /* Clean data buffer for zero-padded crc32 checksum calculation. */
    memset((void *)pMsg->data, 0, TELEMETRY_BUFFER_SIZE);
    memcpy((void *)pMsg->data, (void *)g_mixedInput, sizeof(g_mixedInput));
 80040da:	f8ce 0000 	str.w	r0, [lr]
 80040de:	f88e a004 	strb.w	sl, [lr, #4]
    pMsg->size = sizeof(g_mixedInput) + TELEMETRY_MSG_SVC_SIZE;
    pMsg->crc  = telemetryGetCRC32Checksum(pMsg);
 80040e2:	f1ae 0014 	sub.w	r0, lr, #20
    break;
  case 'p': /* Outputs mixed input settings. */
    /* Clean data buffer for zero-padded crc32 checksum calculation. */
    memset((void *)pMsg->data, 0, TELEMETRY_BUFFER_SIZE);
    memcpy((void *)pMsg->data, (void *)g_mixedInput, sizeof(g_mixedInput));
    pMsg->size = sizeof(g_mixedInput) + TELEMETRY_MSG_SVC_SIZE;
 80040e6:	70a3      	strb	r3, [r4, #2]
    pMsg->crc  = telemetryGetCRC32Checksum(pMsg);
 80040e8:	f7ff fe3a 	bl	8003d60 <telemetryGetCRC32Checksum>
 80040ec:	f8c4 0084 	str.w	r0, [r4, #132]	; 0x84
 80040f0:	e7aa      	b.n	8004048 <telemetryReadSerialData+0x238>
 80040f2:	bf00      	nop
 80040f4:	200010d8 	.word	0x200010d8
 80040f8:	2000085c 	.word	0x2000085c
 80040fc:	200008e4 	.word	0x200008e4
 8004100:	20000fe0 	.word	0x20000fe0
 8004104:	2000085d 	.word	0x2000085d
 8004108:	200008e0 	.word	0x200008e0
 800410c:	20000860 	.word	0x20000860
 8004110:	2000082c 	.word	0x2000082c
 8004114:	2000102c 	.word	0x2000102c
 8004118:	200008e8 	.word	0x200008e8
 800411c:	2000080c 	.word	0x2000080c
    pMsg->size = sizeof(g_modeSettings) + TELEMETRY_MSG_SVC_SIZE;
    pMsg->crc  = telemetryGetCRC32Checksum(pMsg);
    break;
  case 'o': /* Outputs PWM output settings; */
    /* Clean data buffer for zero-padded crc32 checksum calculation. */
    memset((void *)pMsg->data, 0, TELEMETRY_BUFFER_SIZE);
 8004120:	2280      	movs	r2, #128	; 0x80
 8004122:	4887      	ldr	r0, [pc, #540]	; (8004340 <telemetryReadSerialData+0x530>)
 8004124:	2100      	movs	r1, #0
 8004126:	f000 fa3b 	bl	80045a0 <memset>
    memcpy((void *)pMsg->data, (void *)g_pwmOutput, sizeof(g_pwmOutput));
 800412a:	4a86      	ldr	r2, [pc, #536]	; (8004344 <telemetryReadSerialData+0x534>)
 800412c:	6810      	ldr	r0, [r2, #0]
 800412e:	6851      	ldr	r1, [r2, #4]
 8004130:	4b83      	ldr	r3, [pc, #524]	; (8004340 <telemetryReadSerialData+0x530>)
 8004132:	6892      	ldr	r2, [r2, #8]
    pMsg->size = sizeof(g_pwmOutput) + TELEMETRY_MSG_SVC_SIZE;
 8004134:	f04f 0e14 	mov.w	lr, #20
    pMsg->crc  = telemetryGetCRC32Checksum(pMsg);
    break;
  case 'o': /* Outputs PWM output settings; */
    /* Clean data buffer for zero-padded crc32 checksum calculation. */
    memset((void *)pMsg->data, 0, TELEMETRY_BUFFER_SIZE);
    memcpy((void *)pMsg->data, (void *)g_pwmOutput, sizeof(g_pwmOutput));
 8004138:	c307      	stmia	r3!, {r0, r1, r2}
    pMsg->size = sizeof(g_pwmOutput) + TELEMETRY_MSG_SVC_SIZE;
    pMsg->crc  = telemetryGetCRC32Checksum(pMsg);
 800413a:	f1a3 0010 	sub.w	r0, r3, #16
    break;
  case 'o': /* Outputs PWM output settings; */
    /* Clean data buffer for zero-padded crc32 checksum calculation. */
    memset((void *)pMsg->data, 0, TELEMETRY_BUFFER_SIZE);
    memcpy((void *)pMsg->data, (void *)g_pwmOutput, sizeof(g_pwmOutput));
    pMsg->size = sizeof(g_pwmOutput) + TELEMETRY_MSG_SVC_SIZE;
 800413e:	f884 e002 	strb.w	lr, [r4, #2]
    pMsg->crc  = telemetryGetCRC32Checksum(pMsg);
 8004142:	f7ff fe0d 	bl	8003d60 <telemetryGetCRC32Checksum>
 8004146:	f8c4 0084 	str.w	r0, [r4, #132]	; 0x84
 800414a:	e77d      	b.n	8004048 <telemetryReadSerialData+0x238>
    memcpy((void *)pMsg->data, (void *)g_inputValues, sizeof(g_inputValues));
    pMsg->size = sizeof(g_inputValues) + TELEMETRY_MSG_SVC_SIZE;
    pMsg->crc  = telemetryGetCRC32Checksum(pMsg);
    break;
  case 'm': /* Outputs input mode settings; */
    memcpy((void *)pMsg->data, (void *)g_modeSettings, sizeof(g_modeSettings));
 800414c:	f8df c22c 	ldr.w	ip, [pc, #556]	; 800437c <telemetryReadSerialData+0x56c>
 8004150:	f8df e1ec 	ldr.w	lr, [pc, #492]	; 8004340 <telemetryReadSerialData+0x530>
 8004154:	f8dc 0000 	ldr.w	r0, [ip]
 8004158:	f8dc 1004 	ldr.w	r1, [ip, #4]
 800415c:	f8dc 2008 	ldr.w	r2, [ip, #8]
 8004160:	f8dc 300c 	ldr.w	r3, [ip, #12]
    pMsg->size = sizeof(g_modeSettings) + TELEMETRY_MSG_SVC_SIZE;
 8004164:	f04f 0a20 	mov.w	sl, #32
    memcpy((void *)pMsg->data, (void *)g_inputValues, sizeof(g_inputValues));
    pMsg->size = sizeof(g_inputValues) + TELEMETRY_MSG_SVC_SIZE;
    pMsg->crc  = telemetryGetCRC32Checksum(pMsg);
    break;
  case 'm': /* Outputs input mode settings; */
    memcpy((void *)pMsg->data, (void *)g_modeSettings, sizeof(g_modeSettings));
 8004168:	e8ae 000f 	stmia.w	lr!, {r0, r1, r2, r3}
 800416c:	f8dc 0010 	ldr.w	r0, [ip, #16]
 8004170:	f8dc 1014 	ldr.w	r1, [ip, #20]
    pMsg->size = sizeof(g_modeSettings) + TELEMETRY_MSG_SVC_SIZE;
 8004174:	f884 a002 	strb.w	sl, [r4, #2]
    memcpy((void *)pMsg->data, (void *)g_inputValues, sizeof(g_inputValues));
    pMsg->size = sizeof(g_inputValues) + TELEMETRY_MSG_SVC_SIZE;
    pMsg->crc  = telemetryGetCRC32Checksum(pMsg);
    break;
  case 'm': /* Outputs input mode settings; */
    memcpy((void *)pMsg->data, (void *)g_modeSettings, sizeof(g_modeSettings));
 8004178:	e8ae 0003 	stmia.w	lr!, {r0, r1}
    pMsg->size = sizeof(g_modeSettings) + TELEMETRY_MSG_SVC_SIZE;
    pMsg->crc  = telemetryGetCRC32Checksum(pMsg);
 800417c:	f1ae 001c 	sub.w	r0, lr, #28
 8004180:	f7ff fdee 	bl	8003d60 <telemetryGetCRC32Checksum>
 8004184:	f8c4 0084 	str.w	r0, [r4, #132]	; 0x84
 8004188:	e75e      	b.n	8004048 <telemetryReadSerialData+0x238>
  case ']': /* Calibrate accelerometer. */
    imuCalibrationSet(IMU1_CALIBRATE_ACCEL);
    telemetryPositiveResponse(pMsg);
    break;
  case 'l': /* Outputs last debug message. */
    memset((void *)pMsg->data, 0, TELEMETRY_BUFFER_SIZE);
 800418a:	2100      	movs	r1, #0
 800418c:	2280      	movs	r2, #128	; 0x80
 800418e:	486c      	ldr	r0, [pc, #432]	; (8004340 <telemetryReadSerialData+0x530>)
 8004190:	f000 fa06 	bl	80045a0 <memset>
    memcpy((void *)pMsg->data, (void *)debugMsg.data, debugMsg.size);
 8004194:	4b6c      	ldr	r3, [pc, #432]	; (8004348 <telemetryReadSerialData+0x538>)
 8004196:	486a      	ldr	r0, [pc, #424]	; (8004340 <telemetryReadSerialData+0x530>)
 8004198:	f893 a002 	ldrb.w	sl, [r3, #2]
 800419c:	1d19      	adds	r1, r3, #4
 800419e:	4652      	mov	r2, sl
 80041a0:	f7fc ffa6 	bl	80010f0 <memcpy>
    pMsg->size = debugMsg.size;
    pMsg->crc  = telemetryGetCRC32Checksum(&debugMsg);
 80041a4:	4868      	ldr	r0, [pc, #416]	; (8004348 <telemetryReadSerialData+0x538>)
    telemetryPositiveResponse(pMsg);
    break;
  case 'l': /* Outputs last debug message. */
    memset((void *)pMsg->data, 0, TELEMETRY_BUFFER_SIZE);
    memcpy((void *)pMsg->data, (void *)debugMsg.data, debugMsg.size);
    pMsg->size = debugMsg.size;
 80041a6:	f884 a002 	strb.w	sl, [r4, #2]
    pMsg->crc  = telemetryGetCRC32Checksum(&debugMsg);
 80041aa:	f7ff fdd9 	bl	8003d60 <telemetryGetCRC32Checksum>
    debugMsg.size = 0;
 80041ae:	4a66      	ldr	r2, [pc, #408]	; (8004348 <telemetryReadSerialData+0x538>)
 80041b0:	2300      	movs	r3, #0
    break;
  case 'l': /* Outputs last debug message. */
    memset((void *)pMsg->data, 0, TELEMETRY_BUFFER_SIZE);
    memcpy((void *)pMsg->data, (void *)debugMsg.data, debugMsg.size);
    pMsg->size = debugMsg.size;
    pMsg->crc  = telemetryGetCRC32Checksum(&debugMsg);
 80041b2:	f8c4 0084 	str.w	r0, [r4, #132]	; 0x84
    debugMsg.size = 0;
 80041b6:	7093      	strb	r3, [r2, #2]
 80041b8:	e746      	b.n	8004048 <telemetryReadSerialData+0x238>
    pMsg->size = sizeof(g_motorOffset) + TELEMETRY_MSG_SVC_SIZE;
    pMsg->crc  = telemetryGetCRC32Checksum(pMsg);
    break;
  case 'i': /* Outputs input data values; */
    /* Clean data buffer for zero-padded crc32 checksum calculation. */
    memset((void *)pMsg->data, 0, TELEMETRY_BUFFER_SIZE);
 80041ba:	2100      	movs	r1, #0
 80041bc:	2280      	movs	r2, #128	; 0x80
 80041be:	4860      	ldr	r0, [pc, #384]	; (8004340 <telemetryReadSerialData+0x530>)
 80041c0:	f000 f9ee 	bl	80045a0 <memset>
    memcpy((void *)pMsg->data, (void *)g_inputValues, sizeof(g_inputValues));
 80041c4:	4a61      	ldr	r2, [pc, #388]	; (800434c <telemetryReadSerialData+0x53c>)
 80041c6:	4b5e      	ldr	r3, [pc, #376]	; (8004340 <telemetryReadSerialData+0x530>)
 80041c8:	6810      	ldr	r0, [r2, #0]
 80041ca:	6851      	ldr	r1, [r2, #4]
 80041cc:	8912      	ldrh	r2, [r2, #8]
 80041ce:	c303      	stmia	r3!, {r0, r1}
 80041d0:	4618      	mov	r0, r3
    pMsg->size = sizeof(g_inputValues) + TELEMETRY_MSG_SVC_SIZE;
 80041d2:	2312      	movs	r3, #18
    pMsg->crc  = telemetryGetCRC32Checksum(pMsg);
    break;
  case 'i': /* Outputs input data values; */
    /* Clean data buffer for zero-padded crc32 checksum calculation. */
    memset((void *)pMsg->data, 0, TELEMETRY_BUFFER_SIZE);
    memcpy((void *)pMsg->data, (void *)g_inputValues, sizeof(g_inputValues));
 80041d4:	f820 290c 	strh.w	r2, [r0], #-12
    pMsg->size = sizeof(g_inputValues) + TELEMETRY_MSG_SVC_SIZE;
 80041d8:	70a3      	strb	r3, [r4, #2]
    pMsg->crc  = telemetryGetCRC32Checksum(pMsg);
 80041da:	f7ff fdc1 	bl	8003d60 <telemetryGetCRC32Checksum>
 80041de:	f8c4 0084 	str.w	r0, [r4, #132]	; 0x84
 80041e2:	e731      	b.n	8004048 <telemetryReadSerialData+0x238>
    memcpy((void *)pMsg->data, (void *)g_IMU1.gyroData, sizeof(g_IMU1.gyroData));
    pMsg->size = sizeof(g_IMU1.gyroData) + TELEMETRY_MSG_SVC_SIZE;
    pMsg->crc  = telemetryGetCRC32Checksum(pMsg);
    break;
  case 'h': /* Outputs motor offset data; */
    memcpy((void *)pMsg->data, (void *)g_motorOffset, sizeof(g_motorOffset));
 80041e4:	4b56      	ldr	r3, [pc, #344]	; (8004340 <telemetryReadSerialData+0x530>)
 80041e6:	4a5a      	ldr	r2, [pc, #360]	; (8004350 <telemetryReadSerialData+0x540>)
 80041e8:	ca07      	ldmia	r2, {r0, r1, r2}
 80041ea:	e883 0007 	stmia.w	r3, {r0, r1, r2}
    pMsg->size = sizeof(g_motorOffset) + TELEMETRY_MSG_SVC_SIZE;
 80041ee:	2214      	movs	r2, #20
    pMsg->crc  = telemetryGetCRC32Checksum(pMsg);
 80041f0:	1f18      	subs	r0, r3, #4
    pMsg->size = sizeof(g_IMU1.gyroData) + TELEMETRY_MSG_SVC_SIZE;
    pMsg->crc  = telemetryGetCRC32Checksum(pMsg);
    break;
  case 'h': /* Outputs motor offset data; */
    memcpy((void *)pMsg->data, (void *)g_motorOffset, sizeof(g_motorOffset));
    pMsg->size = sizeof(g_motorOffset) + TELEMETRY_MSG_SVC_SIZE;
 80041f2:	70a2      	strb	r2, [r4, #2]
    pMsg->crc  = telemetryGetCRC32Checksum(pMsg);
 80041f4:	f7ff fdb4 	bl	8003d60 <telemetryGetCRC32Checksum>
 80041f8:	f8c4 0084 	str.w	r0, [r4, #132]	; 0x84
 80041fc:	e724      	b.n	8004048 <telemetryReadSerialData+0x238>
    memcpy((void *)pMsg->data, (void *)&g_cfSettings, sizeof(g_cfSettings));
    pMsg->size = sizeof(g_cfSettings) + TELEMETRY_MSG_SVC_SIZE;
    pMsg->crc  = telemetryGetCRC32Checksum(pMsg);
    break;
  case 'g': /* Outputs gyroscope data; */
    memcpy((void *)pMsg->data, (void *)g_IMU1.gyroData, sizeof(g_IMU1.gyroData));
 80041fe:	4a55      	ldr	r2, [pc, #340]	; (8004354 <telemetryReadSerialData+0x544>)
 8004200:	e794      	b.n	800412c <telemetryReadSerialData+0x31c>
    memcpy((void *)pMsg->data, (void *)&g_i2cErrorInfo, sizeof(g_i2cErrorInfo));
    pMsg->size = sizeof(g_i2cErrorInfo) + TELEMETRY_MSG_SVC_SIZE;
    pMsg->crc  = telemetryGetCRC32Checksum(pMsg);
    break;
  case 'f': /* Outputs complementary filter settings; */
    memcpy((void *)pMsg->data, (void *)&g_cfSettings, sizeof(g_cfSettings));
 8004202:	4a55      	ldr	r2, [pc, #340]	; (8004358 <telemetryReadSerialData+0x548>)
 8004204:	4b4e      	ldr	r3, [pc, #312]	; (8004340 <telemetryReadSerialData+0x530>)
 8004206:	6810      	ldr	r0, [r2, #0]
    pMsg->size = sizeof(g_cfSettings) + TELEMETRY_MSG_SVC_SIZE;
 8004208:	220c      	movs	r2, #12
    memcpy((void *)pMsg->data, (void *)&g_i2cErrorInfo, sizeof(g_i2cErrorInfo));
    pMsg->size = sizeof(g_i2cErrorInfo) + TELEMETRY_MSG_SVC_SIZE;
    pMsg->crc  = telemetryGetCRC32Checksum(pMsg);
    break;
  case 'f': /* Outputs complementary filter settings; */
    memcpy((void *)pMsg->data, (void *)&g_cfSettings, sizeof(g_cfSettings));
 800420a:	6018      	str	r0, [r3, #0]
    pMsg->size = sizeof(g_cfSettings) + TELEMETRY_MSG_SVC_SIZE;
    pMsg->crc  = telemetryGetCRC32Checksum(pMsg);
 800420c:	1f18      	subs	r0, r3, #4
    pMsg->size = sizeof(g_i2cErrorInfo) + TELEMETRY_MSG_SVC_SIZE;
    pMsg->crc  = telemetryGetCRC32Checksum(pMsg);
    break;
  case 'f': /* Outputs complementary filter settings; */
    memcpy((void *)pMsg->data, (void *)&g_cfSettings, sizeof(g_cfSettings));
    pMsg->size = sizeof(g_cfSettings) + TELEMETRY_MSG_SVC_SIZE;
 800420e:	70a2      	strb	r2, [r4, #2]
    pMsg->crc  = telemetryGetCRC32Checksum(pMsg);
 8004210:	f7ff fda6 	bl	8003d60 <telemetryGetCRC32Checksum>
 8004214:	f8c4 0084 	str.w	r0, [r4, #132]	; 0x84
 8004218:	e716      	b.n	8004048 <telemetryReadSerialData+0x238>
    memcpy((void *)pMsg->data, (void *)g_sensorSettings, sizeof(g_sensorSettings));
    pMsg->size = sizeof(g_sensorSettings) + TELEMETRY_MSG_SVC_SIZE;
    pMsg->crc  = telemetryGetCRC32Checksum(pMsg);
    break;
  case 'e': /* Outputs I2C error info structure; */
    memcpy((void *)pMsg->data, (void *)&g_i2cErrorInfo, sizeof(g_i2cErrorInfo));
 800421a:	4a50      	ldr	r2, [pc, #320]	; (800435c <telemetryReadSerialData+0x54c>)
 800421c:	4b48      	ldr	r3, [pc, #288]	; (8004340 <telemetryReadSerialData+0x530>)
 800421e:	6810      	ldr	r0, [r2, #0]
 8004220:	6851      	ldr	r1, [r2, #4]
    pMsg->size = sizeof(g_i2cErrorInfo) + TELEMETRY_MSG_SVC_SIZE;
 8004222:	2210      	movs	r2, #16
    memcpy((void *)pMsg->data, (void *)g_sensorSettings, sizeof(g_sensorSettings));
    pMsg->size = sizeof(g_sensorSettings) + TELEMETRY_MSG_SVC_SIZE;
    pMsg->crc  = telemetryGetCRC32Checksum(pMsg);
    break;
  case 'e': /* Outputs I2C error info structure; */
    memcpy((void *)pMsg->data, (void *)&g_i2cErrorInfo, sizeof(g_i2cErrorInfo));
 8004224:	c303      	stmia	r3!, {r0, r1}
    pMsg->size = sizeof(g_i2cErrorInfo) + TELEMETRY_MSG_SVC_SIZE;
    pMsg->crc  = telemetryGetCRC32Checksum(pMsg);
 8004226:	f1a3 000c 	sub.w	r0, r3, #12
    pMsg->size = sizeof(g_sensorSettings) + TELEMETRY_MSG_SVC_SIZE;
    pMsg->crc  = telemetryGetCRC32Checksum(pMsg);
    break;
  case 'e': /* Outputs I2C error info structure; */
    memcpy((void *)pMsg->data, (void *)&g_i2cErrorInfo, sizeof(g_i2cErrorInfo));
    pMsg->size = sizeof(g_i2cErrorInfo) + TELEMETRY_MSG_SVC_SIZE;
 800422a:	70a2      	strb	r2, [r4, #2]
    pMsg->crc  = telemetryGetCRC32Checksum(pMsg);
 800422c:	f7ff fd98 	bl	8003d60 <telemetryGetCRC32Checksum>
 8004230:	f8c4 0084 	str.w	r0, [r4, #132]	; 0x84
 8004234:	e708      	b.n	8004048 <telemetryReadSerialData+0x238>
      telemetryNegativeResponse(pMsg);
    }
    break;
  case 'd': /* Outputs sensor settings; */
    /* Clean data buffer for zero-padded crc32 checksum calculation. */
    memset((void *)pMsg->data, 0, TELEMETRY_BUFFER_SIZE);
 8004236:	f8df a108 	ldr.w	sl, [pc, #264]	; 8004340 <telemetryReadSerialData+0x530>
 800423a:	2100      	movs	r1, #0
 800423c:	2280      	movs	r2, #128	; 0x80
 800423e:	4650      	mov	r0, sl
 8004240:	f000 f9ae 	bl	80045a0 <memset>
    memcpy((void *)pMsg->data, (void *)g_sensorSettings, sizeof(g_sensorSettings));
 8004244:	4b46      	ldr	r3, [pc, #280]	; (8004360 <telemetryReadSerialData+0x550>)
    pMsg->size = sizeof(g_sensorSettings) + TELEMETRY_MSG_SVC_SIZE;
    pMsg->crc  = telemetryGetCRC32Checksum(pMsg);
 8004246:	f1aa 0004 	sub.w	r0, sl, #4
    }
    break;
  case 'd': /* Outputs sensor settings; */
    /* Clean data buffer for zero-padded crc32 checksum calculation. */
    memset((void *)pMsg->data, 0, TELEMETRY_BUFFER_SIZE);
    memcpy((void *)pMsg->data, (void *)g_sensorSettings, sizeof(g_sensorSettings));
 800424a:	8819      	ldrh	r1, [r3, #0]
 800424c:	789a      	ldrb	r2, [r3, #2]
 800424e:	f8aa 1000 	strh.w	r1, [sl]
    pMsg->size = sizeof(g_sensorSettings) + TELEMETRY_MSG_SVC_SIZE;
 8004252:	230b      	movs	r3, #11
    }
    break;
  case 'd': /* Outputs sensor settings; */
    /* Clean data buffer for zero-padded crc32 checksum calculation. */
    memset((void *)pMsg->data, 0, TELEMETRY_BUFFER_SIZE);
    memcpy((void *)pMsg->data, (void *)g_sensorSettings, sizeof(g_sensorSettings));
 8004254:	f88a 2002 	strb.w	r2, [sl, #2]
    pMsg->size = sizeof(g_sensorSettings) + TELEMETRY_MSG_SVC_SIZE;
 8004258:	70a3      	strb	r3, [r4, #2]
    pMsg->crc  = telemetryGetCRC32Checksum(pMsg);
 800425a:	f7ff fd81 	bl	8003d60 <telemetryGetCRC32Checksum>
 800425e:	f8c4 0084 	str.w	r0, [r4, #132]	; 0x84
 8004262:	e6f1      	b.n	8004048 <telemetryReadSerialData+0x238>
    memcpy((void *)pMsg->data, (void *)&g_boardStatus, sizeof(g_boardStatus));
    pMsg->size = sizeof(g_boardStatus) + TELEMETRY_MSG_SVC_SIZE;
    pMsg->crc  = telemetryGetCRC32Checksum(pMsg);
    break;
  case 'c': /* Saves settings to FLASH; */
    if (saveSettings()==SUCCESS) {
 8004264:	f000 f88c 	bl	8004380 <saveSettings>
 8004268:	2801      	cmp	r0, #1
 800426a:	f47f aeeb 	bne.w	8004044 <telemetryReadSerialData+0x234>
    imuCalibrationSet(IMU1_CALIBRATE_GYRO);
    telemetryPositiveResponse(pMsg);
    break;
  case ']': /* Calibrate accelerometer. */
    imuCalibrationSet(IMU1_CALIBRATE_ACCEL);
    telemetryPositiveResponse(pMsg);
 800426e:	f7ff fdbf 	bl	8003df0 <telemetryPositiveResponse.constprop.2>
 8004272:	e6e9      	b.n	8004048 <telemetryReadSerialData+0x238>
    memcpy((void *)pMsg->data, (void *)g_IMU1.accelData, sizeof(g_IMU1.accelData));
    pMsg->size = sizeof(g_IMU1.accelData) + TELEMETRY_MSG_SVC_SIZE;
    pMsg->crc  = telemetryGetCRC32Checksum(pMsg);
    break;
  case 'b': /* Outputs board status; */
    memcpy((void *)pMsg->data, (void *)&g_boardStatus, sizeof(g_boardStatus));
 8004274:	4a3b      	ldr	r2, [pc, #236]	; (8004364 <telemetryReadSerialData+0x554>)
    pMsg->size = sizeof(g_boardStatus) + TELEMETRY_MSG_SVC_SIZE;
 8004276:	230c      	movs	r3, #12
    memcpy((void *)pMsg->data, (void *)g_IMU1.accelData, sizeof(g_IMU1.accelData));
    pMsg->size = sizeof(g_IMU1.accelData) + TELEMETRY_MSG_SVC_SIZE;
    pMsg->crc  = telemetryGetCRC32Checksum(pMsg);
    break;
  case 'b': /* Outputs board status; */
    memcpy((void *)pMsg->data, (void *)&g_boardStatus, sizeof(g_boardStatus));
 8004278:	6812      	ldr	r2, [r2, #0]
    pMsg->size = sizeof(g_boardStatus) + TELEMETRY_MSG_SVC_SIZE;
    pMsg->crc  = telemetryGetCRC32Checksum(pMsg);
 800427a:	483b      	ldr	r0, [pc, #236]	; (8004368 <telemetryReadSerialData+0x558>)
    memcpy((void *)pMsg->data, (void *)g_IMU1.accelData, sizeof(g_IMU1.accelData));
    pMsg->size = sizeof(g_IMU1.accelData) + TELEMETRY_MSG_SVC_SIZE;
    pMsg->crc  = telemetryGetCRC32Checksum(pMsg);
    break;
  case 'b': /* Outputs board status; */
    memcpy((void *)pMsg->data, (void *)&g_boardStatus, sizeof(g_boardStatus));
 800427c:	6062      	str	r2, [r4, #4]
    pMsg->size = sizeof(g_boardStatus) + TELEMETRY_MSG_SVC_SIZE;
 800427e:	70a3      	strb	r3, [r4, #2]
    pMsg->crc  = telemetryGetCRC32Checksum(pMsg);
 8004280:	f7ff fd6e 	bl	8003d60 <telemetryGetCRC32Checksum>
 8004284:	f8c4 0084 	str.w	r0, [r4, #132]	; 0x84
 8004288:	e6de      	b.n	8004048 <telemetryReadSerialData+0x238>
    } else {
      telemetryNegativeResponse(pMsg);
    }
    break;
  case 'a': /* Outputs accelerometer data; */
    memcpy((void *)pMsg->data, (void *)g_IMU1.accelData, sizeof(g_IMU1.accelData));
 800428a:	4a38      	ldr	r2, [pc, #224]	; (800436c <telemetryReadSerialData+0x55c>)
 800428c:	e74e      	b.n	800412c <telemetryReadSerialData+0x31c>
  case '[': /* Calibrate gyroscope. */
    imuCalibrationSet(IMU1_CALIBRATE_GYRO);
    telemetryPositiveResponse(pMsg);
    break;
  case ']': /* Calibrate accelerometer. */
    imuCalibrationSet(IMU1_CALIBRATE_ACCEL);
 800428e:	2010      	movs	r0, #16
 8004290:	f7ff fd36 	bl	8003d00 <imuCalibrationSet>
 8004294:	e7eb      	b.n	800426e <telemetryReadSerialData+0x45e>
    memcpy((void *)pMsg->data, (void *)g_pidSettings, sizeof(g_pidSettings));
    pMsg->size = sizeof(g_pidSettings) + TELEMETRY_MSG_SVC_SIZE;
    pMsg->crc  = telemetryGetCRC32Checksum(pMsg);
    break;
  case '[': /* Calibrate gyroscope. */
    imuCalibrationSet(IMU1_CALIBRATE_GYRO);
 8004296:	2008      	movs	r0, #8
 8004298:	f7ff fd32 	bl	8003d00 <imuCalibrationSet>
    telemetryPositiveResponse(pMsg);
 800429c:	f7ff fda8 	bl	8003df0 <telemetryPositiveResponse.constprop.2>
 80042a0:	e6d2      	b.n	8004048 <telemetryReadSerialData+0x238>
    } else {
      telemetryNegativeResponse(pMsg);
    }
    break;
  case 'Z': /* Reads new streaming data id; */
    if ((pMsg->size - TELEMETRY_MSG_SVC_SIZE) == sizeof(uint8_t)) {
 80042a2:	78a3      	ldrb	r3, [r4, #2]
 80042a4:	2b09      	cmp	r3, #9
 80042a6:	f47f aecd 	bne.w	8004044 <telemetryReadSerialData+0x234>
      g_streamDataID = pMsg->data[0];
 80042aa:	4931      	ldr	r1, [pc, #196]	; (8004370 <telemetryReadSerialData+0x560>)
 80042ac:	7928      	ldrb	r0, [r5, #4]
      g_streamIdx    = 0; /* Reset index. */
 80042ae:	4b31      	ldr	r3, [pc, #196]	; (8004374 <telemetryReadSerialData+0x564>)
 80042b0:	2200      	movs	r2, #0
      telemetryNegativeResponse(pMsg);
    }
    break;
  case 'Z': /* Reads new streaming data id; */
    if ((pMsg->size - TELEMETRY_MSG_SVC_SIZE) == sizeof(uint8_t)) {
      g_streamDataID = pMsg->data[0];
 80042b2:	7008      	strb	r0, [r1, #0]
      g_streamIdx    = 0; /* Reset index. */
 80042b4:	701a      	strb	r2, [r3, #0]
      telemetryPositiveResponse(pMsg);
 80042b6:	f7ff fd9b 	bl	8003df0 <telemetryPositiveResponse.constprop.2>
 80042ba:	e6c5      	b.n	8004048 <telemetryReadSerialData+0x238>
    pMsg->size = debugMsg.size;
    pMsg->crc  = telemetryGetCRC32Checksum(&debugMsg);
    debugMsg.size = 0;
    break;
  case 'X': /* Hard reset the board. */
    telemetryPositiveResponse(pMsg);
 80042bc:	f7ff fd98 	bl	8003df0 <telemetryPositiveResponse.constprop.2>
    g_runMain = FALSE;
 80042c0:	4b2d      	ldr	r3, [pc, #180]	; (8004378 <telemetryReadSerialData+0x568>)
 80042c2:	2200      	movs	r2, #0
 80042c4:	701a      	strb	r2, [r3, #0]
 80042c6:	e6bf      	b.n	8004048 <telemetryReadSerialData+0x238>
    } else {
      telemetryNegativeResponse(pMsg);
    }
    break;
  case 'S': /* Reads new PID values; */
    if ((pMsg->size - TELEMETRY_MSG_SVC_SIZE) == sizeof(g_pidSettings)) {
 80042c8:	78a3      	ldrb	r3, [r4, #2]
 80042ca:	2b11      	cmp	r3, #17
 80042cc:	f47f aeba 	bne.w	8004044 <telemetryReadSerialData+0x234>
      pidSettingsUpdate((PPIDSettings)pMsg->data);
 80042d0:	481b      	ldr	r0, [pc, #108]	; (8004340 <telemetryReadSerialData+0x530>)
 80042d2:	f7ff fc5d 	bl	8003b90 <pidSettingsUpdate>
      telemetryPositiveResponse(pMsg);
 80042d6:	f7ff fd8b 	bl	8003df0 <telemetryPositiveResponse.constprop.2>
 80042da:	e6b5      	b.n	8004048 <telemetryReadSerialData+0x238>
    } else {
      telemetryNegativeResponse(pMsg);
    }
    break;
  case 'O': /* Reads new output settings; */
    if ((pMsg->size - TELEMETRY_MSG_SVC_SIZE) == sizeof(g_pwmOutput)) {
 80042dc:	78a3      	ldrb	r3, [r4, #2]
 80042de:	2b14      	cmp	r3, #20
 80042e0:	f47f aeb0 	bne.w	8004044 <telemetryReadSerialData+0x234>
      pwmOutputSettingsUpdate((PPWMOutputStruct)pMsg->data);
 80042e4:	4816      	ldr	r0, [pc, #88]	; (8004340 <telemetryReadSerialData+0x530>)
 80042e6:	f7ff f8c3 	bl	8003470 <pwmOutputSettingsUpdate>
      telemetryPositiveResponse(pMsg);
 80042ea:	f7ff fd81 	bl	8003df0 <telemetryPositiveResponse.constprop.2>
 80042ee:	e6ab      	b.n	8004048 <telemetryReadSerialData+0x238>
    } else {
      telemetryNegativeResponse(pMsg);
    }
    break;
  case 'M': /* Reads new input mode settings; */
    if ((pMsg->size - TELEMETRY_MSG_SVC_SIZE) == sizeof(g_modeSettings)) {
 80042f0:	78a3      	ldrb	r3, [r4, #2]
 80042f2:	2b20      	cmp	r3, #32
 80042f4:	f47f aea6 	bne.w	8004044 <telemetryReadSerialData+0x234>
      inputModeSettingsUpdate((PInputModeStruct)pMsg->data);
 80042f8:	4811      	ldr	r0, [pc, #68]	; (8004340 <telemetryReadSerialData+0x530>)
 80042fa:	f7ff fc59 	bl	8003bb0 <inputModeSettingsUpdate>
      telemetryPositiveResponse(pMsg);
 80042fe:	f7ff fd77 	bl	8003df0 <telemetryPositiveResponse.constprop.2>
 8004302:	e6a1      	b.n	8004048 <telemetryReadSerialData+0x238>
    } else {
      telemetryNegativeResponse(pMsg);
    }
    break;
  case 'I': /* Reads new mixed input settings; */
    if ((pMsg->size - TELEMETRY_MSG_SVC_SIZE) == sizeof(g_mixedInput)) {
 8004304:	78a3      	ldrb	r3, [r4, #2]
 8004306:	2b1d      	cmp	r3, #29
 8004308:	f47f ae9c 	bne.w	8004044 <telemetryReadSerialData+0x234>
      mixedInputSettingsUpdate((PMixedInputStruct)pMsg->data);
 800430c:	480c      	ldr	r0, [pc, #48]	; (8004340 <telemetryReadSerialData+0x530>)
 800430e:	f7ff f8bf 	bl	8003490 <mixedInputSettingsUpdate>
      telemetryPositiveResponse(pMsg);
 8004312:	f7ff fd6d 	bl	8003df0 <telemetryPositiveResponse.constprop.2>
 8004316:	e697      	b.n	8004048 <telemetryReadSerialData+0x238>
    } else {
      telemetryNegativeResponse(pMsg);
    }
    break;
  case 'F': /* Reads new complementary filter settings; */
    if ((pMsg->size - TELEMETRY_MSG_SVC_SIZE) == sizeof(g_cfSettings)) {
 8004318:	78a3      	ldrb	r3, [r4, #2]
 800431a:	2b0c      	cmp	r3, #12
 800431c:	f47f ae92 	bne.w	8004044 <telemetryReadSerialData+0x234>
      cfSettingsUpdate((uint16_t *)pMsg->data);
 8004320:	4807      	ldr	r0, [pc, #28]	; (8004340 <telemetryReadSerialData+0x530>)
 8004322:	f7ff fc55 	bl	8003bd0 <cfSettingsUpdate>
      telemetryPositiveResponse(pMsg);
 8004326:	f7ff fd63 	bl	8003df0 <telemetryPositiveResponse.constprop.2>
 800432a:	e68d      	b.n	8004048 <telemetryReadSerialData+0x238>
static void telemetryProcessCommand(const PMessage pMsg) {
  //chnWrite(g_chnp, "otrzymao" + pMsg->msg_id, 20);
    
  switch (pMsg->msg_id) {
  case 'D': /* Reads new sensor settings; */
    if ((pMsg->size - TELEMETRY_MSG_SVC_SIZE) == sizeof(g_sensorSettings)) {
 800432c:	78a3      	ldrb	r3, [r4, #2]
 800432e:	2b0b      	cmp	r3, #11
 8004330:	f47f ae88 	bne.w	8004044 <telemetryReadSerialData+0x234>
      sensorSettingsUpdate((uint8_t *)pMsg->data);
 8004334:	4802      	ldr	r0, [pc, #8]	; (8004340 <telemetryReadSerialData+0x530>)
 8004336:	f7ff fcf3 	bl	8003d20 <sensorSettingsUpdate>
      telemetryPositiveResponse(pMsg);
 800433a:	f7ff fd59 	bl	8003df0 <telemetryPositiveResponse.constprop.2>
 800433e:	e683      	b.n	8004048 <telemetryReadSerialData+0x238>
 8004340:	20000860 	.word	0x20000860
 8004344:	20000800 	.word	0x20000800
 8004348:	20001050 	.word	0x20001050
 800434c:	20000d6c 	.word	0x20000d6c
 8004350:	20000dc0 	.word	0x20000dc0
 8004354:	20000ff0 	.word	0x20000ff0
 8004358:	20000828 	.word	0x20000828
 800435c:	20000dd4 	.word	0x20000dd4
 8004360:	20000858 	.word	0x20000858
 8004364:	20000dd0 	.word	0x20000dd0
 8004368:	2000085c 	.word	0x2000085c
 800436c:	20000fe4 	.word	0x20000fe4
 8004370:	20000ddc 	.word	0x20000ddc
 8004374:	20000dcc 	.word	0x20000dcc
 8004378:	20000854 	.word	0x20000854
 800437c:	2000083c 	.word	0x2000083c

08004380 <saveSettings>:
 * @brief  Starts saving all user defined settings to external EEPROM chip.
 * @return 1 - if write operation is successful;
 *         0 - if write operation fails.
 */
uint8_t saveSettings(void) {
  memcpy((void *)paramsData.pidSettings, (void *)g_pidSettings, sizeof(g_pidSettings));
 8004380:	4a47      	ldr	r2, [pc, #284]	; (80044a0 <saveSettings+0x120>)
/**
 * @brief  Starts saving all user defined settings to external EEPROM chip.
 * @return 1 - if write operation is successful;
 *         0 - if write operation fails.
 */
uint8_t saveSettings(void) {
 8004382:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  memcpy((void *)paramsData.pidSettings, (void *)g_pidSettings, sizeof(g_pidSettings));
 8004386:	4616      	mov	r6, r2
  memcpy((void *)paramsData.pwmOutput, (void *)g_pwmOutput, sizeof(g_pwmOutput));
  memcpy((void *)paramsData.mixedInput, (void *)g_mixedInput, sizeof(g_mixedInput));
  memcpy((void *)paramsData.modeSettings, (void *)g_modeSettings, sizeof(g_modeSettings));
  memcpy((void *)paramsData.sensorSettings, (void *)g_sensorSettings, sizeof(g_sensorSettings));
  memcpy((void *)paramsData.cfSettings, (void *)g_cfSettings, sizeof(g_cfSettings));
  memcpy((void *)paramsData.accelBias, (void *)g_IMU1.accelBias, sizeof(g_IMU1.accelBias));
 8004388:	4f46      	ldr	r7, [pc, #280]	; (80044a4 <saveSettings+0x124>)
 * @retval 32-bit CRC
 */
static inline uint32_t crcCRC32(const uint32_t pBuf[], uint32_t length) {
  uint32_t i;
  /* Resets CRC generator. */
  CRC->CR = CRC_CR_RESET;
 800438a:	f8df 912c 	ldr.w	r9, [pc, #300]	; 80044b8 <saveSettings+0x138>
  memcpy((void *)paramsData.gyroBias, (void *)g_IMU1.gyroBias, sizeof(g_IMU1.gyroBias));
 800438e:	46be      	mov	lr, r7
  /* Calculates CRC32 checksum. */
  for(i = 0; i < length; i++) {
    CRC->DR = pBuf[i];
 8004390:	464b      	mov	r3, r9
 * @brief  Starts saving all user defined settings to external EEPROM chip.
 * @return 1 - if write operation is successful;
 *         0 - if write operation fails.
 */
uint8_t saveSettings(void) {
  memcpy((void *)paramsData.pidSettings, (void *)g_pidSettings, sizeof(g_pidSettings));
 8004392:	f8df a12c 	ldr.w	sl, [pc, #300]	; 80044c0 <saveSettings+0x140>
  memcpy((void *)paramsData.pwmOutput, (void *)g_pwmOutput, sizeof(g_pwmOutput));
  memcpy((void *)paramsData.mixedInput, (void *)g_mixedInput, sizeof(g_mixedInput));
 8004396:	4d44      	ldr	r5, [pc, #272]	; (80044a8 <saveSettings+0x128>)
 * @brief  Starts saving all user defined settings to external EEPROM chip.
 * @return 1 - if write operation is successful;
 *         0 - if write operation fails.
 */
uint8_t saveSettings(void) {
  memcpy((void *)paramsData.pidSettings, (void *)g_pidSettings, sizeof(g_pidSettings));
 8004398:	f8da 0000 	ldr.w	r0, [sl]
 800439c:	f8da 1004 	ldr.w	r1, [sl, #4]
  memcpy((void *)paramsData.pwmOutput, (void *)g_pwmOutput, sizeof(g_pwmOutput));
  memcpy((void *)paramsData.mixedInput, (void *)g_mixedInput, sizeof(g_mixedInput));
  memcpy((void *)paramsData.modeSettings, (void *)g_modeSettings, sizeof(g_modeSettings));
 80043a0:	4c42      	ldr	r4, [pc, #264]	; (80044ac <saveSettings+0x12c>)
 *         0 - if write operation fails.
 */
uint8_t saveSettings(void) {
  memcpy((void *)paramsData.pidSettings, (void *)g_pidSettings, sizeof(g_pidSettings));
  memcpy((void *)paramsData.pwmOutput, (void *)g_pwmOutput, sizeof(g_pwmOutput));
  memcpy((void *)paramsData.mixedInput, (void *)g_mixedInput, sizeof(g_mixedInput));
 80043a2:	f8d5 c000 	ldr.w	ip, [r5]
 * @brief  Starts saving all user defined settings to external EEPROM chip.
 * @return 1 - if write operation is successful;
 *         0 - if write operation fails.
 */
uint8_t saveSettings(void) {
  memcpy((void *)paramsData.pidSettings, (void *)g_pidSettings, sizeof(g_pidSettings));
 80043a6:	c603      	stmia	r6!, {r0, r1}
  memcpy((void *)paramsData.pwmOutput, (void *)g_pwmOutput, sizeof(g_pwmOutput));
 80043a8:	f8df 8118 	ldr.w	r8, [pc, #280]	; 80044c4 <saveSettings+0x144>
  memcpy((void *)paramsData.mixedInput, (void *)g_mixedInput, sizeof(g_mixedInput));
  memcpy((void *)paramsData.modeSettings, (void *)g_modeSettings, sizeof(g_modeSettings));
 80043ac:	6821      	ldr	r1, [r4, #0]
 *         0 - if write operation fails.
 */
uint8_t saveSettings(void) {
  memcpy((void *)paramsData.pidSettings, (void *)g_pidSettings, sizeof(g_pidSettings));
  memcpy((void *)paramsData.pwmOutput, (void *)g_pwmOutput, sizeof(g_pwmOutput));
  memcpy((void *)paramsData.mixedInput, (void *)g_mixedInput, sizeof(g_mixedInput));
 80043ae:	f8c2 c015 	str.w	ip, [r2, #21]
 * @brief  Starts saving all user defined settings to external EEPROM chip.
 * @return 1 - if write operation is successful;
 *         0 - if write operation fails.
 */
uint8_t saveSettings(void) {
  memcpy((void *)paramsData.pidSettings, (void *)g_pidSettings, sizeof(g_pidSettings));
 80043b2:	f89a c008 	ldrb.w	ip, [sl, #8]
  memcpy((void *)paramsData.pwmOutput, (void *)g_pwmOutput, sizeof(g_pwmOutput));
 80043b6:	f8d8 b000 	ldr.w	fp, [r8]
 * @brief  Starts saving all user defined settings to external EEPROM chip.
 * @return 1 - if write operation is successful;
 *         0 - if write operation fails.
 */
uint8_t saveSettings(void) {
  memcpy((void *)paramsData.pidSettings, (void *)g_pidSettings, sizeof(g_pidSettings));
 80043ba:	f886 c000 	strb.w	ip, [r6]
  memcpy((void *)paramsData.pwmOutput, (void *)g_pwmOutput, sizeof(g_pwmOutput));
 80043be:	f8d8 a004 	ldr.w	sl, [r8, #4]
 80043c2:	f8d8 0008 	ldr.w	r0, [r8, #8]
  memcpy((void *)paramsData.mixedInput, (void *)g_mixedInput, sizeof(g_mixedInput));
 80043c6:	68ee      	ldr	r6, [r5, #12]
 80043c8:	f8d5 c010 	ldr.w	ip, [r5, #16]
 80043cc:	f8d5 8004 	ldr.w	r8, [r5, #4]
  memcpy((void *)paramsData.modeSettings, (void *)g_modeSettings, sizeof(g_modeSettings));
 80043d0:	f8c2 102a 	str.w	r1, [r2, #42]	; 0x2a
 *         0 - if write operation fails.
 */
uint8_t saveSettings(void) {
  memcpy((void *)paramsData.pidSettings, (void *)g_pidSettings, sizeof(g_pidSettings));
  memcpy((void *)paramsData.pwmOutput, (void *)g_pwmOutput, sizeof(g_pwmOutput));
  memcpy((void *)paramsData.mixedInput, (void *)g_mixedInput, sizeof(g_mixedInput));
 80043d4:	68a9      	ldr	r1, [r5, #8]
 80043d6:	7d2d      	ldrb	r5, [r5, #20]
/**
 * @brief  Starts saving all user defined settings to external EEPROM chip.
 * @return 1 - if write operation is successful;
 *         0 - if write operation fails.
 */
uint8_t saveSettings(void) {
 80043d8:	b083      	sub	sp, #12
  memcpy((void *)paramsData.pidSettings, (void *)g_pidSettings, sizeof(g_pidSettings));
  memcpy((void *)paramsData.pwmOutput, (void *)g_pwmOutput, sizeof(g_pwmOutput));
  memcpy((void *)paramsData.mixedInput, (void *)g_mixedInput, sizeof(g_mixedInput));
 80043da:	9501      	str	r5, [sp, #4]
 * @return 1 - if write operation is successful;
 *         0 - if write operation fails.
 */
uint8_t saveSettings(void) {
  memcpy((void *)paramsData.pidSettings, (void *)g_pidSettings, sizeof(g_pidSettings));
  memcpy((void *)paramsData.pwmOutput, (void *)g_pwmOutput, sizeof(g_pwmOutput));
 80043dc:	f8c2 a00d 	str.w	sl, [r2, #13]
  memcpy((void *)paramsData.mixedInput, (void *)g_mixedInput, sizeof(g_mixedInput));
  memcpy((void *)paramsData.modeSettings, (void *)g_modeSettings, sizeof(g_modeSettings));
 80043e0:	6865      	ldr	r5, [r4, #4]
 80043e2:	f8d4 a008 	ldr.w	sl, [r4, #8]
 *         0 - if write operation fails.
 */
uint8_t saveSettings(void) {
  memcpy((void *)paramsData.pidSettings, (void *)g_pidSettings, sizeof(g_pidSettings));
  memcpy((void *)paramsData.pwmOutput, (void *)g_pwmOutput, sizeof(g_pwmOutput));
  memcpy((void *)paramsData.mixedInput, (void *)g_mixedInput, sizeof(g_mixedInput));
 80043e6:	f8c2 101d 	str.w	r1, [r2, #29]
 80043ea:	f89d 1004 	ldrb.w	r1, [sp, #4]
 * @return 1 - if write operation is successful;
 *         0 - if write operation fails.
 */
uint8_t saveSettings(void) {
  memcpy((void *)paramsData.pidSettings, (void *)g_pidSettings, sizeof(g_pidSettings));
  memcpy((void *)paramsData.pwmOutput, (void *)g_pwmOutput, sizeof(g_pwmOutput));
 80043ee:	f8c2 b009 	str.w	fp, [r2, #9]
 80043f2:	f8c2 0011 	str.w	r0, [r2, #17]
  memcpy((void *)paramsData.mixedInput, (void *)g_mixedInput, sizeof(g_mixedInput));
  memcpy((void *)paramsData.modeSettings, (void *)g_modeSettings, sizeof(g_modeSettings));
 80043f6:	f8d4 b00c 	ldr.w	fp, [r4, #12]
  memcpy((void *)paramsData.sensorSettings, (void *)g_sensorSettings, sizeof(g_sensorSettings));
 80043fa:	482d      	ldr	r0, [pc, #180]	; (80044b0 <saveSettings+0x130>)
 *         0 - if write operation fails.
 */
uint8_t saveSettings(void) {
  memcpy((void *)paramsData.pidSettings, (void *)g_pidSettings, sizeof(g_pidSettings));
  memcpy((void *)paramsData.pwmOutput, (void *)g_pwmOutput, sizeof(g_pwmOutput));
  memcpy((void *)paramsData.mixedInput, (void *)g_mixedInput, sizeof(g_mixedInput));
 80043fc:	f8c2 6021 	str.w	r6, [r2, #33]	; 0x21
 8004400:	f8c2 c025 	str.w	ip, [r2, #37]	; 0x25
 8004404:	f882 1029 	strb.w	r1, [r2, #41]	; 0x29
  memcpy((void *)paramsData.modeSettings, (void *)g_modeSettings, sizeof(g_modeSettings));
 8004408:	f8c2 502e 	str.w	r5, [r2, #46]	; 0x2e
  memcpy((void *)paramsData.sensorSettings, (void *)g_sensorSettings, sizeof(g_sensorSettings));
  memcpy((void *)paramsData.cfSettings, (void *)g_cfSettings, sizeof(g_cfSettings));
 800440c:	4e29      	ldr	r6, [pc, #164]	; (80044b4 <saveSettings+0x134>)
 *         0 - if write operation fails.
 */
uint8_t saveSettings(void) {
  memcpy((void *)paramsData.pidSettings, (void *)g_pidSettings, sizeof(g_pidSettings));
  memcpy((void *)paramsData.pwmOutput, (void *)g_pwmOutput, sizeof(g_pwmOutput));
  memcpy((void *)paramsData.mixedInput, (void *)g_mixedInput, sizeof(g_mixedInput));
 800440e:	f8c2 8019 	str.w	r8, [r2, #25]
  memcpy((void *)paramsData.modeSettings, (void *)g_modeSettings, sizeof(g_modeSettings));
 8004412:	f8c2 a032 	str.w	sl, [r2, #50]	; 0x32
 8004416:	6921      	ldr	r1, [r4, #16]
 8004418:	6965      	ldr	r5, [r4, #20]
  memcpy((void *)paramsData.sensorSettings, (void *)g_sensorSettings, sizeof(g_sensorSettings));
  memcpy((void *)paramsData.cfSettings, (void *)g_cfSettings, sizeof(g_cfSettings));
  memcpy((void *)paramsData.accelBias, (void *)g_IMU1.accelBias, sizeof(g_IMU1.accelBias));
  memcpy((void *)paramsData.gyroBias, (void *)g_IMU1.gyroBias, sizeof(g_IMU1.gyroBias));
 800441a:	f85e 4f0c 	ldr.w	r4, [lr, #12]!
 */
uint8_t saveSettings(void) {
  memcpy((void *)paramsData.pidSettings, (void *)g_pidSettings, sizeof(g_pidSettings));
  memcpy((void *)paramsData.pwmOutput, (void *)g_pwmOutput, sizeof(g_pwmOutput));
  memcpy((void *)paramsData.mixedInput, (void *)g_mixedInput, sizeof(g_mixedInput));
  memcpy((void *)paramsData.modeSettings, (void *)g_modeSettings, sizeof(g_modeSettings));
 800441e:	f8c2 b036 	str.w	fp, [r2, #54]	; 0x36
  memcpy((void *)paramsData.sensorSettings, (void *)g_sensorSettings, sizeof(g_sensorSettings));
 8004422:	f8b0 b000 	ldrh.w	fp, [r0]
 8004426:	f890 a002 	ldrb.w	sl, [r0, #2]
  memcpy((void *)paramsData.cfSettings, (void *)g_cfSettings, sizeof(g_cfSettings));
 800442a:	f8d6 c000 	ldr.w	ip, [r6]
  memcpy((void *)paramsData.accelBias, (void *)g_IMU1.accelBias, sizeof(g_IMU1.accelBias));
  memcpy((void *)paramsData.gyroBias, (void *)g_IMU1.gyroBias, sizeof(g_IMU1.gyroBias));
 800442e:	f8de 0004 	ldr.w	r0, [lr, #4]
  memcpy((void *)paramsData.pwmOutput, (void *)g_pwmOutput, sizeof(g_pwmOutput));
  memcpy((void *)paramsData.mixedInput, (void *)g_mixedInput, sizeof(g_mixedInput));
  memcpy((void *)paramsData.modeSettings, (void *)g_modeSettings, sizeof(g_modeSettings));
  memcpy((void *)paramsData.sensorSettings, (void *)g_sensorSettings, sizeof(g_sensorSettings));
  memcpy((void *)paramsData.cfSettings, (void *)g_cfSettings, sizeof(g_cfSettings));
  memcpy((void *)paramsData.accelBias, (void *)g_IMU1.accelBias, sizeof(g_IMU1.accelBias));
 8004432:	683e      	ldr	r6, [r7, #0]
  memcpy((void *)paramsData.gyroBias, (void *)g_IMU1.gyroBias, sizeof(g_IMU1.gyroBias));
 8004434:	f8de e008 	ldr.w	lr, [lr, #8]
 */
uint8_t saveSettings(void) {
  memcpy((void *)paramsData.pidSettings, (void *)g_pidSettings, sizeof(g_pidSettings));
  memcpy((void *)paramsData.pwmOutput, (void *)g_pwmOutput, sizeof(g_pwmOutput));
  memcpy((void *)paramsData.mixedInput, (void *)g_mixedInput, sizeof(g_mixedInput));
  memcpy((void *)paramsData.modeSettings, (void *)g_modeSettings, sizeof(g_modeSettings));
 8004438:	f8c2 103a 	str.w	r1, [r2, #58]	; 0x3a
  memcpy((void *)paramsData.sensorSettings, (void *)g_sensorSettings, sizeof(g_sensorSettings));
  memcpy((void *)paramsData.cfSettings, (void *)g_cfSettings, sizeof(g_cfSettings));
  memcpy((void *)paramsData.accelBias, (void *)g_IMU1.accelBias, sizeof(g_IMU1.accelBias));
 800443c:	6879      	ldr	r1, [r7, #4]
 800443e:	68bf      	ldr	r7, [r7, #8]
uint8_t saveSettings(void) {
  memcpy((void *)paramsData.pidSettings, (void *)g_pidSettings, sizeof(g_pidSettings));
  memcpy((void *)paramsData.pwmOutput, (void *)g_pwmOutput, sizeof(g_pwmOutput));
  memcpy((void *)paramsData.mixedInput, (void *)g_mixedInput, sizeof(g_mixedInput));
  memcpy((void *)paramsData.modeSettings, (void *)g_modeSettings, sizeof(g_modeSettings));
  memcpy((void *)paramsData.sensorSettings, (void *)g_sensorSettings, sizeof(g_sensorSettings));
 8004440:	f8a2 b042 	strh.w	fp, [r2, #66]	; 0x42
 * @retval 32-bit CRC
 */
static inline uint32_t crcCRC32(const uint32_t pBuf[], uint32_t length) {
  uint32_t i;
  /* Resets CRC generator. */
  CRC->CR = CRC_CR_RESET;
 8004444:	f04f 0b01 	mov.w	fp, #1
 */
uint8_t saveSettings(void) {
  memcpy((void *)paramsData.pidSettings, (void *)g_pidSettings, sizeof(g_pidSettings));
  memcpy((void *)paramsData.pwmOutput, (void *)g_pwmOutput, sizeof(g_pwmOutput));
  memcpy((void *)paramsData.mixedInput, (void *)g_mixedInput, sizeof(g_mixedInput));
  memcpy((void *)paramsData.modeSettings, (void *)g_modeSettings, sizeof(g_modeSettings));
 8004448:	f8c2 503e 	str.w	r5, [r2, #62]	; 0x3e
  memcpy((void *)paramsData.sensorSettings, (void *)g_sensorSettings, sizeof(g_sensorSettings));
  memcpy((void *)paramsData.cfSettings, (void *)g_cfSettings, sizeof(g_cfSettings));
  memcpy((void *)paramsData.accelBias, (void *)g_IMU1.accelBias, sizeof(g_IMU1.accelBias));
 800444c:	f8c2 104d 	str.w	r1, [r2, #77]	; 0x4d
uint8_t saveSettings(void) {
  memcpy((void *)paramsData.pidSettings, (void *)g_pidSettings, sizeof(g_pidSettings));
  memcpy((void *)paramsData.pwmOutput, (void *)g_pwmOutput, sizeof(g_pwmOutput));
  memcpy((void *)paramsData.mixedInput, (void *)g_mixedInput, sizeof(g_mixedInput));
  memcpy((void *)paramsData.modeSettings, (void *)g_modeSettings, sizeof(g_modeSettings));
  memcpy((void *)paramsData.sensorSettings, (void *)g_sensorSettings, sizeof(g_sensorSettings));
 8004450:	f882 a044 	strb.w	sl, [r2, #68]	; 0x44
  memcpy((void *)paramsData.cfSettings, (void *)g_cfSettings, sizeof(g_cfSettings));
 8004454:	f8c2 c045 	str.w	ip, [r2, #69]	; 0x45
  memcpy((void *)paramsData.accelBias, (void *)g_IMU1.accelBias, sizeof(g_IMU1.accelBias));
 8004458:	f8c2 6049 	str.w	r6, [r2, #73]	; 0x49
  memcpy((void *)paramsData.gyroBias, (void *)g_IMU1.gyroBias, sizeof(g_IMU1.gyroBias));
 800445c:	f8c2 4055 	str.w	r4, [r2, #85]	; 0x55
 8004460:	f8c2 0059 	str.w	r0, [r2, #89]	; 0x59
 8004464:	f8c2 e05d 	str.w	lr, [r2, #93]	; 0x5d
  memcpy((void *)paramsData.pwmOutput, (void *)g_pwmOutput, sizeof(g_pwmOutput));
  memcpy((void *)paramsData.mixedInput, (void *)g_mixedInput, sizeof(g_mixedInput));
  memcpy((void *)paramsData.modeSettings, (void *)g_modeSettings, sizeof(g_modeSettings));
  memcpy((void *)paramsData.sensorSettings, (void *)g_sensorSettings, sizeof(g_sensorSettings));
  memcpy((void *)paramsData.cfSettings, (void *)g_cfSettings, sizeof(g_cfSettings));
  memcpy((void *)paramsData.accelBias, (void *)g_IMU1.accelBias, sizeof(g_IMU1.accelBias));
 8004468:	f8c2 7051 	str.w	r7, [r2, #81]	; 0x51
 800446c:	1f11      	subs	r1, r2, #4
 800446e:	f102 055c 	add.w	r5, r2, #92	; 0x5c
 8004472:	f8c9 b008 	str.w	fp, [r9, #8]
  /* Calculates CRC32 checksum. */
  for(i = 0; i < length; i++) {
    CRC->DR = pBuf[i];
 8004476:	f851 0f04 	ldr.w	r0, [r1, #4]!
 800447a:	4c0f      	ldr	r4, [pc, #60]	; (80044b8 <saveSettings+0x138>)
static inline uint32_t crcCRC32(const uint32_t pBuf[], uint32_t length) {
  uint32_t i;
  /* Resets CRC generator. */
  CRC->CR = CRC_CR_RESET;
  /* Calculates CRC32 checksum. */
  for(i = 0; i < length; i++) {
 800447c:	42a9      	cmp	r1, r5
    CRC->DR = pBuf[i];
 800447e:	6018      	str	r0, [r3, #0]
static inline uint32_t crcCRC32(const uint32_t pBuf[], uint32_t length) {
  uint32_t i;
  /* Resets CRC generator. */
  CRC->CR = CRC_CR_RESET;
  /* Calculates CRC32 checksum. */
  for(i = 0; i < length; i++) {
 8004480:	d1f9      	bne.n	8004476 <saveSettings+0xf6>
    CRC->DR = pBuf[i];
  }
  return CRC->DR;
 8004482:	6823      	ldr	r3, [r4, #0]
  memcpy((void *)paramsData.gyroBias, (void *)g_IMU1.gyroBias, sizeof(g_IMU1.gyroBias));
  paramsData.crc32 = crcCRC32((uint32_t *)&paramsData, sizeof(paramsData) / sizeof(uint32_t) - 1);

  flashPageErase(FLASH_PARAMS_PAGE);
 8004484:	207d      	movs	r0, #125	; 0x7d
  memcpy((void *)paramsData.modeSettings, (void *)g_modeSettings, sizeof(g_modeSettings));
  memcpy((void *)paramsData.sensorSettings, (void *)g_sensorSettings, sizeof(g_sensorSettings));
  memcpy((void *)paramsData.cfSettings, (void *)g_cfSettings, sizeof(g_cfSettings));
  memcpy((void *)paramsData.accelBias, (void *)g_IMU1.accelBias, sizeof(g_IMU1.accelBias));
  memcpy((void *)paramsData.gyroBias, (void *)g_IMU1.gyroBias, sizeof(g_IMU1.gyroBias));
  paramsData.crc32 = crcCRC32((uint32_t *)&paramsData, sizeof(paramsData) / sizeof(uint32_t) - 1);
 8004486:	f8c2 3061 	str.w	r3, [r2, #97]	; 0x61

  flashPageErase(FLASH_PARAMS_PAGE);
 800448a:	f7ff fa69 	bl	8003960 <flashPageErase>
  return flashWrite((flashaddr_t) FLASH_ADDRESS_OF_PAGE(FLASH_PARAMS_PAGE), (char*) &paramsData, sizeof(paramsData));
 800448e:	4904      	ldr	r1, [pc, #16]	; (80044a0 <saveSettings+0x120>)
 8004490:	2265      	movs	r2, #101	; 0x65
 8004492:	480a      	ldr	r0, [pc, #40]	; (80044bc <saveSettings+0x13c>)
 8004494:	f7ff fab4 	bl	8003a00 <flashWrite>
}
 8004498:	b2c0      	uxtb	r0, r0
 800449a:	b003      	add	sp, #12
 800449c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80044a0:	200010dc 	.word	0x200010dc
 80044a4:	20000ffc 	.word	0x20000ffc
 80044a8:	2000080c 	.word	0x2000080c
 80044ac:	2000083c 	.word	0x2000083c
 80044b0:	20000858 	.word	0x20000858
 80044b4:	20000828 	.word	0x20000828
 80044b8:	40023000 	.word	0x40023000
 80044bc:	0803e800 	.word	0x0803e800
 80044c0:	2000082c 	.word	0x2000082c
 80044c4:	20000800 	.word	0x20000800
	...

080044d0 <memmove>:
 80044d0:	4288      	cmp	r0, r1
 80044d2:	b5f0      	push	{r4, r5, r6, r7, lr}
 80044d4:	d90d      	bls.n	80044f2 <memmove+0x22>
 80044d6:	188b      	adds	r3, r1, r2
 80044d8:	4298      	cmp	r0, r3
 80044da:	d20a      	bcs.n	80044f2 <memmove+0x22>
 80044dc:	1881      	adds	r1, r0, r2
 80044de:	2a00      	cmp	r2, #0
 80044e0:	d054      	beq.n	800458c <memmove+0xbc>
 80044e2:	1a9a      	subs	r2, r3, r2
 80044e4:	f813 4d01 	ldrb.w	r4, [r3, #-1]!
 80044e8:	4293      	cmp	r3, r2
 80044ea:	f801 4d01 	strb.w	r4, [r1, #-1]!
 80044ee:	d1f9      	bne.n	80044e4 <memmove+0x14>
 80044f0:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80044f2:	2a0f      	cmp	r2, #15
 80044f4:	d948      	bls.n	8004588 <memmove+0xb8>
 80044f6:	ea40 0301 	orr.w	r3, r0, r1
 80044fa:	079b      	lsls	r3, r3, #30
 80044fc:	d147      	bne.n	800458e <memmove+0xbe>
 80044fe:	4615      	mov	r5, r2
 8004500:	f100 0410 	add.w	r4, r0, #16
 8004504:	f101 0310 	add.w	r3, r1, #16
 8004508:	f853 6c10 	ldr.w	r6, [r3, #-16]
 800450c:	3d10      	subs	r5, #16
 800450e:	f844 6c10 	str.w	r6, [r4, #-16]
 8004512:	f853 6c0c 	ldr.w	r6, [r3, #-12]
 8004516:	2d0f      	cmp	r5, #15
 8004518:	f844 6c0c 	str.w	r6, [r4, #-12]
 800451c:	f853 6c08 	ldr.w	r6, [r3, #-8]
 8004520:	f104 0410 	add.w	r4, r4, #16
 8004524:	f844 6c18 	str.w	r6, [r4, #-24]
 8004528:	f853 6c04 	ldr.w	r6, [r3, #-4]
 800452c:	f103 0310 	add.w	r3, r3, #16
 8004530:	f844 6c14 	str.w	r6, [r4, #-20]
 8004534:	d8e8      	bhi.n	8004508 <memmove+0x38>
 8004536:	f1a2 0310 	sub.w	r3, r2, #16
 800453a:	f023 030f 	bic.w	r3, r3, #15
 800453e:	f002 0e0f 	and.w	lr, r2, #15
 8004542:	3310      	adds	r3, #16
 8004544:	f1be 0f03 	cmp.w	lr, #3
 8004548:	4419      	add	r1, r3
 800454a:	4403      	add	r3, r0
 800454c:	d921      	bls.n	8004592 <memmove+0xc2>
 800454e:	460e      	mov	r6, r1
 8004550:	4674      	mov	r4, lr
 8004552:	1f1d      	subs	r5, r3, #4
 8004554:	f856 7b04 	ldr.w	r7, [r6], #4
 8004558:	3c04      	subs	r4, #4
 800455a:	2c03      	cmp	r4, #3
 800455c:	f845 7f04 	str.w	r7, [r5, #4]!
 8004560:	d8f8      	bhi.n	8004554 <memmove+0x84>
 8004562:	f1ae 0404 	sub.w	r4, lr, #4
 8004566:	f024 0403 	bic.w	r4, r4, #3
 800456a:	3404      	adds	r4, #4
 800456c:	4423      	add	r3, r4
 800456e:	4421      	add	r1, r4
 8004570:	f002 0203 	and.w	r2, r2, #3
 8004574:	b152      	cbz	r2, 800458c <memmove+0xbc>
 8004576:	3b01      	subs	r3, #1
 8004578:	440a      	add	r2, r1
 800457a:	f811 4b01 	ldrb.w	r4, [r1], #1
 800457e:	4291      	cmp	r1, r2
 8004580:	f803 4f01 	strb.w	r4, [r3, #1]!
 8004584:	d1f9      	bne.n	800457a <memmove+0xaa>
 8004586:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8004588:	4603      	mov	r3, r0
 800458a:	e7f3      	b.n	8004574 <memmove+0xa4>
 800458c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800458e:	4603      	mov	r3, r0
 8004590:	e7f1      	b.n	8004576 <memmove+0xa6>
 8004592:	4672      	mov	r2, lr
 8004594:	e7ee      	b.n	8004574 <memmove+0xa4>
 8004596:	bf00      	nop
	...

080045a0 <memset>:
 80045a0:	b470      	push	{r4, r5, r6}
 80045a2:	0784      	lsls	r4, r0, #30
 80045a4:	d046      	beq.n	8004634 <memset+0x94>
 80045a6:	1e54      	subs	r4, r2, #1
 80045a8:	2a00      	cmp	r2, #0
 80045aa:	d041      	beq.n	8004630 <memset+0x90>
 80045ac:	b2cd      	uxtb	r5, r1
 80045ae:	4603      	mov	r3, r0
 80045b0:	e002      	b.n	80045b8 <memset+0x18>
 80045b2:	1e62      	subs	r2, r4, #1
 80045b4:	b3e4      	cbz	r4, 8004630 <memset+0x90>
 80045b6:	4614      	mov	r4, r2
 80045b8:	f803 5b01 	strb.w	r5, [r3], #1
 80045bc:	079a      	lsls	r2, r3, #30
 80045be:	d1f8      	bne.n	80045b2 <memset+0x12>
 80045c0:	2c03      	cmp	r4, #3
 80045c2:	d92e      	bls.n	8004622 <memset+0x82>
 80045c4:	b2cd      	uxtb	r5, r1
 80045c6:	ea45 2505 	orr.w	r5, r5, r5, lsl #8
 80045ca:	2c0f      	cmp	r4, #15
 80045cc:	ea45 4505 	orr.w	r5, r5, r5, lsl #16
 80045d0:	d919      	bls.n	8004606 <memset+0x66>
 80045d2:	4626      	mov	r6, r4
 80045d4:	f103 0210 	add.w	r2, r3, #16
 80045d8:	3e10      	subs	r6, #16
 80045da:	2e0f      	cmp	r6, #15
 80045dc:	f842 5c10 	str.w	r5, [r2, #-16]
 80045e0:	f842 5c0c 	str.w	r5, [r2, #-12]
 80045e4:	f842 5c08 	str.w	r5, [r2, #-8]
 80045e8:	f842 5c04 	str.w	r5, [r2, #-4]
 80045ec:	f102 0210 	add.w	r2, r2, #16
 80045f0:	d8f2      	bhi.n	80045d8 <memset+0x38>
 80045f2:	f1a4 0210 	sub.w	r2, r4, #16
 80045f6:	f022 020f 	bic.w	r2, r2, #15
 80045fa:	f004 040f 	and.w	r4, r4, #15
 80045fe:	3210      	adds	r2, #16
 8004600:	2c03      	cmp	r4, #3
 8004602:	4413      	add	r3, r2
 8004604:	d90d      	bls.n	8004622 <memset+0x82>
 8004606:	461e      	mov	r6, r3
 8004608:	4622      	mov	r2, r4
 800460a:	3a04      	subs	r2, #4
 800460c:	2a03      	cmp	r2, #3
 800460e:	f846 5b04 	str.w	r5, [r6], #4
 8004612:	d8fa      	bhi.n	800460a <memset+0x6a>
 8004614:	1f22      	subs	r2, r4, #4
 8004616:	f022 0203 	bic.w	r2, r2, #3
 800461a:	3204      	adds	r2, #4
 800461c:	4413      	add	r3, r2
 800461e:	f004 0403 	and.w	r4, r4, #3
 8004622:	b12c      	cbz	r4, 8004630 <memset+0x90>
 8004624:	b2c9      	uxtb	r1, r1
 8004626:	441c      	add	r4, r3
 8004628:	f803 1b01 	strb.w	r1, [r3], #1
 800462c:	42a3      	cmp	r3, r4
 800462e:	d1fb      	bne.n	8004628 <memset+0x88>
 8004630:	bc70      	pop	{r4, r5, r6}
 8004632:	4770      	bx	lr
 8004634:	4614      	mov	r4, r2
 8004636:	4603      	mov	r3, r0
 8004638:	e7c2      	b.n	80045c0 <memset+0x20>
 800463a:	bf00      	nop
 800463c:	0000      	movs	r0, r0
	...

08004640 <ram_areas>:
 8004640:	49dc 0800 1144 2000 1144 2000 1144 2000     .I..D.. D.. D.. 
 8004650:	49dc 0800 0000 0000 0000 0000 0000 0000     .I..............
 8004660:	49dc 0800 0000 0000 0000 0000 0000 0000     .I..............
 8004670:	49dc 0800 0000 0000 0000 0000 0000 0000     .I..............
 8004680:	49dc 0800 0000 0000 0000 0000 0000 0000     .I..............
 8004690:	49dc 0800 0000 0000 0000 0000 0000 0000     .I..............
 80046a0:	49dc 0800 0000 0000 0000 0000 0000 0000     .I..............
 80046b0:	49dc 0800 0000 0000 0000 0000 0000 0000     .I..............

080046c0 <vmt>:
 80046c0:	1cc1 0800 1ca1 0800 1d01 0800 1ce1 0800     ................
 80046d0:	1cf1 0800 1cd1 0800 1cb1 0800 1c91 0800     ................

080046e0 <zero_status>:
	...

080046f0 <active_status>:
	...

08004700 <halted_status>:
 8004700:	0001 0000 0000 0000 0000 0000 0000 0000     ................

08004710 <_stm32_dma_streams>:
 8004710:	0000 4002 0008 4002 0001 0000 0000 0000     ...@...@........
 8004720:	0000 000b 0000 4002 001c 4002 0002 0000     .......@...@....
 8004730:	0000 0000 0104 000c 0000 4002 0030 4002     ...........@0..@
 8004740:	0004 0000 0000 0000 0208 000d 0000 4002     ...............@
 8004750:	0044 4002 0008 0000 0000 0000 030c 000e     D..@............
 8004760:	0000 4002 0058 4002 0010 0000 0000 0000     ...@X..@........
 8004770:	0410 000f 0000 4002 006c 4002 0020 0000     .......@l..@ ...
 8004780:	0000 0000 0514 0010 0000 4002 0080 4002     ...........@...@
 8004790:	0040 0000 0000 0000 0618 0011 0400 4002     @..............@
 80047a0:	0408 4002 0080 0000 0000 0000 0700 0038     ...@..........8.
 80047b0:	0400 4002 041c 4002 0100 0000 0000 0000     ...@...@........
 80047c0:	0804 0039 0400 4002 0430 4002 0200 0000     ..9....@0..@....
 80047d0:	0000 0000 0908 003a 0400 4002 0444 4002     ......:....@D..@
 80047e0:	0c00 0000 0000 0000 0a0c 003b 0400 4002     ..........;....@
 80047f0:	0458 4002 0c00 0000 0000 0000 0b10 003b     X..@..........;.

08004800 <default_config>:
 8004800:	c200 0001 0000 4000 0000 0000 0000 0000     .......@........

08004810 <ep0config>:
 8004810:	0000 0000 1f61 0800 2271 0800 2321 0800     ....a...q"..!#..
 8004820:	0040 0040 0d54 2000 0d54 2000 0001 0000     @.@.T.. T.. ....
 8004830:	0d64 2000 0000 0000 0000 0000 0000 0000     d.. ............

08004840 <pal_default_config>:
 8004840:	ffff ffff aaaa aa08 4000 a884 ffff ffff     .........@......
 8004850:	48aa ff24 ffaa 8822 ffff ffff 8000 aa88     .H$...".........
 8004860:	4aaa 8888 ffff ffff 8844 8888 8888 8888     .J......D.......
 8004870:	ffff ffff 8888 8888 8888 8888 ffff ffff     ................
 8004880:	8888 8888 8888 8888 ffff ffff 8888 8888     ................
 8004890:	8888 8888 0000 0000 0000 0000 0000 0000     ................
 80048a0:	6e28 6c75 296c 0000 0000 0000 0000 0000     (null)..........

080048b0 <pow10>:
 80048b0:	000a 0000 0064 0000 03e8 0000 2710 0000     ....d........'..
 80048c0:	86a0 0001 4240 000f 9680 0098 e100 05f5     ....@B..........
 80048d0:	ca00 3b9a 0000 0000 0000 0000 0000 0000     ...;............
 80048e0:	6f77 0a31 0000 0000 6f77 0a32 0000 0000     wo1.....wo2.....
